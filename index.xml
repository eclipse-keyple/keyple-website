<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Eclipse Keyple</title><link>https://keyple.org/</link><atom:link href="https://keyple.org/index.xml" rel="self" type="application/rss+xml"/><description>Eclipse Keyple</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright © Eclipse Foundation, Inc. All Rights Reserved.</copyright><lastBuildDate>Tue, 26 Jan 2021 14:57:56 +0200</lastBuildDate><image><url>https://keyple.org/images/logo_hu673a59176cd62c570f44ed2728665b48_42188_300x300_fit_lanczos_2.png</url><title>Eclipse Keyple</title><link>https://keyple.org/</link></image><item><title>Add your support &amp; trainings</title><link>https://keyple.org/support-trainings/add-support-trainings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/support-trainings/add-support-trainings/</guid><description>&lt;p>To add your support &amp;amp; trainings made a
&lt;a href="https://github.com/eclipse/keyple-website/pulls" target="_blank" rel="noopener">Pull request&lt;/a> contributions on GitHub.&lt;/p>
&lt;p>In order for your contribution to be accepted you must comply with one of the conditions below:&lt;/p>
&lt;ul>
&lt;li>Be a commiter of Eclipse Keyple™ project&lt;/li>
&lt;li>Having contributed to one of the components of Eclipse Keyple™ project&lt;/li>
&lt;li>Be a
&lt;a href="https://iot.eclipse.org/adopters/" target="_blank" rel="noopener">adopter/user&lt;/a> of Eclipse Keyple™&lt;/li>
&lt;/ul></description></item><item><title>Keyple Calypso</title><link>https://keyple.org/components-cpp/extensions/calypso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-cpp/extensions/calypso/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>0.9.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/tree/master/component/keyple-calypso">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Calypso&lt;/strong> C++ component is a Keyple reader extension for &lt;strong>Calypso®&lt;/strong> technology.&lt;/p>
&lt;p>It can be used on &lt;strong>PC&lt;/strong> and &lt;strong>MAC&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/calypso-application/">Developer guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All sources are available on
&lt;a href="https://github.com/eclipse/keyple-cpp/" target="_blank" rel="noopener">GitHub&lt;/a>.&lt;/p></description></item><item><title>Keyple Calypso</title><link>https://keyple.org/components-java/extensions/calypso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/extensions/calypso/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-calypso">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Calypso&lt;/strong> Java component is a Keyple reader extension for &lt;strong>Calypso®&lt;/strong> technology.&lt;/p>
&lt;p>It can be used on &lt;strong>PC&lt;/strong>, &lt;strong>MAC&lt;/strong> and &lt;strong>Android&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/calypso-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-calypso/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-calypso&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-calypso" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Distributed Local</title><link>https://keyple.org/components-java/distributed-systems/local/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/distributed-systems/local/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-distributed/local">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed Local&lt;/strong> Java component is the part of the &lt;strong>Keyple Distributed&lt;/strong> solution which contains all the &lt;strong>local&lt;/strong> services.&lt;/p>
&lt;p>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/p>
&lt;p>It is important to note that it uses and exposes the APIs exposed by
&lt;a href="./components-java/distributed-systems/network/">Keyple Distributed Network&lt;/a> component.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC&lt;/strong>, &lt;strong>MAC&lt;/strong> and &lt;strong>Android&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/distributed-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-distributed-local/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-distributed-local:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-distributed-local&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-distributed-local" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Distributed Network</title><link>https://keyple.org/components-java/distributed-systems/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/distributed-systems/network/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-distributed/network">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed Network&lt;/strong> Java component is the part of the &lt;strong>Keyple Distributed&lt;/strong> solution which contains the common network elements used by
&lt;a href="./components-java/distributed-systems/local/">Keyple Distributed Local&lt;/a> and
&lt;a href="./components-java/distributed-systems/remote/">Keyple Distributed Remote&lt;/a> components.&lt;/p>
&lt;p>This library &lt;strong>should not be import explicitly because it&amp;rsquo;s imported by transitivity&lt;/strong> by the other components.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC&lt;/strong>, &lt;strong>MAC&lt;/strong> and &lt;strong>Android&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/distributed-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-distributed-network/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-distributed-network:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-distributed-network&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-distributed-network" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Plugin NFC</title><link>https://keyple.org/components-java/plugins/nfc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/plugins/nfc/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/android/keyple-plugin/android-nfc">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin NFC&lt;/strong> Java component is a Keyple plugin for &lt;strong>Android&lt;/strong> devices having &lt;strong>NFC&lt;/strong> capabilities.&lt;/p>
&lt;p>It is compatible with &lt;strong>Android 4.4 minimum&lt;/strong>.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-android-plugin-nfc/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-android-plugin-nfc:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-android-plugin-nfc&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-android-plugin-nfc" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Plugin OMAPI</title><link>https://keyple.org/components-java/plugins/omapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/plugins/omapi/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/android/keyple-plugin/android-omapi">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin OMAPI&lt;/strong> Java component is a Keyple plugin for &lt;strong>Android&lt;/strong> devices using &lt;strong>OMAPI&lt;/strong> technology.&lt;/p>
&lt;p>It is compatible with &lt;strong>Android 4.4 minimum&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>OMAPI (Open Mobile Application Programming Interface)&lt;/strong> is the mechanism which enables an authorized mobile app to communicate with applets within a &lt;strong>SE&lt;/strong> in a device.
This allows the app to benefit from enhanced SE-based security services.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-android-plugin-omapi/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-android-plugin-omapi:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-android-plugin-omapi&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-android-plugin-omapi" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Overview</title><link>https://keyple.org/what-is-keyple/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/what-is-keyple/overview/</guid><description>&lt;p>Coming from a rather closed technical environment, ticketing for transport is essentially based on proprietary solutions provided by manufacturers.
However, in order for the concept of Mobility as a Service to become a reality, and at a reasonable cost, the ecosystem should, as far as possible,
rely on open standards, APIs and SDKs as well as Open Source technologies. This openness has already been a reality for several years in the field
of passenger information and has enabled the explosion of rich and high-quality applications, thanks in particular to Open Data. Today, Eclipse
Keyple™ is paving the way for ticketing to follow the same path, by making available for free the first fully Open Source API.&lt;/p>
&lt;p>Eclipse Keyple™ accelerates the integration and development of ticketing applications by enabling multimodal transport services, public transport
operators and event organizers to implement ticketing and access control systems based on a common, open and modular base.&lt;/p>
&lt;p>Eclipse Keyple™ works with Keyple&amp;rsquo;s extensions. The first available extension allows you to benefit from Calypso®'s main features of reliability,
security and interoperability.&lt;/p>
&lt;p>Eclipse Keyple™ transforms complex contactless ticketing, transportation and event access systems into a simple integration to manage terminal
readers and portals that use smart cards and mobile applications to enter and exit.&lt;/p>
&lt;p>As an open source technology, Eclipse Keyple™ offers uniformity of structure but does not lock you into a specific ticketing system. Plugins and
extensions are being created, or may be created by developers, to allow ticket processing integrating technologies other than Calypso®, based on
several programming languages.&lt;/p></description></item><item><title>Keyple Plugin PC/SC</title><link>https://keyple.org/components-cpp/plugins/pcsc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-cpp/plugins/pcsc/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>0.9.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/tree/master/component/keyple-plugin/pcsc">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin PC/SC&lt;/strong> C++ component is a Keyple plugin for &lt;strong>PC/SC&lt;/strong> smart card readers.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC/SC Reader&lt;/strong> (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All sources are available on
&lt;a href="https://github.com/eclipse/keyple-cpp/" target="_blank" rel="noopener">GitHub&lt;/a>.&lt;/p></description></item><item><title>Keyple Plugin PC/SC</title><link>https://keyple.org/components-java/plugins/pcsc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/plugins/pcsc/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-plugin/pcsc">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin PC/SC&lt;/strong> Java component is a Keyple plugin for &lt;strong>PC/SC&lt;/strong> smart card readers.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC/SC Reader&lt;/strong> (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-plugin-pcsc/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-plugin-pcsc&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-plugin-pcsc" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Distributed Remote</title><link>https://keyple.org/components-java/distributed-systems/remote/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/distributed-systems/remote/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-distributed/remote">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed Remote&lt;/strong> Java component is the part of the &lt;strong>Keyple Distributed&lt;/strong> solution which contains all the &lt;strong>remote&lt;/strong> plugins.&lt;/p>
&lt;p>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/p>
&lt;p>It is important to note that it uses and exposes the APIs exposed by
&lt;a href="./components-java/distributed-systems/network/">Keyple Distributed Network&lt;/a> component.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC&lt;/strong>, &lt;strong>MAC&lt;/strong> and &lt;strong>Android&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/distributed-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-distributed-remote/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-distributed-remote:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-distributed-remote&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-distributed-remote" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Keyple Plugin Stub</title><link>https://keyple.org/components-cpp/plugins/stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-cpp/plugins/stub/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>0.9.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/tree/master/component/keyple-plugin/stub">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-cpp/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin Stub&lt;/strong> C++ component is a Keyple plugin used to &lt;strong>stub&lt;/strong> smart card readers.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC&lt;/strong> and &lt;strong>MAC&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All sources are available on
&lt;a href="https://github.com/eclipse/keyple-cpp/" target="_blank" rel="noopener">GitHub&lt;/a>.&lt;/p></description></item><item><title>Keyple Plugin Stub</title><link>https://keyple.org/components-java/plugins/stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/components-java/plugins/stub/</guid><description>&lt;div class="alert alert-note">
&lt;div>
&lt;strong>&lt;code>1.0.0&lt;/code>&lt;/strong>
     
&lt;i class="fas fa-users-cog pr-1 fa-fw">&lt;/i>
Keyple project
     
&lt;i class="fas fa-download pr-1 fa-fw">&lt;/i>
&lt;a href="#download">Download&lt;/a>
     
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-plugin/stub">GitHub&lt;/a>
     
&lt;i class="fas fa-exchange-alt pr-1 fa-fw">&lt;/i>
&lt;a href="https://github.com/eclipse/keyple-java/releases/">Changelogs&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The &lt;strong>Keyple Plugin Stub&lt;/strong> Java component is a Keyple plugin used to &lt;strong>stub&lt;/strong> smart card readers.&lt;/p>
&lt;p>It is compatible with &lt;strong>PC&lt;/strong>, &lt;strong>MAC&lt;/strong> and &lt;strong>Android&lt;/strong> platforms.&lt;/p>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./docs/developer-guide/standalone-application/">Developer guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs/api-reference/java-api/keyple-java-plugin-stub/1.0.0/index.html">JavaDoc API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>All deliverables are available on the
&lt;a href="https://search.maven.org/" target="_blank" rel="noopener">Maven Central Repository&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Using
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-java-plugin-stub:1.0.0'
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Using
&lt;a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-xml">&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.eclipse.keyple&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;keyple-java-plugin-stub&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Direct
&lt;a href="https://search.maven.org/search?q=a:keyple-java-plugin-stub" target="_blank" rel="noopener">download&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso Networks Association</title><link>https://keyple.org/support-trainings/cna/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/support-trainings/cna/</guid><description>&lt;p>Calypso Networks Association (CNA) is a non-profit organization dedicated to improve contactless
electronic ticketing for transportation and access control standards since 2003.
For many years, our mission has been to create innovative solutions that are fully interoperable,
reliable, secure, and open. We collaborate with a dynamic network of city leaders and transport
authorities that are keen to work with system integrators with Calypso® standard expertise.&lt;/p>
&lt;p>Discover more about CNA here : &lt;a href="http://calypsonet.org">http://calypsonet.org&lt;/a>&lt;/p>
&lt;p>Calypso Networks Association offers comprehensive
&lt;a href="https://calypsonet.org/technical-support-documentation/" target="_blank" rel="noopener">technical support and documentation&lt;/a>
to ensure all users can get the most out of Calypso® technology and Eclipse Keyple™.&lt;/p>
&lt;p>Calypso Networks Association provides a Calypso Test Kit. The Calypso Test Kit aims at helping
ticketing system developers to fully experience Eclipse Keyple™ with a set of Calypso® SAM and
Calypso® certified portable objects from several manufacturers in various configurations.&lt;/p></description></item><item><title>Why trust Eclipse Keyple™?</title><link>https://keyple.org/what-is-keyple/why-trust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/what-is-keyple/why-trust/</guid><description>&lt;p>Eclipse Keyple™ is an Eclipse open source project currently leaded by Calypso Networks Association, which has been the leader in contactless
electronic ticketing transportation standards since 2003.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/3CWNho1rrSw" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Free, easy-to-use and flexible&lt;/th>
&lt;th>Built by developers, for developers&lt;/th>
&lt;th>Tailored to public entities requirements&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Interoperable with any smart card reader solution (standard/proprietary, local/remote)&lt;/td>
&lt;td>Open source libraries in Java and C++&lt;/td>
&lt;td>Audit and certification&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Compatible with any terminal architecture (mobile, embedded, server)&lt;/td>
&lt;td>Developer-friendly, up-to-date documentation, code samples and how-to guides&lt;/td>
&lt;td>Permanent compliance to the latest Calypso® release&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Options for creating add-on features that incorporate Calypso’s advanced security together with non-Calypso smart cards for ticketing and payment&lt;/td>
&lt;td>Accredited and hosted by the Eclipse foundation&lt;/td>
&lt;td>Exchange platform between providers and transport authorities&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Help desk-Separate maintenance for software and equipment&lt;/td>
&lt;td>Online and offline trainings available that will help you get the most of Keyple™&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Active on GitHub and within the Eclipse community&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Who is it for?</title><link>https://keyple.org/what-is-keyple/who-is-it-for/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/what-is-keyple/who-is-it-for/</guid><description>&lt;p>Whether you are a transport authority or operator, a mobility provider, a system integrator, an event manager, a mobility aggregator
or a multi-mobility startup, Eclipse Keyple™ allows you to:&lt;/p>
&lt;ul>
&lt;li>Reduce your costs and accelerate your developments.&lt;/li>
&lt;li>Facilitate the integration of new services or technologies.&lt;/li>
&lt;li>Use libraries to enable instant payments, remote top-ups, event and multimodal transport integrations, connection to park-and-ride services, and more.&lt;/li>
&lt;li>Easily create applications or services compatible with existing card-centric or server-centric systems.&lt;/li>
&lt;li>Benefit from a more diverse and easily collaborative network that encourages coopetition in a multimodal market: compete where you can, collaborate when necessary to create integrated mobility customer journeys.&lt;/li>
&lt;li>Harness the flexibility to introduce modern, mobile and new architecture systems while maintaining integrations to legacy infrastructure.&lt;/li>
&lt;li>Ensure the sustainability and future-proofing of your ticketing system, as Keyple™ is compatible with any smart card reader and SIO-enabled terminal.&lt;/li>
&lt;li>Unchain from vendor lock in, black box and single provider systems to an open solution with access to multiple suppliers.&lt;/li>
&lt;li>Enable partnerships with multimodal transport, building facilities including parking, tourism operators and events to offer seamless, single ticketing across the end customer’s journey.&lt;/li>
&lt;/ul>
&lt;p>With Keyple Calypso extension:&lt;/p>
&lt;ul>
&lt;li>Have easy access to a highly secure and interoperable standard, Calypso®.&lt;/li>
&lt;li>Quickly build new apps and integrations that conform to the Calypso® standard and other ticketing schemas.&lt;/li>
&lt;li>Easily migrate from an existing, closed ticketing schemes to Calypso®, a high-end open ticketing, certified solution.&lt;/li>
&lt;li>Easily integrate with public transport providers that are using the Calypso® standard, today used in major cities around the world in over 25 countries.&lt;/li>
&lt;/ul></description></item><item><title>What is Calypso®?</title><link>https://keyple.org/what-is-keyple/what-is-calypso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/what-is-keyple/what-is-calypso/</guid><description>&lt;p>Calypso® is a set of specifications describing a fast and secure off-line contactless transaction, between a portable object and a terminal.
It has been created for public transport ticketing at the end of the 1990s by some European public transport operators or authority
(RATP and SNCF in Paris and all France, STIB in Brussels, OTLIS in Lisbon, ACTV in Venice, Konstanz in Germany), in order to create an open,
interoperable and secure standard independent from industrials to ensure a real competition.&lt;/p>
&lt;p>Today Calypso® represents 20% of the world market of contactless smart ticketing in more than 25 countries and over 170 cities globally.
It brings to his user a guarantee of security and interoperability which relies on a total compliance with existing standards
(ISO 14443, ISO 7816-4, Global Platform). The Calypso® standard is managed by the Calypso Networks Association (CNA),
which is led by transports operators and public authorities in order to ensure openness and independence from industrials
in confront of other proprietary schemes.&lt;/p>
&lt;p>Discover more about Calypso® here : &lt;a href="https://calypsonet.org/solutions-overview/">https://calypsonet.org/solutions-overview/&lt;/a>&lt;/p></description></item><item><title>Keyple's main features</title><link>https://keyple.org/what-is-keyple/main-features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/what-is-keyple/main-features/</guid><description>&lt;p>The goal of Eclipse Keyple™ is to allow developers to easily implement fast and secure off-line contactless transactions
(using NFC cards, mobile phones, …) based on ticket processing integrating technologies other than Calypso®the Calypso standard.&lt;/p>
&lt;p>More specifically, Keyple™ is a set of open source libraries that will initially be available in Java and C++,
designed on the same mutual Object-Oriented Model compatible with any terminal architecture: mobile, embedded
or server and Interoperable with any smart card reader solution: standard or proprietary, local or remote.&lt;/p>
&lt;p>To fully understand how Keyple™ works, it is important to discern two main components of contactless ticketing technology:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Smart Card Readers&lt;/strong>: Readers are situated at the entrance and exit of events, venues and transport sites.
For example, a smart card reader could be a terminal, a portable scanning laser gun, or a swipe tablet area that is embedded
into a door, vehicle or gate. Code is written for a terminal to set the parameters for allowing cards or apps to transmit
ticketing information data. Sometimes in a distributed architecture system design, the code for the reader is not on the
terminal, but in a cloud environment, so the reader sends the data to cloud-based architecture.&lt;/li>
&lt;li>&lt;strong>Ticketing application&lt;/strong>: This is behind-the-scenes code that is able to take the data from the smart card reader
and, in milliseconds real-time, analyze the balance of the ticket, confirm the permissions for entry, and update the data
on the ticket (for example, to confirm that the ticket holder can enter the gate or vehicle, and then to deduct the cost
of the journey and calculate the new balance).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>According to this scheme, Keyple™ defines two layers:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Smart Card readers&lt;/strong> are integrated through plugins implementing the SE Proxy API which manages the communications with
a smart card through any type of contactless or contact reader (local, remote, standard, proprietary…)&lt;/li>
&lt;li>&lt;strong>Ticketing applications&lt;/strong> relies on a high-level Calypso® processing API to manage Calypso® commands &amp;amp; security features.
This API uses the SE Proxy API to communicate with the reader&lt;/li>
&lt;/ul>
&lt;p>Keyple™ comes with dedicated plugins that integrate directly with smart card readers that have been built on standard
software interfaces including PC/SC, Android NFC reader, and Android OMAPI.&lt;/p>
&lt;p>In cases where there is a distributed architecture design, Keyple™ includes a Remote API plugin so that
a smart card terminal can be operated remotely, as if it were local to the terminal, and ensures that robust security and
speed is not sacrificed in a cloud-based system.&lt;/p>
&lt;p>The Calypso Processing API is also available as a Keyple™ extension. This component carries out the terminal processing
element of ticketing technology. Access to Calypso’s security features are automatically managed by the Keyple™ extension.&lt;/p></description></item><item><title>Global Solution</title><link>https://keyple.org/docs/architecture/keyple-global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/architecture/keyple-global/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The Eclipse Keyple solution provides currently 2 modules:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>Keyple Core&lt;/strong>, a universal smart card reader interface to manage the setting of smart card reader, the detection and the communication with smart card, and the selection of card application.&lt;/li>
&lt;li>the &lt;strong>Keyple Calypso&lt;/strong>, a first smart card solution extension built on the Keyple Core, dedicated to manage Calypso processing, Calypso card identification, card command generation, card data recovery, authentication with the secure session.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-architecture-global">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Global.svg" data-caption="Keyple Architecture Global">
&lt;img src="./media/architecture/Keyple_Architecture_Global.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Global
&lt;/figcaption>
&lt;/figure>
&lt;p>The Keyple Core provides 3 interfaces:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>Service API&lt;/strong>, to allow terminal application to handle reader &amp;amp; select card&lt;/li>
&lt;li>the &lt;strong>Card API&lt;/strong>, for APDU command transmission, card data parsing&lt;/li>
&lt;li>the &lt;strong>Plugin API&lt;/strong>, to integrate specific smart card reader solutions.&lt;/li>
&lt;/ul>
&lt;p>The Keyple Calypso extension provides the Calypso API: a high-level interface to manage Calypso card processing.&lt;/p>
&lt;hr>
&lt;h2 id="application-integration">Application integration&lt;/h2>
&lt;p>The Card API is a low-level interface to manage the transmission of APDU commands with a smart card.
A terminal application operating processing with a specific smart card solution could be implemented directly on top the Card API.&lt;/p>
&lt;figure id="figure-keyple-architecture-application-integration">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Application_Integration.svg" data-caption="Keyple Architecture Application Integration">
&lt;img src="./media/architecture/Keyple_Architecture_Application_Integration.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Application Integration
&lt;/figcaption>
&lt;/figure>
&lt;p>Another way offering a better abstraction on smart card technical settings could be to implement on the Card API a smart card solution library extension providing a high level interface: a specific Solution API.
This is how the Keyple Calypso extension has be defined, the Calypso API is a high level functional interface, which hides the low-level APDU operations.&lt;/p>
&lt;hr>
&lt;h2 id="reader-integration">Reader integration&lt;/h2>
&lt;h3 id="native-integration">native integration&lt;/h3>
&lt;p>The smart card readers could be directly integrated with the Keyple Core. By interfacing through the Plugin API, a specific plugin dedicated to a smart card reader solution, the Keyple Core could have the capability to fully manage the smart card readers corresponding to this native plugin.&lt;/p>
&lt;figure id="figure-keyple-architecture-reader-integration-native">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Reader_Integration_native.svg" data-caption="Keyple Architecture Reader Integration Native">
&lt;img src="./media/architecture/Keyple_Architecture_Reader_Integration_native.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Reader Integration Native
&lt;/figcaption>
&lt;/figure>
&lt;p>The Eclipse Keyple project provides the plugin for the main standard smart card reader solutions.&lt;/p>
&lt;figure id="figure-keyple-architecture-native-plugins">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Native_Plugins.svg" data-caption="Keyple Architecture Native Plugins">
&lt;img src="./media/architecture/Keyple_Architecture_Native_Plugins.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Native Plugins
&lt;/figcaption>
&lt;/figure>
&lt;ul>
&lt;li>The PC/SC plugin is available for both the Java and the C++ implementation of Eclipse Keyple, it allows to interface PC/SC reader on Windows, Linux and Mac OS.&lt;/li>
&lt;li>For Android devices the NFC plugin allows to operate the standard NFC interface to handle external contactless smart card. And the OMAPI plugin provides the integration of internal eSE (embedded Secure Element) or UICC (SIM card). Both plugins support Keyple Java.&lt;/li>
&lt;li>The Remote plugin (part of the Core distributed extension) allows to operate remote smart card readers.&lt;/li>
&lt;/ul>
&lt;h3 id="hybrid-integration">hybrid integration&lt;/h3>
&lt;p>It&amp;rsquo;s also possible to integrate Keyple in a terminal solution already embedding not Keyple based terminal applications operating smart card solutions. In those kinds of terminal, a Reader Manager has already the direct control on a smart card reader and manage the smart card detection: depending on the type of smart card identified on the reader, a specific terminal application is requested to operated the processing of the smart card.&lt;/p>
&lt;figure id="figure-keyple-architecture-hybrid-plugins">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Reader_Integration_hybrid.svg" data-caption="Keyple Architecture Hybrid Plugins">
&lt;img src="./media/architecture/Keyple_Architecture_Reader_Integration_hybrid.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Hybrid Plugins
&lt;/figcaption>
&lt;/figure>
&lt;p>In this case a reader manager plugin, also based on the Plugin API, could allow the Keyple Core to operate the processing of a specific smart card, when requested by the Reader Manager.&lt;/p>
&lt;p>For example, an EMV certified reader manager could call a Keyple application in case of PPSE selection failure.&lt;/p>
&lt;hr>
&lt;h2 id="smart-card-processing">Smart card processing&lt;/h2>
&lt;h3 id="stand-alone">stand-alone&lt;/h3>
&lt;p>By default, a terminal application manages the processing of a specific smart card in stand-alone with its local readers.&lt;/p>
&lt;figure id="figure-keyple-architecture-local-plugin">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Local_Plugin.svg" data-caption="Keyple Architecture Local Plugin">
&lt;img src="./media/architecture/Keyple_Architecture_Local_Plugin.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Local Plugin
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="distributed">distributed&lt;/h3>
&lt;p>The &lt;strong>Distributed&lt;/strong> extension of the Keyple Core provides a solution allowing a master terminal application to manage the processing of a smart card localized in a remote driven terminal.
&lt;figure id="figure-keyple-architecture-remote-plugin">
&lt;a data-fancybox="" href="./media/architecture/Keyple_Architecture_Remote_Plugin.svg" data-caption="Keyple Architecture Remote Plugin">
&lt;img src="./media/architecture/Keyple_Architecture_Remote_Plugin.svg" alt="" >
&lt;/a>
&lt;figcaption>
Keyple Architecture Remote Plugin
&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;hr>
&lt;h2 id="smart-card-transaction">Smart card transaction&lt;/h2>
&lt;p>There are two ways for a terminal application to manage a transaction with a smart card.&lt;/p>
&lt;ul>
&lt;li>Either the smart card processing could be directly started by the terminal application.&lt;/li>
&lt;li>Otherwise, the smart card processing could be launched when a smart card is inserted in a reader of the terminal.&lt;/li>
&lt;/ul>
&lt;h3 id="explicit-selection">explicit selection&lt;/h3>
&lt;p>For a classic transaction,&lt;/p>
&lt;ul>
&lt;li>the presence of a card is firtsly checked on a reader,&lt;/li>
&lt;li>then the car is selected and identified,&lt;/li>
&lt;li>finally, a transaction is processed with the card application.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-transaction-explicit-selection">
&lt;a data-fancybox="" href="./media/architecture/Keyple_CardTransaction_ActivityDiag_ExplicitSelection.svg" data-caption="[Keyple Transaction Explicit Selection">
&lt;img src="./media/architecture/Keyple_CardTransaction_ActivityDiag_ExplicitSelection.svg" alt="" >
&lt;/a>
&lt;figcaption>
[Keyple Transaction Explicit Selection
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="default-selection">default selection&lt;/h3>
&lt;ul>
&lt;li>For automatons (e.g. a ticketing validator), the ticketing transaction is often driven by the insertion of a card.&lt;/li>
&lt;li>Keyple Core allows to define a default selection on Observable Reader, and in return to be notified of successful selections.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-transaction-default-selection">
&lt;a data-fancybox="" href="./media/architecture/Keyple_CardTransaction_ActivityDiag_DefaultSelection.svg" data-caption="[Keyple Transaction Default Selection">
&lt;img src="./media/architecture/Keyple_CardTransaction_ActivityDiag_DefaultSelection.svg" alt="" >
&lt;/a>
&lt;figcaption>
[Keyple Transaction Default Selection
&lt;/figcaption>
&lt;/figure></description></item><item><title>Keyple Core</title><link>https://keyple.org/docs/architecture/keyple-core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/architecture/keyple-core/</guid><description>&lt;hr>
&lt;h2 id="features--packages-and-corresponding-usages">Features / packages and corresponding usages&lt;/h2>
&lt;p>The Keyple Core is a tool to handle smart card reader and to operate generic processing with smart cards.&lt;/p>
&lt;p>The Core is divided in 3 sub-modules:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Service API&lt;/strong> : provides the interfaces to access to the smart card readers and to select a smart card.&lt;/li>
&lt;li>&lt;strong>Card API&lt;/strong> : for the transmission of APDU commands with a smart card.&lt;/li>
&lt;li>&lt;strong>Plugin API&lt;/strong> : includes the factorized processing for the implementation of plugin.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Module&lt;/th>
&lt;th>Package&lt;/th>
&lt;th>Feature&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td rowspan="4" width="13%">Service&lt;/td>
&lt;td width="38%">org.eclipse.keyple.core.&lt;b>service&lt;/b>&lt;/td>
&lt;td>Management of the smart card readers&lt;br/>
&lt;ul>&lt;li>Registration of plugins to the smart card Service&lt;br/>&lt;/li>
&lt;li>Access to the readers through plugins&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.service.&lt;b>event&lt;/b>&lt;/td>
&lt;td>Notifications of reader plug/unplug, of smart card insertion/removed&lt;br/>
&lt;ul>&lt;li>Define observers of plugins or readers&lt;br/>&lt;/li>
&lt;li>Interface to be implemented by observers to be notified on plugin event or reader event&lt;br/>&lt;/li>
&lt;li>For observable reader, setting of default selections, to automatically operate in case of smart card insertion&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.service.&lt;b>util&lt;/b>&lt;/td>
&lt;td>Communication protocols setting for contactless/contacts Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.card.&lt;b>selection&lt;/b>&lt;/td>
&lt;td>Generic selection of a smart card&lt;br/>
&lt;ul>&lt;li>preparation of smart card selection requests&lt;br>&lt;/li>
&lt;li>matching selection results as smart card images&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td rowspan="2">Smart card&lt;/td>
&lt;td>org.eclipse.keyple.card.&lt;b>message&lt;/b>&lt;/td>
&lt;td>Transmission of grouped APDU commands to a Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.card.&lt;b>command&lt;/b>&lt;/td>
&lt;td>Generic API to develop a smart card specific library&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Plugin&lt;/td>
&lt;td>org.eclipse.keyple.core.&lt;b>plugin&lt;/b>&lt;br/>
&lt;td>Reader plugins implementation&lt;br/>
&lt;ul>&lt;li>Utility classes providing generic processing for Readers &lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>According to the developer’s objective different packages must be imported:&lt;/p>
&lt;ul>
&lt;li>for the implementation of a smart card terminal application: the packages &lt;strong>service&lt;/strong>, &lt;strong>event&lt;/strong> and &lt;strong>selection&lt;/strong>.&lt;/li>
&lt;li>to develop a dedicated library supporting the command sets and transaction features of a specific smart card solution: the packages &lt;strong>message&lt;/strong>, &lt;strong>command&lt;/strong>, and &lt;strong>selection&lt;/strong>.&lt;/li>
&lt;li>to implement a plugin: the packages &lt;strong>plugin&lt;/strong>, &lt;strong>service&lt;/strong>, &lt;strong>event&lt;/strong>, and &lt;strong>message&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;figure id="figure-core-packages">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Packages.svg" data-caption="Core packages">
&lt;img src="./media/architecture/KeypleCore_Packages.svg" alt="" >
&lt;/a>
&lt;figcaption>
Core packages
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="service-interface---reader-access">Service Interface - Reader Access&lt;/h2>
&lt;p>for the development of ticketing terminal application&lt;/p>
&lt;h3 id="types-of-plugin--reader">Types of plugin &amp;amp; reader&lt;/h3>
&lt;p>On Keyple, the smart card readers are managed through plugins in order to integrate specific reader solutions.
The &lt;strong>SmartCard Service&lt;/strong> singleton provides the unique name list of registered plugins. There can be three kinds of plugin:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plugin&lt;/strong> is the generic interface to list the readers of a plugin, or to access to a specific reader with its name.&lt;/li>
&lt;li>The &lt;strong>Observable Plugin&lt;/strong> interface extends Plugins which have the capability to be observed: in order to notify registered Plugin Observers about the plug or unplug of readers. Plugin Observers could be added or removed to the Observable Plugin. Useful for systems allowing the hot plug / unplug of Readers.&lt;/li>
&lt;li>A &lt;strong>Pool Plugin&lt;/strong> is a plugin for which a Reader is available only after an explicit allocation. When not more necessary, a Reader must be released. Useful for server solutions managing farms of Readers or interfaced with HSM: unallocated Readers or HSM instances could be shared between several smartcard terminal solutions.&lt;/li>
&lt;/ul>
&lt;p>A smartcard Reader is identified through its unique name in a Plugin. There are two kinds of Reader:&lt;/p>
&lt;ul>
&lt;li>The &lt;strong>Reader&lt;/strong> is the generic interface to handle a smartcard reader. The presence of card in a Reader could be checked.&lt;/li>
&lt;li>The &lt;strong>Observable Reader&lt;/strong> interface extends Readers which have the capability to notify registered Reader Observers about the insertion or remove of a Card in the Reader. Reader Observers could be added or removed to the Observable Reader. Useful for systems automatically starting the processing of a Card at its insertion: like a ticketing validator.
&lt;figure id="figure-reader-access-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" data-caption="[Reader Access v1.0.0">
&lt;img src="./media/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
[Reader Access v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;p>(The APDU transmission with a Card is managed at a lower layer, through a Card Solution API.)&lt;/p>
&lt;h3 id="specific-plugin-integration">Specific Plugin integration&lt;/h3>
&lt;p>The Plugins are registered to the SmartCard Service through related specific Plugin Factory.
&lt;figure id="figure-specific-plugin-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Reader_ClassDiag_SpecificPluginFactoryAndProtocol_1_0_0.svg" data-caption="Specific Plugin v1.0.0">
&lt;img src="./media/architecture/KeypleCore_Reader_ClassDiag_SpecificPluginFactoryAndProtocol_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Specific Plugin v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="reader-notifications">Reader Notifications&lt;/h3>
&lt;p>To be notified about &lt;strong>Plugin Event&lt;/strong> or &lt;strong>Reader Event&lt;/strong>, a terminal application must implement the dedicated &lt;strong>Plugin Observer&lt;/strong> or &lt;strong>Reader Observer&lt;/strong> interfaces.&lt;/p>
&lt;figure id="figure-reader-notifications-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Reader_ClassDiag_ObservablePluginAndReaderEvents_1_0_0.svg" data-caption="Reader Notifications v1.0.0">
&lt;img src="./media/architecture/KeypleCore_Reader_ClassDiag_ObservablePluginAndReaderEvents_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Reader Notifications v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="plugin-event">Plugin Event&lt;/h3>
&lt;p>Several &lt;strong>Plugin Observers&lt;/strong> could be registered to an Observable Plugin.
In case of reader connection / disconnection, the Observable Plugin notifies sequentially the registered Plugin Observers with the corresponding Plugin Event.
The Observable Plugin is a blocking API, the thread managing the issuance of the Plugin Event waits the acknowledge of the Plugin Observer currently notified.&lt;/p>
&lt;h3 id="reader-event">Reader Event&lt;/h3>
&lt;p>Several &lt;strong>Reader Observers&lt;/strong> could be registered to an Observable Reader.
In case of Card insertion / removal or selection match, the Observable Reader notifies sequentially the registered Reader Observers with the corresponding Reader Event. The Observable Reader could be a blocking API, the thread managing the issuance of the Plugin Event could wait the acknowledge of the notified Reader Observers.&lt;/p>
&lt;p>An Observable Reader has the capability to be set with a &lt;strong>Default Selections Request&lt;/strong>: in this case when a Card is inserted in the Reader, the Reader will try to operate the configured default selections. If a selection successfully matches with the Card, instead to simply notify about the insertion of a Card, the Observable Reader will notify about a successful selection with a Card application.&lt;/p>
&lt;ul>
&lt;li>If the notification mode is defined as &lt;strong>always&lt;/strong>, then in case of Card insertion, the Observable Reader will notify a matched card Reader Event in case of successful selection, or a simple card insertion Reader Event if not.&lt;/li>
&lt;li>If the notification mode is defined as &lt;strong>matched only&lt;/strong>, then in case of Card insertion, simple card insertion Reader Events are not notified.&lt;/li>
&lt;/ul>
&lt;p>When the processing of an inserted or matched Card is finished, a Reader Observer must release the logical channel with the Card, in order to prepare the Observable Reader to detect the removal of the Card.&lt;/p>
&lt;h3 id="observable-reader-states">Observable Reader states&lt;/h3>
&lt;p>An Observable Reader is active only when at least one Reader Observer is registered, and if the start of the detection has been requested.
When active, an Observable Reader could switch between three internal states: &lt;strong>Wait for Card Insertion&lt;/strong>, &lt;strong>Wait for Card Processing&lt;/strong>, &amp;amp; &lt;strong>Wait for Card Removal&lt;/strong>.&lt;/p>
&lt;p>In the nominal case, a Reader Observer indicates to the Observable Reader that the processing of the SE is finished by releasing the Card Channel.
To manage a failure of the Reader Observer process, the Observable Reader interface provides also a method to finalize the Card processing.&lt;/p>
&lt;figure id="figure-observable-reader-states">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Reader_StateDiag_ObservableReaderStates_1_0_0.svg" data-caption="Observable Reader States">
&lt;img src="./media/architecture/KeypleCore_Reader_StateDiag_ObservableReaderStates_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Observable Reader States
&lt;/figcaption>
&lt;/figure>
&lt;p>The states could be switched:&lt;/p>
&lt;ul>
&lt;li>due to an explicit API request (blue arrows):
&lt;ul>
&lt;li>the release of the Card Channel,&lt;/li>
&lt;li>the call of an Observable Reader method:
&lt;ul>
&lt;li>the addition or the remove of an Observable Reader,&lt;/li>
&lt;li>a request to start or stop the detection, to finalize the Card processing.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Or because of an external event (red arrows), the insertion or the remove of a Card.
&lt;ul>
&lt;li>the insertion a Card causing the Observable Reader to notify a &lt;strong>Card matched&lt;/strong> Reader Event (in case of successful default selection) or a &lt;strong>Card inserted&lt;/strong> Reader Event (Notification Mode defined as always).&lt;/li>
&lt;li>the removal of a Card causing the Observable Reader to notify a &lt;strong>Card removed&lt;/strong> Reader Event.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>If a Card detection is started with the &lt;strong>repeating&lt;/strong> polling mode, then later when the Card is removed, the Reader starts again the detection of a new Card.&lt;/p>
&lt;p>Whatever the Plugin of Observable Reader, when waiting for the Card removal, any Observable Reader shall have the capability to notify the remove of the Card.
Some Plugin solutions could have the capability to notify a Card removal also during the processing of the Card.&lt;/p>
&lt;hr>
&lt;h2 id="service-interface---card-selection">Service Interface - Card Selection&lt;/h2>
&lt;p>for the development of ticketing terminal application&lt;/p>
&lt;h3 id="selection-scenarios">Selection scenarios&lt;/h3>
&lt;p>Depending on the Card transaction use case, or on the Reader capability, there are two ways to manage the Selection of a Card:&lt;/p>
&lt;ul>
&lt;li>Either on a simple Reader, a Selection could be operated directly by transmitting the Selection Request. In this case the same entity manages both the Card Selection and the Card processing.&lt;/li>
&lt;li>Otherwise, on an Observable Reader, a Default Selection could be defined. In this case the Selection is operated automatically at the insertion of the Card. In this case, the Card Selection is next managed by the Observable Reader, but the Card processing is managed by a Reader Observer.&lt;/li>
&lt;/ul>
&lt;figure id="figure-selection-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_CardSelection_ActivityDiag_Scenarii.svg" data-caption="Selection v1.0.0">
&lt;img src="./media/architecture/KeypleCore_CardSelection_ActivityDiag_Scenarii.svg" alt="" >
&lt;/a>
&lt;figcaption>
Selection v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="selection-setting-and-processing">Selection setting and processing&lt;/h3>
&lt;p>A Card Selection request is defined with a Card Selector. A Card Selector could be defined with tree optional levels of selection filter.&lt;/p>
&lt;ul>
&lt;li>The selection could be limited to match a specific card communication protocol.&lt;/li>
&lt;li>The Card ATR could be filtered to match a regular expression.&lt;/li>
&lt;li>If an AID is defined, the local reader transmits a Select Application APDU command to the card.
If a SE Selector is defined without any filter, the selection is always successful if a card is present in the reader.&lt;/li>
&lt;/ul>
&lt;p>Depending on the Keyple Card Solution extension library, a card request could be completed with specific card commands to operate at the selection (for example, a Select File for a specific DF LID, the read of a specific file).&lt;/p>
&lt;p>For terminal managing several kinds of card applications, a Card Selection could be prepared with several card selection request to operate sequentially with the card.&lt;/p>
&lt;p>According to the defined &lt;strong>multi selection processing&lt;/strong> mode, the card selection could stop at the first selection request matching card application, otherwise all the prepared card selection request could be operated.&lt;/p>
&lt;ul>
&lt;li>Before the new processing of card selection request, the logical channel previously opened is closed.&lt;/li>
&lt;li>The &lt;strong>channel control&lt;/strong> defines if the logical channel should be kept open or close after the last processed card selection request.&lt;/li>
&lt;/ul>
&lt;figure id="figure-card-selection-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" data-caption="Card Selection v1.0.0">
&lt;img src="./media/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Card Selection v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;p>The result of a card request selection is a card image of a matching card. For a card selection with multiple requests, several matching card could be provided.&lt;/p>
&lt;hr>
&lt;h2 id="card-interface">Card Interface&lt;/h2>
&lt;p>for the development of smartcard solution library&lt;/p>
&lt;p>The Keyple Calypso extension uses the card interface to exchange APDU commands with Calypso cards and SAM.&lt;/p>
&lt;h3 id="apdu-transmission">APDU Transmission&lt;/h3>
&lt;figure id="figure-apdu-transmission-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Card_ClassDiag_CardMessage_1_0_0.svg" data-caption="APDU Transmission v1.0.0">
&lt;img src="./media/architecture/KeypleCore_Card_ClassDiag_CardMessage_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
APDU Transmission v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="plugin-api">Plugin API&lt;/h2>
&lt;p>for the implementation of smartcard reader plugins&lt;/p>
&lt;h3 id="plugin-factorized-processing">Plugin Factorized Processing&lt;/h3>
&lt;p>The implementation of Plugins requires to extend the classes AbstractPlugin and AbstractLocalReader.&lt;/p>
&lt;ul>
&lt;li>If the reader solution allows the hot plug/unplug of readers then AbstractThreadedObservablePlugin should be extended.&lt;/li>
&lt;li>In case the local reader has the capability to detect the insertion or the removal or a card, then AbstractObservableLocalReader should be extended.&lt;/li>
&lt;/ul>
&lt;p>For reader solutions managing themselves the allocation of logical channel for communicatio with smart cards, the interface SmartSelectionReader should be implemented (e.g. it is the case for the OMAPI plugin).&lt;/p>
&lt;p>Only the abstract methods highlighted &lt;strong>in blue&lt;/strong> have to be implemented have to be implemented by the specific plugins.&lt;/p>
&lt;p>For plugins with ObservableReader: depending on the capability of the reader solution different interfaces could be implemented:&lt;/p>
&lt;ul>
&lt;li>WaitForCardInsertionAutonomous&lt;/li>
&lt;li>WaitForCardRemovalAutonomous&lt;/li>
&lt;li>WaitForCardRemovalDuringProcessing or DontWaitForCardRemovalDuringProcessing&lt;/li>
&lt;li>WaitForCardInsertionBlocking or WaitForCardInsertionNonBlocking&lt;/li>
&lt;li>WaitForCardRemovalBlocking or WaitForCardRemovalNonBlocking&lt;/li>
&lt;li>AbstractObservableLocalAutonomousReader&lt;/li>
&lt;/ul>
&lt;figure id="figure-plugin-factorized-processing-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Plugin_ClassDiag_PluginImplementaion_1_0_0.svg" data-caption="Plugin Factorized Processing v1.0.0">
&lt;img src="./media/architecture/KeypleCore_Plugin_ClassDiag_PluginImplementaion_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Plugin Factorized Processing v1.0.0
&lt;/figcaption>
&lt;/figure></description></item><item><title>Keyple Calypso</title><link>https://keyple.org/docs/architecture/keyple-calypso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/architecture/keyple-calypso/</guid><description>&lt;hr>
&lt;h2 id="features--packages-and-corresponding-usages">Features / packages and corresponding usages&lt;/h2>
&lt;p>The Calypso transaction API provides a high-level of abstraction to define functional commands to manage a secure session with a Calypso Portable Object, to update or authenticate its data.&lt;/p>
&lt;p>The transaction API is defined on a low-level Calypso commands API which contains the builders of PO and SAM APDU commands, and the corresponding parsers of APDU responses. This internal library is deprecated, and will be refactorized for the version 2.0.0 of Keyple Calypso.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Package&lt;/th>
&lt;th>API&lt;br/>level&lt;/th>
&lt;th>Feature&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td width="50%">org.eclipse.keyple.calypso.&lt;b>transaction&lt;/b>&lt;/td>
&lt;td width="8%">high&lt;/td>
&lt;td>Calypso Portable Object commands and secure transaction management&lt;br/>
&lt;ul>&lt;li>CalypsoAPI, command’s settings are limited to functional parameters&lt;br/>&lt;/li>
&lt;li>Calypso SAM (Secure Module) operations automatically processed&lt;br/>&lt;/li>&lt;/ul>
(only functional parameters)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.calypso.&lt;b>command&lt;/b>&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.builder&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.parser&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.parser.session&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.builder&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.parser&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.parser.session&lt;/td>
&lt;td>low&lt;/td>
&lt;td>Calypso PO &amp;amp; SAM APDU commands' sets&lt;br/>
&lt;ul>&lt;li>APDU command builders&lt;br/>&lt;/li>
&lt;li>APDU response parsers&lt;br/>&lt;/li>&lt;/ul>
(technical parameter settings specific to the PO &amp;amp; SAM revisions)&lt;br>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Ticketing terminal applications must import only the high-level Calypso transaction package.&lt;/p>
&lt;figure id="figure-calypso-packages">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Packages.svg" data-caption="Calypso packages">
&lt;img src="./media/architecture/KeypleCalypso_Packages.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso packages
&lt;/figcaption>
&lt;/figure>
&lt;!-- The only exception is the implementation a Calypso PO/SAM test tool, the setting of low-level APDU commands with wrong settings could require the usage of the Calypso command packages. -->
&lt;hr>
&lt;h2 id="calypso-portable-object-selection">Calypso Portable Object Selection&lt;/h2>
&lt;p>Compared to the generic Card Selection API (cf. &lt;a href="https://keyple.org/docs/architecture/keyple-core/#card-selection),">https://keyple.org/docs/architecture/keyple-core/#card-selection),&lt;/a> a PO Selector could be defined to accept only non-invalidated Portable Object (in this cas an invalidated PO isn&amp;rsquo;t selected).&lt;/p>
&lt;p>In addition, a PO Selection Request provides methods:&lt;/p>
&lt;ul>
&lt;li>to prepare Select File command (useful in particular to manage REV1 Calypso PO for which the select of the targeted DF is required).&lt;/li>
&lt;li>and to prepare simple read record command (useful to optimize the read of a file present on all targeted PO).&lt;/li>
&lt;/ul>
&lt;p>The matching SmartCard resulting from a PO Selection Request is a Calypso PO. In case file records have been read during the selection: the corresponding data could be recovered in the Calypso PO card image.&lt;/p>
&lt;figure id="figure-calypso-selection-v100">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_ClassDiag_PO_Selection_1_0_0.svg" data-caption="Calypso Selection v1.0.0">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_ClassDiag_PO_Selection_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso Selection v1.0.0
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="calypso-portable-object-transaction">Calypso Portable Object Transaction&lt;/h2>
&lt;p>A Card Resource is a set of a Reader and a &lt;strong>selected&lt;/strong> Card application.&lt;/p>
&lt;ul>
&lt;li>A Calypso Portable Object is the image of a selected Calypso PO.&lt;/li>
&lt;li>A Calypso SAM is the image of a selected Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>To operate a Calypso transaction:&lt;/p>
&lt;ul>
&lt;li>At least a Calypso Resource (CardResource&amp;lt;CalypsoPo&amp;gt;) is required.&lt;/li>
&lt;li>A SAM Resource ((CardResource&amp;lt;CalypsoSam&amp;gt;) is required too if security features are involved (Calypso secure session, Stored value transaction, PIN encryption, etc…).&lt;/li>
&lt;/ul>
&lt;p>A Calypso PO image provides public &lt;strong>getters&lt;/strong> in order to &lt;strong>recover&lt;/strong> the information of the selected PO (startup data, file data, … etc).&lt;/p>
&lt;p>A transaction with a Calypso PO is fully managed through the PoTransaction object:&lt;/p>
&lt;ul>
&lt;li>First a set of PO commands could be defined through &lt;strong>prepare&lt;/strong> commands.&lt;/li>
&lt;li>Next the prepared PO commands transmitted when operating a &lt;strong>process&lt;/strong> command.&lt;/li>
&lt;li>The responses of the PO are then recovered through the Calypso PO image.&lt;/li>
&lt;/ul>
&lt;figure id="figure-calypso-api-global-architecture">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_ClassDiag_Overview.svg" data-caption="Calypso API Global Architecture">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_ClassDiag_Overview.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso API Global Architecture
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="calypso-card-image">Calypso card image&lt;/h3>
&lt;p>When read commands have been exchanged with a Calypso PO, the corresponding data could be recovered by parsing the file structure of the PO card image.&lt;/p>
&lt;figure id="figure-calypso-po-card-image">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_ClassDiag_CalypsoPo_1_0_0.svg" data-caption="Calypso PO card image">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_ClassDiag_CalypsoPo_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso PO card image
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="calypso-transaction">Calypso transaction&lt;/h3>
&lt;p>Only the &lt;strong>process&lt;/strong> methods generate communication with the Calypso PO and SAM.&lt;/p>
&lt;ul>
&lt;li>processPoCommands is used to transmit a set of prepared PO commands (outside or inside a secure session).&lt;/li>
&lt;li>processOpening issues an Open Secure Session followed by the prepared PO commands.&lt;/li>
&lt;li>processClosing issues the last prepared PO commands and transmits a Close Secure Session.&lt;/li>
&lt;/ul>
&lt;!---
- prepareManageSession allows to change authenticate or change the encryption mode.
-->
&lt;p>The prepareReleaseChannel method allows to the logical channel with the Calypso PO at the end of the processing of the next process method.&lt;/p>
&lt;figure id="figure-calypso-transaction">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_ClassDiag_PoTransaction_1_0_0.svg" data-caption="Calypso transaction">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_ClassDiag_PoTransaction_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso transaction
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="data-model-extension">Data model extension&lt;/h2>
&lt;figure id="figure-calypso-data-model">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_ClassDiag_SpecificPoTransaction_1_0_0.svg" data-caption="Calypso Data Model">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_ClassDiag_SpecificPoTransaction_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso Data Model
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="secure-session-sequence">Secure session sequence&lt;/h2>
&lt;figure id="figure-calypso-session">
&lt;a data-fancybox="" href="./media/architecture/KeypleCalypso_Transaction_SequenceDiag_SecureSessionProcessing_1_0_0.svg" data-caption="Calypso session">
&lt;img src="./media/architecture/KeypleCalypso_Transaction_SequenceDiag_SecureSessionProcessing_1_0_0.svg" alt="" >
&lt;/a>
&lt;figcaption>
Calypso session
&lt;/figcaption>
&lt;/figure></description></item><item><title>Build your first Java application</title><link>https://keyple.org/docs/build-your-first-app/java-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/java-app/</guid><description>&lt;hr>
&lt;p>This quick start describes how to create a ready-to-execute Java
command-line application that runs a simple transaction based on
a Calypso portable object (PO) involving two smart card readers.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The demonstration application created for this quick start requires a
Calypo PO (contactless smart card, mobile phone with contactless
communication) and a Calypo Secure Access Module (SAM).
&lt;/div>
&lt;/div>
&lt;p>We will use three main components of Keyple:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/">Keyple Core&lt;/a>
which is the base component to which all the others refer,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-java/plugins/pcsc/">Keyple PC/SC plugin&lt;/a>
to provide the ability to manage PC/SC readers,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-java/extensions/calypso/">Keyple Calypso extension&lt;/a>
to handle the commands sent to the Calypso PO and the Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>In this guide
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a> is used as build automation
tool, but it is easy to transpose these explanations to another tool
such as Maven for example.&lt;/p>
&lt;p>The example can run on any machine: Linux, Windows and macOS. If not
installed in your machine, you will need to download :&lt;/p>
&lt;ul>
&lt;li>Java 1.6 or newer&lt;/li>
&lt;li>
&lt;a href="https://gradle.org/install/" target="_blank" rel="noopener">Gradle (any version)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>We recommend that you use a Java IDE like
&lt;a href="https://www.eclipse.org/ide/" target="_blank" rel="noopener">Eclipse&lt;/a> or
&lt;a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">Intellij IDEA&lt;/a> to create your new
Gradle project.&lt;/p>
&lt;hr>
&lt;h2 id="create-a-gradle-based-empty-project">Create a Gradle-based empty project&lt;/h2>
&lt;p>Create a new Java project and add the following statements to your
&lt;code>build.gradle&lt;/code> file to import the Keyple components into your
project:&lt;/p>
&lt;pre>&lt;code class="language-gradle">apply plugin: 'java'
repositories {
mavenCentral()
}
dependencies {
//Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core
implementation 'org.eclipse.keyple:keyple-java-core:1.0.0'
//Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso
implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0'
//Import PC/SC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc
implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'
//Import logger lib
implementation 'org.slf4j:slf4j-api:1.7.25'
implementation &amp;quot;org.slf4j:slf4j-simple:1.7.25&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>If necessary, also create the usual tree in which the Java code of this
guide will be placed, namely the folders: &lt;code>\src\main\java&lt;/code>&lt;/p>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;p>Now let&amp;rsquo;s see step by step how to create in one single class the
elements that allow a certified reading of data through a Calypso secure
session.&lt;/p>
&lt;p>In a real ticketing application, the organization of the code would
probably be different, but the point here is to show how Keyple makes it
possible to perform very simply operations that normally require a
quantity of code and knowledge that far exceeds what is implemented
here.&lt;/p>
&lt;p>You can either progressively copy each of the small portions of code
that follow or copy the whole class at the bottom of this page.&lt;/p>
&lt;h3 id="create-the-class-skeleton">Create the class skeleton&lt;/h3>
&lt;p>Copy the source code below in a new Java Class named
DemoPoAuthentication.&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.calypso.command.sam.SamRevision;
import org.eclipse.keyple.calypso.transaction.*;
import org.eclipse.keyple.core.card.selection.*;
import org.eclipse.keyple.core.service.*;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.plugin.pcsc.*;
public class DemoPoAuthentication {
public static void main(String[] args) {
// ...
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="configure-the-pcsc-plugin-and-the-readers">Configure the PC/SC plugin and the readers&lt;/h3>
&lt;p>The first step to use Keyple is to initialize the plugin and smart card readers.&lt;/p>
&lt;p>In this snippet the PC/SC plugin is registered to the SmartCardService.&lt;/p>
&lt;p>Two readers needs to be connected to the local machine. Replace
&amp;ldquo;PO_READER_NAME&amp;rdquo; and &amp;ldquo;SAM_READER_NAME&amp;rdquo; with the name of the USB readers.&lt;/p>
&lt;p>If you don&amp;rsquo;t know the names of the readers, read how to find them in the
&lt;a href="#faq">FAQ&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-java">//...
// Get the instance of the SmartCardService : main service of Keyple SDK
SmartCardService smartCardService = SmartCardService.getInstance();
// Register the PcscPlugin within the SmartCardService to use PC/SC readers
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory());
// Get the PO reader
PcscReader poReader = (PcscReader) plugin.getReader(&amp;quot;PO_READER_NAME&amp;quot;);
// Configure the PO reader parameters
poReader.setContactless(true);
// Get the SAM reader
PcscReader samReader = (PcscReader) plugin.getReader(&amp;quot;SAM_READER_NAME&amp;quot;);
// ...
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-sam">Select the Calypso SAM&lt;/h3>
&lt;p>Before executing a transaction each smart card should be selected. The
next step is the selection of the Calypso SAM resulting in a
CalypsoSam object.&lt;/p>
&lt;p>It is then combined with the SAM reader to form the SAM resource needed
later within the transaction service.&lt;/p>
&lt;pre>&lt;code class="language-java">//...
// Prepare a SamSelector that identifies the Calypso SAM
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build();
// Perform the SAM selection
CardSelectionService samSelection = new CardSelectionService();
samSelection.prepareSelection(new SamSelection(samSelector));
if (!samReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader.getName());
}
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
// Associate the calypsoSam and the samReader to create a samResource
CardResource&amp;lt;CalypsoSam&amp;gt; samResource = new CardResource&amp;lt;CalypsoSam&amp;gt;(samReader, calypsoSam);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-po">Select the Calypso PO&lt;/h3>
&lt;p>1st PO exchange:&lt;/p>
&lt;p>The Calypso PO selection is made using the portable object application&amp;rsquo;s AID
and results in a CalypsoPo object that will contain all the information extracted
from the Calypso PO all along the transaction.&lt;/p>
&lt;pre>&lt;code class="language-java">// Prepare a Calypso PO selection
final String AID = &amp;quot;315449432E49434131&amp;quot;; /* AID: Keyple test kit profile 1, Application 2 */
CardSelectionService cardSelectionService = new CardSelectionService();
// Setting up a selection based on the AID of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication protocol
PoSelection poSelection = new PoSelection(
PoSelector.builder()
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier
.invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not
.build());
// Add the selection case to the current selection
// (we could have added other cases)
cardSelectionService.prepareSelection(poSelection);
if (!poReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;The selection of the PO has failed.&amp;quot;);
}
// Perform the PO selection and get a CalypoPo container in return
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard();
//...
&lt;/code>&lt;/pre>
&lt;h3 id="open-the-calypso-secure-session">Open the Calypso secure session&lt;/h3>
&lt;p>2nd PO exchange :&lt;/p>
&lt;p>The secure session opening operated by the PoTransaction service is
combined with the reading of the environment file (SFI=07h).&lt;/p>
&lt;p>The mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.&lt;/p>
&lt;pre>&lt;code class="language-java">// Prepare the security settings used during the Calypso transaction
PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build();
// Create a PoTransaction service to manage the Calypso transaction
PoTransaction poTransaction = new PoTransaction(
new CardResource&amp;lt;CalypsoPo(poReader, calypsoPo),
poSecuritySettings);
final byte RECORD_NUMBER_1 = 1;
final byte SFI_Environment = (byte) 0x07;
// Schedule the reading of the Environment file after the secure session is opened
// (we could have added other commands)
poTransaction.prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Perform the session opening with the debit key
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the Environment data from the card image CalypsoPo
ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment);
String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent());
System.out.println(&amp;quot;Environment file content: &amp;quot;+ environmentLog);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="close-the-calypso-secure-session">Close the Calypso secure session&lt;/h3>
&lt;p>3rd PO exchange:&lt;/p>
&lt;p>Simply close the Calypso secure session&lt;/p>
&lt;p>The mutual authentication is finalized, it includes the authentication
of the data in the read file.&lt;/p>
&lt;p>Note: any technical, crytographic or content-related incident in the Calypso PO
would be signalled by an exception and would interrupt the thread of
execution.&lt;/p>
&lt;pre>&lt;code class="language-java">// Schedule the closure of the channel with the PO after the closing of the secure session
poTransaction.prepareReleasePoChannel();
// Perform the closing of the Calypso Secure Session
poTransaction.processClosing();
System.out.println(&amp;quot;The data read in session have been certified by the successful closing.&amp;quot;);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="unregister-the-plugin">Unregister the plugin&lt;/h3>
&lt;p>Finally unregister the plugin before shutting down the application&lt;/p>
&lt;pre>&lt;code class="language-java">// Shutdown the application
smartCardService.unregisterPlugin(plugin.getName());
System.exit(0);
&lt;/code>&lt;/pre>
&lt;p>Find the complete code source
&lt;a href="#full-code">below&lt;/a>.&lt;/p>
&lt;hr>
&lt;h2 id="run">Run&lt;/h2>
&lt;ol>
&lt;li>Connect two USB PC/SC Readers.&lt;/li>
&lt;li>Insert the Calypso SAM in the SAM reader.&lt;/li>
&lt;li>Insert the Calypso PO in the PO reader.&lt;/li>
&lt;li>Run the application.&lt;/li>
&lt;/ol>
&lt;div class="alert alert-note">
&lt;div>
All project dependencies, including Keyple
components, are downloaded during the first run, which can take some
time.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How do I find out the names of the readers?&lt;/strong>&lt;/p>
&lt;p>To find out the names of the readers connected to your computer, we will
use Keyple with the following class which prints in the console the
number and names of the readers present:&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.core.service.Plugin;
import org.eclipse.keyple.core.service.SmartCardService;
import org.eclipse.keyple.plugin.pcsc.PcscPluginFactory;
import java.util.Set;
public class ReaderDiscovery {
public static void main(String[] args) {
SmartCardService smartCardService = SmartCardService.getInstance();
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory());
Set&amp;lt;String&amp;gt; names = plugin.getReaderNames();
System.out.println(names.size() + &amp;quot; readers found.&amp;quot;);
for (String name : names) {
System.out.println('&amp;quot;' + name + '&amp;quot;');
}
}
}
&lt;/code>&lt;/pre>
&lt;p>The console output should look something like:&lt;/p>
&lt;pre>&lt;code>2 readers found.
&amp;quot;ASK LoGO 0&amp;quot;
&amp;quot;Identive CLOUD 2700 R Smart Card Reader 0&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Identify which reader will be the PO (contactless) reader and the SAM
(contact) reader and replace &lt;code>PO_READER_NAME&lt;/code> and
&lt;code>SAM_READER_NAME&lt;/code> with their values.&lt;/p>
&lt;p>&lt;strong>How to activate the Keyple&amp;rsquo;s logs?&lt;/strong>&lt;/p>
&lt;p>As soon as the &lt;code>slf4j&lt;/code> library is imported into the project, Keyple
modules are able to produce logs.&lt;/p>
&lt;p>However, to take full advantage of the possibilities of this library, it
is necessary to create a &lt;code>simplelogger.properties&lt;/code> file in the
&lt;code>/src/main/resources&lt;/code> folder of the project.&lt;/p>
&lt;p>The self-documented content of this file may be:&lt;/p>
&lt;pre>&lt;code># SLF4J's SimpleLogger configuration file
# Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err.
# Default logging detail level for all instances of SimpleLogger.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, defaults to &amp;quot;info&amp;quot;.
org.slf4j.simpleLogger.defaultLogLevel=debug
# Logging detail level for a SimpleLogger instance named &amp;quot;xxxxx&amp;quot;.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, the default logging detail level is used.
#org.slf4j.simpleLogger.log.xxxxx=
# Set to true if you want the current date and time to be included in output messages.
# Default is false, and will output the number of milliseconds elapsed since startup.
org.slf4j.simpleLogger.showDateTime=true
# The date and time format to be used in the output messages.
# The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat.
# If the format is not specified or is invalid, the default format is used.
# The default format is yyyy-MM-dd HH:mm:ss:SSS Z.
org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS]
# Set to true if you want to output the current thread name.
# Defaults to true.
org.slf4j.simpleLogger.showThreadName=true
# Set to true if you want the Logger instance name to be included in output messages.
# Defaults to true.
org.slf4j.simpleLogger.showLogName=false
# Set to true if you want the last component of the name to be included in output messages.
# Defaults to false.
org.slf4j.simpleLogger.showShortLogName=true
org.slf4j.simpleLogger.levelInBrackets=true
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Why do I see a warning in the console about illegal reflexive access
when running the application?&lt;/strong>&lt;/p>
&lt;p>A known problem on Windows 8/10 platforms causes the smartcard service
to stop when the last reader is removed. This problem prevents a
&amp;ldquo;classic&amp;rdquo; monitoring of connections and disconnections of readers with
the smartcard.io library (Java PC/SC). So for the moment we are using a
workaround based on reflexivity to overcome this problem and allow a
correct monitoring of the readers in the PC/SC plugin. This has the
disadvantage of generating a warning message with recent versions of the
JVM. However, we have not found any problems with this implementation of
the PC/SC plugin so far.&lt;/p>
&lt;h4 id="full-code">Full code&lt;/h4>
&lt;p>Here is the complete code of this quick start in one single block.&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.calypso.command.sam.SamRevision;
import org.eclipse.keyple.calypso.transaction.*;
import org.eclipse.keyple.core.card.selection.*;
import org.eclipse.keyple.core.service.*;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.plugin.pcsc.*;
public class DemoPoAuthentication {
public static void main(String[] args) {
// Get the instance of the SmartCardService : main service of Keyple SDK
SmartCardService smartCardService = SmartCardService.getInstance();
// Register a PcscPlugin within the SmartCardService to use PC/SC USB Readers
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, null));
// Get the PO reader
PcscReader poReader = (PcscReader) plugin.getReader(&amp;quot;ASK LoGO 0&amp;quot;);
// Configure the PO reader parameters
poReader.setContactless(true);
// Get a SAM reader
PcscReader samReader = (PcscReader) plugin.getReader(&amp;quot;Identive CLOUD 2700 R Smart Card Reader 0&amp;quot;);
// Prepare a SamSelector that identifies the Calypso SAM
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build();
// Perform the SAM selection
CardSelectionsService samSelection = new CardSelectionsService();
samSelection.prepareSelection(new SamSelection(samSelector));
if (!samReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader.getName());
}
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
// Associate the calypsoSam and the samReader to create a samResource
CardResource&amp;lt;CalypsoSam&amp;gt; samResource = new CardResource&amp;lt;CalypsoSam&amp;gt;(samReader, calypsoSam);
// Prepare a Calypso PO selection
final String AID = &amp;quot;315449432E49434131&amp;quot;; /* AID: Keyple test kit profile 1, Application 2 */
final byte RECORD_NUMBER_1 = 1;
final byte SFI_Environment = (byte) 0x07;
CardSelectionsService cardSelectionService = new CardSelectionsService();
// Setting up a selection based on the AID of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication protocol
PoSelection poSelection = new PoSelection(
PoSelector.builder()
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier
.invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not
.build());
// Add the selection case to the current selection
// (we could have added other cases)
cardSelectionService.prepareSelection(poSelection);
if (!poReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;The selection of the PO has failed.&amp;quot;);
}
// Perform the PO selection and get a CalypoPo container in return
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard();
// Prepare the security settings used during the Calypso transaction
PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build();
// Create a PoTransaction service to manage the Calypso transaction
PoTransaction poTransaction = new PoTransaction(
new CardResource&amp;lt;CalypsoPo&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
// Schedule the reading of the Environment file after the secure session is opened
// (we could have added other commands)
poTransaction.prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Perform the session opening with the debit key
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the Environment data from the card image CalypsoPo
ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment);
String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent());
System.out.println(&amp;quot;Environment file content: &amp;quot;+ environmentLog);
// Schedule the closure of the channel with the PO after the closing of the secure session
poTransaction.prepareReleasePoChannel();
// Perform the closing of the Calypso Secure Session
poTransaction.processClosing();
System.out.println(&amp;quot;The data read in session have been certified by the successful closing.&amp;quot;);
// Shutdown the application
smartCardService.unregisterPlugin(plugin.getName());
System.exit(0);
}
}
&lt;/code>&lt;/pre></description></item><item><title>Build your first Android application</title><link>https://keyple.org/docs/build-your-first-app/android-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/android-app/</guid><description>&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>&lt;strong>Since Keyple is supported by the Android operating system, developers can take advantage of this quick and easy way to implement solution to provide SmartCard communication functionalities in their own mobile application.&lt;/strong>&lt;/p>
&lt;p>For example, Keyple could be used to facilitate the development of a ticketing application based on the use of conteners on a SIM card and relying on
&lt;a href="https://developer.android.com/reference/android/se/omapi/package-summary" target="_blank" rel="noopener">Android SE OMAPI&lt;/a>.
Keyple could also be used to develop an application reading SmartCard content through NFC using
&lt;a href="https://developer.android.com/guide/topics/connectivity/nfc/advanced-nfc" target="_blank" rel="noopener">Android NFC&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/android-app/component/Android_App_Overview.png" >
&lt;img src="./media/android-app/component/Android_App_Overview.png" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>As Keyple request low level reader access, the key features of Keyple SDK relies on components called &lt;strong>Plugins&lt;/strong>. These are the plugins that allow access to the hardware functionality of the terminal by using the native Android SDK or the terminal manufacturer&amp;rsquo;s own custom SDKs.&lt;/p>
&lt;p>This guide will describe how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso SmartCard. As we want to focus on Keyple integration, the Android application architecture will remain the simplest as possible.&lt;/p>
&lt;h3 id="what-to-we-need-for-this-guide">What to we need for this guide?&lt;/h3>
&lt;ul>
&lt;li>Retail Device with NFC powered by android.nfc library (integrated into standard Android SDK).&lt;/li>
&lt;li>Android OS 19+&lt;/li>
&lt;li>A NFC SmartCard with Calypso PO&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="integration">Integration&lt;/h2>
&lt;h3 id="application-setup">Application setup&lt;/h3>
&lt;p>Like for any other Android NFC Application, we need to declare items in the application manifest.&lt;/p>
&lt;pre>&lt;code class="language-xml">&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
...
&amp;lt;uses-permission android:name=&amp;quot;android.permission.NFC&amp;quot; /&amp;gt;
&amp;lt;uses-feature android:name=&amp;quot;android.hardware.nfc&amp;quot; android:required=&amp;quot;true&amp;quot; /&amp;gt;
...
&amp;lt;/manifest&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="sdk-integration">SDK Integration&lt;/h3>
&lt;h4 id="keyple-core">Keyple Core&lt;/h4>
&lt;p>This high-level API is convenient for developers implementing smart card processing application for terminal interfaced
with smart card readers. Access to the readers is provided by the plugins.&lt;/p>
&lt;p>To use Keyple core API (and in fact, anything keyple&amp;rsquo;s related) import the jar within the gradle dependencies of your
Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-core:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Please refer to Architecture/Keyle Core&lt;/p>
&lt;h4 id="keyple-plugins">Keyple Plugins&lt;/h4>
&lt;p>There are many Keyple plugins available, the one to use depends on the device and ticketing tools you are aiming to
use.&lt;/p>
&lt;p>To use the NFC plugin simply import it within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-android-nfc:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h4 id="keyple-calypso">Keyple Calypso&lt;/h4>
&lt;p>The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Objects.&lt;/p>
&lt;p>Please refer to Architecture/Keyle Calypso&lt;/p>
&lt;p>To use Keyple Calypso User API simply import the jar within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-calypso:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;h3 id="initializing-the-sdk">Initializing the SDK&lt;/h3>
&lt;h4 id="register-a-plugin">Register a plugin&lt;/h4>
&lt;p>In order to setup Keyple, we need to register at least one plugin. Here we register our NFC plugin. To do so, we use the singleton SmartCardService and the plugin Factory. (See plugin development guide to know more about plugins)&lt;/p>
&lt;pre>&lt;code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
/* register Android NFC Plugin to the SmartCardService */
try {
val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -&amp;gt;}
SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler))
}catch (e: KeypleException){
/* do something with it */
}
}
&lt;/code>&lt;/pre>
&lt;p>Note: Plugins Factory&amp;rsquo;s initialisation could request more steps to execute before passing it to registerPlugin(). It depends on plugins, please check the documentation or usage example of desired plugin.&lt;/p>
&lt;h4 id="unregister-a-plugin">Unregister a plugin&lt;/h4>
&lt;p>Clean resources.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">override fun onDestroy() {
...
/* Unregister Android NFC Plugin to the SmartCardService */
SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME)
reader = null
super.onDestroy()
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-a-specific-reader">Retrieve a specific reader&lt;/h3>
&lt;p>With the plugin registered we can retrieve all instances of the component mapping the SmartCard readers. Here we want to retrieve the NFC reader.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//We keep a reference to the reader for later use
private lateinit var reader: AndroidNfcReader
...
//PLUGIN_NAME and READER_NAME are constants provided by the used Keyple plugin
reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader
&lt;/code>&lt;/pre>
&lt;h3 id="add-observer-to-handle-nfc-events">Add observer to handle NFC events&lt;/h3>
&lt;p>When native NFC is activated on an Android device, the OS dispatches insertion events occurring in the NFC detection field. In our application, we need detect it in order to proceed to exchanges with the SmartCard.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//To keep it simple we choose to have our MainActivity implementing ObservableReader.ReaderObserver
//interface.
class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
...
reader.addObserver(this)
...
//Belongs to ObservableReader.ReaderObserver
//NFC Reader events will be received here.
//this method is not triggered in UI thread
override fun update(event: ReaderEvent) {
if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){
//We'll select PO when SmartCard is presented in field
//Method handlePo is described below
handlePo()
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="activate-a-protocol">Activate a protocol&lt;/h3>
&lt;p>Before starting to read a NFC tag, you must activate the protocol in which you wish to detect it.
If you do not activate any protocol, no card will be detected by the Keyple library.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
...
// with this protocol settings we activate the nfc for ISO1443_4 protocol
reader.activateProtocol(
ContactlessCardCommonProtocols.ISO_14443_4.name,
AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name)
)
...
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="deactivate-a-protocol">Deactivate a protocol&lt;/h3>
&lt;p>When your are done with your NFC operations, you can deactivate the NFC protocol :&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onDestroy() {
...
//Deactivate nfc for ISO1443_4 protocol
reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
...
super.onDestroy()
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we have an access to our NFC Reader, we can activate Card Detection.&lt;/p>
&lt;h3 id="activate-card-detection">Activate Card detection&lt;/h3>
&lt;p>We will start detection as soon as our application comes in foreground and stop when application go background.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onResume() {
super.onResume()
reader?.let {
//We choose to continue waiting for a new card persentation
it.startCardDetection(ObservableReader.PollingMode.REPEATING)
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="deactivate-card-detection">Deactivate Card detection&lt;/h3>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onPause() {
reader?.let {
it.stopCardDetection()
}
super.onPause()
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we can detect when a SmartCard is presented in the field, we can proceed to card application selection and data reading.&lt;/p>
&lt;h3 id="handling-a-calypso-po">Handling a Calypso PO&lt;/h3>
&lt;h4 id="calypso-selection-api">Calypso Selection API&lt;/h4>
&lt;p>With Keyple, PO selection and FCI retrieving can be done using only Keyple Core, but Keyple Calypso API provides specific tools to handle Calypso POs and make the process a bit more simple.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">fun handlePo(){
reader?.let {
//check if card is in the NFC field
if(it.isCardPresent){
//Instanciate class handling card selection service
val cardSelectionService = CardSelectionsService()
//We only want to select the PO so we choose to close communication channel once
//selection is done
cardSelectionService.prepareReleaseChannel()
//We build a selection request managing specific characteristics of Calypso POs
val poSelection = PoSelection(
PoSelector
.builder()
//Smarcard standard protocol
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
.aidSelector(
CardSelector.AidSelector.builder()
.aidToSelect(YOUR_AID) //Set the AID of your Calypso PO
//indicates how to carry out the file occurrence in accordance with
//ISO7816-4
.fileOccurrence(CardSelector.AidSelector.FileOccurrence.FIRST)
//indicates which template is expected in accordance with ISO7816-4
.fileControlInformation(
CardSelector.AidSelector.FileControlInformation.FCI)
.build()
).build())
cardSelectionService.prepareSelection(poSelection)
//Proceed to selection using the reader
val selectionResult = cardSelectionService.processExplicitSelections(it)
runOnUiThread {
//We check the selection result and read the FCI
if(selectionResult.hasActiveSelection()){
val matchedSmartCard = selectionResult.activeSmartCard
val fci = matchedSmartCard.fciBytes
Toast.makeText(this, String.format(&amp;quot;Selected, Fci %s&amp;quot;,
ByteArrayUtil.toHex(fci)), Toast.LENGTH_LONG).show()
}else {
Toast.makeText(this,
String.format(&amp;quot;Not selected&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we&amp;rsquo;ve seen we can select our PO we can retrieve more data from it.&lt;/p>
&lt;h4 id="reading-environment-and-usage">Reading Environment and usage&lt;/h4>
&lt;p>In the below example we&amp;rsquo;ll read Environment and Usage data of an Hoplink container.&lt;/p>
&lt;pre>&lt;code class="language-kotlin"> ...
//Data related to Hoplink
val poAid= &amp;quot;A000000291A000000191&amp;quot;
val sfiHoplinkEFEnvironment = 0x14.toByte()
val sfiHoplinkEFUsage = 0x1A.toByte()
...
private fun handlePo(){
...
//Prepare the reading order. We'll read the first record of the EF
//specified by its SFI. This reading will be done within explicit selection.
poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1)
poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1)
...
//Hoplink is a Calypso PO, we can cast the SmartCard
//with CalypsoPo class, representing the PO content.
val calypsoPO = selectionResult.activeSmartCard as CalypsoPo
val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment)
val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage)
Toast.makeText(this, String.format(&amp;quot;Environment %s&amp;quot;,
ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show()
Toast.makeText(this, String.format(&amp;quot;Usage %s&amp;quot;,
ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show()
}
&lt;/code>&lt;/pre>
&lt;h3 id="full-code">Full code&lt;/h3>
&lt;pre>&lt;code class="language-xml">&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
package=&amp;quot;org.eclipse.keyple.android.quickstart&amp;quot;&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.NFC&amp;quot; /&amp;gt;
&amp;lt;uses-feature
android:name=&amp;quot;android.hardware.nfc&amp;quot;
android:required=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;application
android:allowBackup=&amp;quot;true&amp;quot;
android:screenOrientation=&amp;quot;portrait&amp;quot;
android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
android:label=&amp;quot;@string/app_name&amp;quot;
android:roundIcon=&amp;quot;@mipmap/ic_launcher_round&amp;quot;
android:supportsRtl=&amp;quot;true&amp;quot;
android:theme=&amp;quot;@style/AppTheme&amp;quot;&amp;gt;
&amp;lt;activity android:name=&amp;quot;.MainActivity&amp;quot;&amp;gt;
&amp;lt;intent-filter&amp;gt;
&amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;
&amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
&amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
private var reader: AndroidNfcReader? = null
val poAid= &amp;quot;A000000291A000000191&amp;quot;
val sfiHoplinkEFEnvironment = 0x14.toByte()
val sfiHoplinkEFUsage = 0x1A.toByte()
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
try {
val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -&amp;gt;}
val plugin = SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler))
val reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader
reader.addObserver(this)
reader.activateProtocol(
ContactlessCardCommonProtocols.ISO_14443_4.name,
AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name)
)
this.reader = reader
}catch (e: KeypleException){
Timber.e(e)
Toast.makeText(this, String.format(&amp;quot;Error: %s&amp;quot;, e.message), Toast.LENGTH_LONG).show()
}
}
override fun onResume() {
super.onResume()
reader?.let {
it.startCardDetection(ObservableReader.PollingMode.SINGLESHOT)
Toast.makeText(this, String.format(&amp;quot;Hunt enabled&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
override fun onPause() {
reader?.let {
it.stopCardDetection()
}
super.onPause()
}
override fun onDestroy() {
/* Deactivate nfc for ISO1443_4 protocol */
reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
/* Unregister Android NFC Plugin to the SmartCardService */
SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME)
reader = null
super.onDestroy()
}
override fun update(event: ReaderEvent) {
Timber.d(&amp;quot;Event: %s&amp;quot;, event.eventType.name)
runOnUiThread {
Toast.makeText(this, String.format(&amp;quot;Event: %s&amp;quot;, event.eventType.name),
Toast.LENGTH_SHORT).show()
}
if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){
handlePo()
}
}
//With Calypso API
private fun handlePo(){
reader?.let {
if(it.isCardPresent){
val cardSelectionService = CardSelectionService()
cardSelectionService.prepareReleaseChannel()
val poSelection = PoSelection(
PoSelector
.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
.aidSelector(
CardSelector.AidSelector.builder()
.aidToSelect(poAid)
.fileOccurrence(
CardSelector.AidSelector.FileOccurrence.FIRST)
.fileControlInformation(
CardSelector.AidSelector.FileControlInformation.FCI)
.build()
).build())
cardSelectionService.prepareSelection(poSelection)
//Prepare the reading order. We'll read the first record of the EF
//specified by his SFI. This reading will be done with selection.
poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1)
poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1)
//Selection and file reading will be done here
val selectionResult = cardSelectionService.processExplicitSelections(it)
runOnUiThread {
if(selectionResult.hasActiveSelection()){
val matchedSmartCard = selectionResult.activeSmartCard
val fci = matchedSmartCard.fciBytes
Toast.makeText(this, String.format(&amp;quot;Selected, Fci %s&amp;quot;,
ByteArrayUtil.toHex(fci)), Toast.LENGTH_SHORT).show()
//Hoplink is a Calypso PO, we can cast the SmartCard
//with CalypsoPo class, representing the PO content.
val calypsoPO = selectionResult.activeSmartCard as CalypsoPo
val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment)
val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage)
Toast.makeText(this, String.format(&amp;quot;Environment %s&amp;quot;,
ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show()
Toast.makeText(this, String.format(&amp;quot;Usage %s&amp;quot;,
ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show()
}else {
Toast.makeText(this, String.format(&amp;quot;Not selected&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How to fix &amp;ldquo;More than one file was found with OS independent path &amp;lsquo;META-INF/NOTICE.md&amp;rsquo;.&amp;quot;&lt;/strong>&lt;/p>
&lt;p>Add lines below to your :app build.gradle file&lt;/p>
&lt;pre>&lt;code class="language-gradle">android{
packagingOptions {
exclude 'META-INF/NOTICE.md'
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Where can I see more examples&lt;/strong>&lt;/p>
&lt;p>Android native plugins are provided with example applications. Check it to see more use cases:
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example" target="_blank" rel="noopener">Examples&lt;/a>&lt;/p></description></item><item><title>Build your first C++ application</title><link>https://keyple.org/docs/build-your-first-app/cpp-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/cpp-app/</guid><description>&lt;hr>
&lt;p>This quick start describes how to create a ready-to-execute C++
command-line application that runs a simple transaction based on
a Calypso portable object (PO) involving two smart card readers.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The demonstration application created for this quick start requires a
Calypo PO (contactless smart card, mobile phone with contactless
communication) and a Calypo Secure Access Module (SAM).
&lt;/div>
&lt;/div>
&lt;p>We will use three main components of Keyple:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/core/">Keyple Core&lt;/a>
which is the base component to which all the others refer,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/plugins/pcsc/">Keyple PC/SC plugin&lt;/a>
to provide the ability to manage PC/SC readers,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/extensions/calypso/">Keyple Calypso extension&lt;/a>
to handle the commands sent to the Calypso PO and the Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>In this guide CMake is used as build automation tool.&lt;/p>
&lt;p>The example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you
will need to download :&lt;/p>
&lt;ul>
&lt;li>CMake 2.8 or newer
&lt;a href="https://cmake.org/install/" target="_blank" rel="noopener">(download)&lt;/a>&lt;/li>
&lt;li>GCC / CLang / MSVC compiler&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;p>Now let&amp;rsquo;s see step by step how to create in one single class the
elements that allow a certified reading of data through a Calypso secure
session.&lt;/p>
&lt;p>In a real ticketing application, the organization of the code would
probably be different, but the point here is to show how Keyple makes it
possible to perform very simply operations that normally require a
quantity of code and knowledge that far exceeds what is implemented
here.&lt;/p>
&lt;p>You can either progressively copy each of the small portions of code
that follow or copy the whole class at the bottom of this page.&lt;/p>
&lt;h3 id="create-the-class-skeleton">Create the class skeleton&lt;/h3>
&lt;p>Copy the source code below in a new C++ Class named
DemoPoAuthentication.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Common */
#include &amp;quot;IllegalStateException.h&amp;quot;
#include &amp;quot;LoggerFactory.h&amp;quot;
/* Core */
#include &amp;quot;ByteArrayUtil.h&amp;quot;
#include &amp;quot;SeCommonProtocols.h&amp;quot;
#include &amp;quot;SeSelector.h&amp;quot;
#include &amp;quot;SeSelection.h&amp;quot;
#include &amp;quot;SeProxyService.h&amp;quot;
/* PCSC */
#include &amp;quot;PcscPluginFactory.h&amp;quot;
#include &amp;quot;PcscProtocolSetting.h&amp;quot;
#include &amp;quot;PcscReader.h&amp;quot;
/* Calypso */
#include &amp;quot;CalypsoPo.h&amp;quot;
#include &amp;quot;CalypsoSam.h&amp;quot;
#include &amp;quot;ElementaryFile.h&amp;quot;
#include &amp;quot;PoSecuritySettings.h&amp;quot;
#include &amp;quot;PoSelectionRequest.h&amp;quot;
#include &amp;quot;PoSelector.h&amp;quot;
#include &amp;quot;PoTransaction.h&amp;quot;
#include &amp;quot;SamRevision.h&amp;quot;
#include &amp;quot;SamSelector.h&amp;quot;
#include &amp;quot;SamSelectionRequest.h&amp;quot;
using namespace keyple::calypso::command::po;
using namespace keyple::calypso::command::po::builder;
using namespace keyple::calypso::command::po::parser;
using namespace keyple::calypso::command::sam;
using namespace keyple::calypso::transaction;
using namespace keyple::common;
using namespace keyple::common::exception;
using namespace keyple::core::command::exception;
using namespace keyple::core::selection;
using namespace keyple::core::seproxy;
using namespace keyple::core::seproxy::event;
using namespace keyple::core::seproxy::exception;
using namespace keyple::core::seproxy::message;
using namespace keyple::core::seproxy::protocol;
using namespace keyple::core::util;
using namespace keyple::plugin::pcsc;
int main(int argv, char **args)
{
// ...
return 0;
}
&lt;/code>&lt;/pre>
&lt;h3 id="configure-the-pcsc-plugin-and-the-readers">Configure the PC/SC plugin and the readers&lt;/h3>
&lt;p>The first step to use Keyple is to initialize the plugin and smart card readers.&lt;/p>
&lt;p>In this snippet the PC/SC plugin is registered to the SmartCardService.&lt;/p>
&lt;p>Two readers needs to be connected to the local machine. Replace
&amp;ldquo;PO_READER_NAME&amp;rdquo; and &amp;ldquo;SAM_READER_NAME&amp;rdquo; with the name of the USB readers.&lt;/p>
&lt;p>If you don&amp;rsquo;t know the names of the readers, read how to find them in the
&lt;a href="#faq">FAQ&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* ... */
/* PO Reader name */
const std::string PO_READER_NAME = &amp;quot;XXX&amp;quot;;
/* SAM Reader name */
const std::string SAM_READER_NAME = &amp;quot;XXX&amp;quot;;
/* Get the instance of the SeProxyService (Singleton pattern) */
SeProxyService&amp;amp; seProxyService = SeProxyService::getInstance();
/* Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin */
auto pluginFactory = std::make_shared&amp;lt;PcscPluginFactory&amp;gt;();
std::shared_ptr&amp;lt;ReaderPlugin&amp;gt; readerPlugin = seProxyService.registerPlugin(pluginFactory);
/* Get the PO reader */
std::shared_ptr&amp;lt;SeReader&amp;gt; poReader = readerPlugin-&amp;gt;getReader(PO_READER_NAME);
/* Configure the PO reader parameters */
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1);
/* Get a SAM reader */
std::shared_ptr&amp;lt;SeReader&amp;gt; samReader = readerPlugin-&amp;gt;getReader(SAM_READER_NAME);
/* Configure the SAM reader parameters */
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0);
/*
* PC/SC card access mode:
*
* The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited
* time between two consecutive exchanges granted by Windows.
*
* This point will be addressed in a coming release of the Keyple PcSc reader plugin.
*
* The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the
* selection step that may result in session failures.
*
* See KEYPLE-CORE.PC.md file to learn more about this point.
*
*/
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
/* Set the PO reader protocol flag */
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO14443_4,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]);
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_B_PRIME,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]);
samReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO7816_3,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]);
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-sam">Select the Calypso SAM&lt;/h3>
&lt;p>Before executing a transaction each smart card should be selected. The
next step is the selection of the Calypso SAM resulting in a
CalypsoSam object.&lt;/p>
&lt;p>It is then combined with the SAM reader to form the SAM resource needed
later within the transaction service.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* ... */
/* Prepare the selector to ensure the correct SAM is used */
auto selector = SamSelector::builder()-&amp;gt;samRevision(SamRevision::AUTO).build();
auto samSelector = std::dynamic_pointer_cast&amp;lt;SamSelector&amp;gt;(selector);
/* Make the SAM selection */
SeSelection samSelection;
auto samSelectionRequest = std::make_shared&amp;lt;SamSelectionRequest&amp;gt;(samSelector);
auto abstractSamSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(samSelectionRequest);
samSelection.prepareSelection(abstractSamSelectionRequest);
std::shared_ptr&amp;lt;CalypsoSam&amp;gt; calypsoSam;
if (samReader-&amp;gt;isSePresent()) {
std::shared_ptr&amp;lt;SelectionsResult&amp;gt; selectionsResult = samSelection.processExplicitSelection(samReader);
if (selectionsResult-&amp;gt;hasActiveSelection()) {
calypsoSam = std::dynamic_pointer_cast&amp;lt;CalypsoSam&amp;gt;(selectionsResult-&amp;gt;getActiveMatchingSe());
} else {
throw IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
} else {
throw IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader-&amp;gt;getName());
}
/* Associate the calypsoSam and the samReader to create the samResource */
auto samResource = std::make_shared&amp;lt;SeResource&amp;lt;CalypsoSam&amp;gt;&amp;gt;(samReader, calypsoSam);
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-po">Select the Calypso PO&lt;/h3>
&lt;p>1st PO exchange:&lt;/p>
&lt;p>The Calypso PO selection is made using the portable object application&amp;rsquo;s AID
and results in a CalypsoPo object that will contain all the information extracted
from the Calypso PO all along the transaction.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Prepare a Calypso PO selection */
SeSelection seSelection;
/* Keyple test kit profile 1, Application 2 */
const std::string AID = &amp;quot;315449432E49434131&amp;quot;;
/*
* Setting of an AID based selection of a Calypso Revision 3.1 PO
*
* Select the first application matching the selection AID whatever the card communication
* protocol
* Keep the logical channel open after the selection
*
* Calypso selection: configures a PoSelectionRequest with all the desired attributes to
* make the selection and read additional information afterwards
*/
auto aidSelector = SeSelector::AidSelector::builder()-&amp;gt;aidToSelect(AID).build();
auto seSelector = PoSelector::builder()-&amp;gt;aidSelector(aidSelector) /* The application identifier
to indicate if an invalidated PO should be accepted
or not */
.invalidatedPo(PoSelector::InvalidatedPo::REJECT)
.build();
auto poSelector = std::dynamic_pointer_cast&amp;lt;PoSelector&amp;gt;(seSelector);
auto poSelectionRequest = std::make_shared&amp;lt;PoSelectionRequest&amp;gt;(poSelector);
/* Add the selection case to the current selection (we could have added other cases) */
auto abstractPoSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(poSelectionRequest);
seSelection.prepareSelection(abstractPoSelectionRequest);
if (poReader-&amp;gt;isSePresent()) {
try {
// Actual PO communication: operate through a single request the Calypso PO selection
std::shared_ptr&amp;lt;CalypsoPo&amp;gt; calypsoPo =
std::dynamic_pointer_cast&amp;lt;CalypsoPo&amp;gt;(
seSelection.processExplicitSelection(poReader)-&amp;gt;getActiveMatchingSe());
/* ... */
} catch (const Exception&amp;amp; e) {
}
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="open-the-calypso-secure-session">Open the Calypso secure session&lt;/h3>
&lt;p>2nd PO exchange :&lt;/p>
&lt;p>The secure session opening operated by the PoTransaction service is
combined with the reading of the environment file (SFI=07h).&lt;/p>
&lt;p>The mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Prepare the security settings used during the Calypso transaction */
auto poSecuritySettings = std::make_shared&amp;lt;PoSecuritySettings::PoSecuritySettingsBuilder&amp;gt;(samResource)-&amp;gt;build();
/* Create a PoTransaction object to manage the Calypso transaction */
auto poTransaction = std::make_shared&amp;lt;PoTransaction&amp;gt;(
std::make_shared&amp;lt;SeResource&amp;lt;CalypsoPo&amp;gt;&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
const uint8_t RECORD_NUMBER_1 = 1;
const uint8_t SFI_Environment = 0x07;
/* Read the Environment file at the Session Opening (we could have added other commands) */
poTransaction-&amp;gt;prepareReadRecordFile(
SFI_Environment, /* The sfi to select */
RECORD_NUMBER_1);
/* Open Session with the debit key */
poTransaction-&amp;gt;processOpening(PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT);
/* Get the Environment data */
std::shared_ptr&amp;lt;ElementaryFile&amp;gt; efEnvironment = calypsoPo-&amp;gt;getFileBySfi(SFI_Environment);
const std::string environmentLog = ByteArrayUtil::toHex(efEnvironment-&amp;gt;getData()-&amp;gt;getContent());
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="close-the-calypso-secure-session">Close the Calypso secure session&lt;/h3>
&lt;p>3rd PO exchange:&lt;/p>
&lt;p>Simply close the Calypso secure session&lt;/p>
&lt;p>The mutual authentication is finalized, it includes the authentication
of the data in the read file.&lt;/p>
&lt;p>Note: any technical, crytographic or content-related incident in the Calypso PO
would be signalled by an exception and would interrupt the thread of
execution.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Schedule the closure of the channel with the PO after the closing of the secure session */
poTransaction-&amp;gt;prepareReleasePoChannel();
/* Perform the closing of the Calypso Secure Session */
poTransaction-&amp;gt;processClosing();
/* ... */
&lt;/code>&lt;/pre>
&lt;p>Find the complete code source
&lt;a href="#full-code">below&lt;/a>.&lt;/p>
&lt;hr>
&lt;h2 id="cmake-build">CMake build&lt;/h2>
&lt;p>Create a CMakeLists.txt file as follows:&lt;/p>
&lt;pre>&lt;code class="language-cpp">#
# Copyright (c) 2020 Calypso Networks Association https://www.calypsonet-asso.org/
#
# All rights reserved. This program and the accompanying materials are made available under the
# terms of the Eclipse Public License version 2.0 which accompanies this distribution, and is
# available at https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
#
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
SET(CMAKE_LEGACY_CYGWIN_WIN32 0)
SET(CMAKE_MACOSX_RPATH 1)
SET(CMAKE_CXX_STANDARD 11)
SET(CMAKE_C_COMPILER_WORKS 1)
SET(CMAKE_CXX_COMPILER_WORKS 1)
PROJECT(KeypleDemo)
SET(KEYPLE_SOURCE_DIR &amp;quot;&amp;lt;path_to_keyple_repos&amp;gt;&amp;quot;)
INCLUDE_DIRECTORIES(
${CMAKE_CURRENT_SOURCE_DIR}
# Core
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command/exception
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/selection
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/event
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/exception
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/message
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/protocol
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util/bertlv
# Plugin
${KEYPLE_SOURCE_DIR}/component/keyple-plugin/pcsc/src/main
# Common
${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main
${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main/exception
# Calypso
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/builder
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/parser
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/sam
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/transaction
# pcsc (Linux / macOS)
/usr/include/PCSC
)
IF(WIN32)
SET(CMAKE_FIND_LIBRARY_PREFIXES &amp;quot;&amp;quot;)
SET(CMAKE_FIND_LIBRARY_SUFFIXES &amp;quot;.dll&amp;quot;)
SET(CMAKE_BUILD_DIRECTORY &amp;quot;${CMAKE_CURRENT_BINARY_DIR}&amp;quot;)
SET(WINSCARD winscard.lib)
ENDIF(WIN32)
IF(APPLE)
SET(CMAKE_FIND_LIBRARY_PREFIXES &amp;quot;lib&amp;quot;)
SET(CMAKE_FIND_LIBRARY_SUFFIXES &amp;quot;.dylib&amp;quot;)
SET(CMAKE_BUILD_DIRECTORY &amp;quot;${CMAKE_CURRENT_BINARY_DIR}&amp;quot;)
SET(WINSCARD &amp;quot;-framework PCSC&amp;quot;)
ENDIF(APPLE)
IF(UNIX)
SET(SPEC_LIBS pthread pcsclite rt)
ENDIF(UNIX)
IF(APPLE)
SET(SPEC_LIBS pthread)
ENDIF(APPLE)
ADD_EXECUTABLE(
demo_po_authentication
${CMAKE_CURRENT_SOURCE_DIR}/main.cpp
)
TARGET_LINK_DIRECTORIES(demo_po_authentication PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/build)
TARGET_LINK_LIBRARIES(demo_po_authentication keyplecommon keyplepluginpcsc keyplecore keyplecalypso ${SPEC_LIBS})
&lt;/code>&lt;/pre>
&lt;p>Now build the demo code:&lt;/p>
&lt;pre>&lt;code class="language-bash">mkdir build
cd build
cmake ..
make
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="run">Run&lt;/h2>
&lt;ol>
&lt;li>Connect two USB PC/SC Readers.&lt;/li>
&lt;li>Insert the Calypso SAM in the SAM reader.&lt;/li>
&lt;li>Insert the Calypso PO in the PO reader.&lt;/li>
&lt;li>Run the application.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How do I find out the names of the readers?&lt;/strong>&lt;/p>
&lt;p>If you don’t know the reader name, several options:&lt;/p>
&lt;ul>
&lt;li>run the application in debug mode and get the reader name in plugin variable&lt;/li>
&lt;li>run &amp;lsquo;pcsctest&amp;rsquo; (macOS)&lt;/li>
&lt;li>run &amp;lsquo;pcsc_scan&amp;rsquo; (Linux)&lt;/li>
&lt;/ul>
&lt;p>Identify which reader will be the PO (contactless) reader and the SAM
(contact) reader and replace &lt;code>PO_READER_NAME&lt;/code> and
&lt;code>SAM_READER_NAME&lt;/code> with their values.&lt;/p>
&lt;p>&lt;strong>How to activate the Keyple&amp;rsquo;s logs?&lt;/strong>&lt;/p>
&lt;p>Logs are automatically activated but log level can be dynamically changed by a simple call to the
Logger::setLevel() function. Default value is Logger::Level::logDebug.&lt;/p>
&lt;pre>&lt;code class="language-cpp">class DemoPoAuthentication final {};
const std::shared_ptr&amp;lt;Logger&amp;gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication));
logger-&amp;gt;setLoggerLevel(Logger::Level::logError);
&lt;/code>&lt;/pre>
&lt;h4 id="full-code">Full code&lt;/h4>
&lt;p>Here is the complete code of this quick start in one single block.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/**************************************************************************************************
* Copyright (c) 2020 Calypso Networks Association *
* https://www.calypsonet-asso.org/ *
* *
* See the NOTICE file(s) distributed with this work for additional information regarding *
* copyright ownership. *
* *
* This program and the accompanying materials are made available under the terms of the Eclipse *
* Public License 2.0 which is available at http://www.eclipse.org/legal/epl-2.0 *
* *
* SPDX-License-Identifier: EPL-2.0 *
**************************************************************************************************/
/* Common */
#include &amp;quot;IllegalStateException.h&amp;quot;
#include &amp;quot;LoggerFactory.h&amp;quot;
/* Core */
#include &amp;quot;ByteArrayUtil.h&amp;quot;
#include &amp;quot;SeCommonProtocols.h&amp;quot;
#include &amp;quot;SeSelector.h&amp;quot;
#include &amp;quot;SeSelection.h&amp;quot;
#include &amp;quot;SeProxyService.h&amp;quot;
/* PCSC */
#include &amp;quot;PcscPluginFactory.h&amp;quot;
#include &amp;quot;PcscProtocolSetting.h&amp;quot;
#include &amp;quot;PcscReader.h&amp;quot;
/* Calypso */
#include &amp;quot;CalypsoPo.h&amp;quot;
#include &amp;quot;CalypsoSam.h&amp;quot;
#include &amp;quot;ElementaryFile.h&amp;quot;
#include &amp;quot;PoSecuritySettings.h&amp;quot;
#include &amp;quot;PoSelectionRequest.h&amp;quot;
#include &amp;quot;PoSelector.h&amp;quot;
#include &amp;quot;PoTransaction.h&amp;quot;
#include &amp;quot;SamRevision.h&amp;quot;
#include &amp;quot;SamSelector.h&amp;quot;
#include &amp;quot;SamSelectionRequest.h&amp;quot;
using namespace keyple::calypso::command::po;
using namespace keyple::calypso::command::po::builder;
using namespace keyple::calypso::command::po::parser;
using namespace keyple::calypso::command::sam;
using namespace keyple::calypso::transaction;
using namespace keyple::common;
using namespace keyple::common::exception;
using namespace keyple::core::command::exception;
using namespace keyple::core::selection;
using namespace keyple::core::seproxy;
using namespace keyple::core::seproxy::event;
using namespace keyple::core::seproxy::exception;
using namespace keyple::core::seproxy::message;
using namespace keyple::core::seproxy::protocol;
using namespace keyple::core::util;
using namespace keyple::plugin::pcsc;
class DemoPoAuthentication final {};
const std::shared_ptr&amp;lt;Logger&amp;gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication));
// PO Reader name
const std::string PO_READER_NAME = &amp;quot;XXX&amp;quot;;
// SAM Reader name
const std::string SAM_READER_NAME = &amp;quot;XXX&amp;quot;;
// Keyple test kit profile 1, Application 2
const std::string AID = &amp;quot;315449432E49434131&amp;quot;;
const uint8_t RECORD_NUMBER_1 = 1;
const uint8_t SFI_Environment = 0x07;
int main(int argv, char **args)
{
// Get the instance of the SeProxyService (Singleton pattern)
SeProxyService&amp;amp; seProxyService = SeProxyService::getInstance();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Get and Configure the PO &amp;amp; SAM Readers =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin
auto pluginFactory = std::make_shared&amp;lt;PcscPluginFactory&amp;gt;();
std::shared_ptr&amp;lt;ReaderPlugin&amp;gt; readerPlugin = seProxyService.registerPlugin(pluginFactory);
// Get the PO reader
std::shared_ptr&amp;lt;SeReader&amp;gt; poReader = readerPlugin-&amp;gt;getReader(PO_READER_NAME);
// Get a SAM reader
std::shared_ptr&amp;lt;SeReader&amp;gt; samReader = readerPlugin-&amp;gt;getReader(SAM_READER_NAME);
// Eventually, configure the SAM reader parameters
// ...
/* Set Pcsc settings per reader */
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1);
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0);
/*
* PC/SC card access mode:
*
* The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited
* time between two consecutive exchanges granted by Windows.
*
* This point will be addressed in a coming release of the Keyple PcSc reader plugin.
*
* The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the
* selection step that may result in session failures.
*
* See KEYPLE-CORE.PC.md file to learn more about this point.
*
*/
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
/* Set the PO reader protocol flag */
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO14443_4,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]);
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_B_PRIME,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]);
samReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO7816_3,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Create a SAM resource after selecting the SAM =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Prepare the selector to ensure the correct SAM is used
auto selector = SamSelector::builder()-&amp;gt;samRevision(SamRevision::AUTO).build();
auto samSelector = std::dynamic_pointer_cast&amp;lt;SamSelector&amp;gt;(selector);
// Make the SAM selection
SeSelection samSelection;
auto samSelectionRequest = std::make_shared&amp;lt;SamSelectionRequest&amp;gt;(samSelector);
auto abstractSamSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(
samSelectionRequest);
samSelection.prepareSelection(abstractSamSelectionRequest);
std::shared_ptr&amp;lt;CalypsoSam&amp;gt; calypsoSam;
if (samReader-&amp;gt;isSePresent()) {
std::shared_ptr&amp;lt;SelectionsResult&amp;gt; selectionsResult =
samSelection.processExplicitSelection(samReader);
if (selectionsResult-&amp;gt;hasActiveSelection()) {
calypsoSam = std::dynamic_pointer_cast&amp;lt;CalypsoSam&amp;gt;(
selectionsResult-&amp;gt;getActiveMatchingSe());
} else {
throw IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
} else {
throw IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader-&amp;gt;getName());
}
// Associate the calypsoSam and the samReader to create the samResource
auto samResource = std::make_shared&amp;lt;SeResource&amp;lt;CalypsoSam&amp;gt;&amp;gt;(samReader, calypsoSam);
// Prepare the security settings used during the Calypso transaction
auto poSecuritySettings =
std::make_shared&amp;lt;PoSecuritySettings::PoSecuritySettingsBuilder&amp;gt;(samResource)-&amp;gt;build();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Display basic information about the readers and SAM =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= PO Reader Name = %\n&amp;quot;, poReader-&amp;gt;getName());
const std::string samSerialNumber =
ByteArrayUtil::toHex(samResource-&amp;gt;getMatchingSe()-&amp;gt;getSerialNumber());
logger-&amp;gt;info(&amp;quot;= SAM Reader Name = %, Serial Number = %\n&amp;quot;,
samResource-&amp;gt;getSeReader()-&amp;gt;getName(),
samSerialNumber);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Prepare the Calypso PO selection =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Prepare a Calypso PO selection
SeSelection seSelection;
// Setting of an AID based selection of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication
// protocol
// Keep the logical channel open after the selection
//
// Calypso selection: configures a PoSelectionRequest with all the desired attributes to
// make the selection and read additional information afterwards
auto aidSelector = SeSelector::AidSelector::builder()-&amp;gt;aidToSelect(AID).build();
auto seSelector = PoSelector::builder()-&amp;gt;aidSelector(aidSelector) // the application identifier
// to indicate if an invalidated PO should be accepted
// or not
.invalidatedPo(PoSelector::InvalidatedPo::REJECT)
.build();
auto poSelector = std::dynamic_pointer_cast&amp;lt;PoSelector&amp;gt;(seSelector);
auto poSelectionRequest = std::make_shared&amp;lt;PoSelectionRequest&amp;gt;(poSelector);
// Add the selection case to the current selection
// (we could have added other cases)
auto abstractPoSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(
poSelectionRequest);
seSelection.prepareSelection(abstractPoSelectionRequest);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Check if a PO is present in the reader =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
if (poReader-&amp;gt;isSePresent()) {
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Start of the Calypso PO processing =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 1st PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= AID based selection =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
try {
// Actual PO communication: operate through a single request the Calypso PO selection
std::shared_ptr&amp;lt;CalypsoPo&amp;gt; calypsoPo =
std::dynamic_pointer_cast&amp;lt;CalypsoPo&amp;gt;(
seSelection.processExplicitSelection(poReader)-&amp;gt;getActiveMatchingSe());
logger-&amp;gt;info(&amp;quot;The selection of the PO has succeeded\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 2nd PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Open a Calypso secure session =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Reading of Environment file (SFI=07h) =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Create a PoTransaction object to manage the Calypso transaction
auto poTransaction = std::make_shared&amp;lt;PoTransaction&amp;gt;(
std::make_shared&amp;lt;SeResource&amp;lt;CalypsoPo&amp;gt;&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
// Read the Environment file at the Session Opening
// (we could have added other commands)
poTransaction-&amp;gt;prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Open Session with the debit key
poTransaction-&amp;gt;processOpening(
PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT);
// Get the Environment data
std::shared_ptr&amp;lt;ElementaryFile&amp;gt; efEnvironment =
calypsoPo-&amp;gt;getFileBySfi(SFI_Environment);
const std::string environmentLog =
ByteArrayUtil::toHex(efEnvironment-&amp;gt;getData()-&amp;gt;getContent());
logger-&amp;gt;info(&amp;quot;File Environment log: %\n&amp;quot;, environmentLog);
if (!calypsoPo-&amp;gt;isDfRatified()) {
logger-&amp;gt;info(&amp;quot;============= Previous Calypso Secure Session was not ratified =============\n&amp;quot;);
}
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 3th PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Close the Calypso secure session =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// To close the channel with the PO after the closing
poTransaction-&amp;gt;prepareReleasePoChannel();
// Close the Calypso Secure Session
// A ratification command will be sent (CONTACTLESS_MODE)
poTransaction-&amp;gt;processClosing();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= The Calypso secure session ended successfully =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= (Successful mutual authentication) =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= End of the Calypso PO processing =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
} catch (const Exception&amp;amp; e) {
logger-&amp;gt;error(&amp;quot;Exception: %\n&amp;quot;, e.getMessage());
}
} else {
logger-&amp;gt;error(&amp;quot;The selection of the PO has failed\n&amp;quot;);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h4 id="sample-trace">Sample trace&lt;/h4>
&lt;pre>&lt;code class="language-bash">============================================================================
= Get and Configure the PO &amp;amp; SAM Readers =
============================================================================
initNativeReaders - getting card terminals
run - starting executor monitoring thread
[PcscReaderImpl] constructor =&amp;gt; using terminal OMNIKEY CardMan (076B:5421) 5421(1)
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME =transmission_mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = disconnect, VALUE =
run - starting executor monitoring thread
constructor =&amp;gt; using terminal OMNIKEY CardMan (076B:5421) 5421(2)
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = transmission_mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = disconnect, VALUE =
Registering a new Plugin to the platform : PcscPlugin
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE = T1
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE = T0
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE = shared
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE = shared
============================================================================
= Create a SAM resource after selecting the SAM =
============================================================================
protocolFlagMatches - physical channel not open, opening it
[OMNIKEY CardMan (076B:5421) 5421(1)] openAndConnect - protocol: T=0
openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(1) with protocol: T=0, connectProtocol: 1
and sharingMode: 2
openAndConnect - card state: 84
[OMNIKEY CardMan (076B:5421) 5421(1)] Opening of a physical SE channel in shared mode
[OMNIKEY CardMan (076B:5421) 5421(1)] protocolFlagMatches =&amp;gt; matching SE. PROTOCOLFLAG = SEPROTOCOL:
{NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS}
processSeRequestSet - processing requests set
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =&amp;gt; transmit SEREQUEST: {REQUESTS = ApduRequests: {},
SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS}AIDSELECTOR = null,
ATRFILTER: {REGEX = .*}}}
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 0
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =&amp;gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {},
SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b3f9600805a4880c1205017aec11a36829000, FCI = R-APDU:
{STATUS = FAILURE, BYTES (0) = }, HASMATCHED = 1}, CHANNELWASOPEN = 0}
============================================================================
= Display basic information about the readers and SAM =
============================================================================
= PO Reader Name = OMNIKEY CardMan (076B:5421) 5421(2)
= SAM Reader Name = OMNIKEY CardMan (076B:5421) 5421(1), Serial Number = AEC11A36
============================================================================
= Prepare the Calypso PO selection =
============================================================================
============================================================================
= Check if a PO is present in the reader =
============================================================================
============================================================================
= Start of the Calypso PO processing =
============================================================================
= 1st PO exchange =
= AID based selection =
============================================================================
protocolFlagMatches - physical channel not open, opening it
[OMNIKEY CardMan (076B:5421) 5421(2)] openAndConnect - protocol: T=1
openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(2) with protocol: T=1, connectProtocol: 2
and sharingMode: 2
openAndConnect - card state: 84
[OMNIKEY CardMan (076B:5421) 5421(2)] Opening of a physical SE channel in shared mode
[OMNIKEY CardMan (076B:5421) 5421(2)] protocolFlagMatches =&amp;gt; matching SE. PROTOCOLFLAG = SEPROTOCOL:
{NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS}
processSeRequestSet - processing requests set
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =&amp;gt; transmit SEREQUEST: {REQUESTS = ApduRequests:
{}, SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS}AIDSELECTOR:
{AIDTOSELECT = 315449432e49434131FILEOCCURRENCE: {ISOBITMASK = 0(0x00)}FILECONTROLINFORMATION:
{ISOBITMASK = 0(0x00)}0x0}, ATRFILTER = null}}
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 0
[OMNIKEY CardMan (076B:5421) 5421(2)] openLogicalChannel =&amp;gt; Select Application with AID = 315449432e49434131
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Internal Select Application,
RAWDATA = 00a4040009315449432e4943413100, CASE4 = 1}, elapsed 13c ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 00a4040009315449432e4943413100
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt;
6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, elapsed c ms
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =&amp;gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {},
SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b888001000000009171710098, FCI = R-APDU: {STATUS = SUCCESS,
BYTES (27) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, HASMATCHED = 1},
CHANNELWASOPEN = 0}
Application Serial Number = 00000000C17BE1F6
Discretionary Data = 0a3c2305141001
The selection of the PO has succeeded
============================================================================
= 2nd PO exchange =
= Open a Calypso secure session =
= Reading of Environment file (SFI=07h) =
============================================================================
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Select Diversifier,
RAWDATA = 801400000800000000c17be1f6, CASE4 = 0}, elapsed 208 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 801400000800000000c17be1f6
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) =
9000}, elapsed 37 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Get Challenge,
RAWDATA = 8084000004, CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 8084000004
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; ef48651d9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
ef48651d9000}, elapsed 3 ms
identification: TERMINALCHALLENGE = ef48651d
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Open Secure Session
V3.1 - KEYINDEX=3, SFI=07, REC=1, RAWDATA = 008a0b3904ef48651d00, CASE4 = 1}, elapsed c7 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 008a0b3904ef48651d00
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt;
030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000}, elapsed e ms
processAtomicOpening =&amp;gt; opening: CARDCHALLENGE = CF, POKIF = 30, POKVC = 79
initialize: POREVISION = REV3_1, SAMREVISION = C1, SESSIONENCRYPTION = 0, VERIFICATIONMODE = 0
initialize: VERIFICATIONMODE = 0, REV32MODE = 0, KEYRECNUMBER = 0(0x00)
initialize: KIF = 48(0x30), KVC = 79(0x79), DIGESTDATA =
030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000
File Environment log: 0000000000000000000000000000000000000000000000000000000000
============================================================================
= 3th PO exchange =
= Close the Calypso secure session =
============================================================================
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Init, RAWDATA = 808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000, CASE4 = 0},
elapsed 2f ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt;
808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000},
elapsed 6 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Close,
RAWDATA = 808e000004, CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 808e000004
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 819e515d9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
819e515d9000}, elapsed 9 ms
SIGNATURE = 819e515d
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Close Secure Session,
RAWDATA = 008e800004819e515d00, CASE4 = 1}, elapsed 31 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 008e800004819e515d00
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt; 08d222e99000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
08d222e99000}, elapsed 34 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = , RAWDATA = 00b2000000,
CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 00b2000000
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt; 6b00
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = FAILURE, BYTES (2) = 6b00},
elapsed 2a ms
[OMNIKEY CardMan (076B:5421) 5421(2)] closePhysicalChannel
[OMNIKEY CardMan (076B:5421) 5421(2)] closeAndDisconnect - reset: y
[OMNIKEY CardMan (076B:5421) 5421(2)] Ignore =&amp;gt; Event SE_PROCESSED received in currentState
WAIT_FOR_START_DETECTION
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Authenticate,
RAWDATA = 808200000408d222e9, CASE4 = 0}, elapsed 61 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 808200000408d222e9
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000},
elapsed 5e ms
============================================================================
= The Calypso secure session ended successfully =
= (Successful mutual authentication) =
= End of the Calypso PO processing =
============================================================================
&lt;/code>&lt;/pre></description></item><item><title>Common concepts</title><link>https://keyple.org/docs/developer-guide/common-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/common-concepts/</guid><description>&lt;hr>
&lt;p>This page describes the core elements of &lt;strong>Keyple&lt;/strong>, i.e. the concepts and APIs of &lt;strong>Keyple Core&lt;/strong> that are used to build any application implementing &lt;strong>Keyple&lt;/strong>.&lt;/p>
&lt;p>It is essential for the future user of &lt;strong>Keyple&lt;/strong> to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;hr>
&lt;h2 id="reader">Reader&lt;/h2>
&lt;p>Keyple&amp;rsquo;s primary goal being to interact with smart cards (or smartphones) worn by individuals, it is logical to put the Reader at the top of &lt;strong>Keyple Core&lt;/strong>&amp;rsquo;s concepts.&lt;/p>
&lt;p>Indeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via &lt;strong>Keyple Core&lt;/strong> or using an extension (such as &lt;strong>Keyple Calypso&lt;/strong>).&lt;/p>
&lt;p>These interfaces provide the means to&lt;/p>
&lt;ul>
&lt;li>identify the underlying physical reader,&lt;/li>
&lt;li>manage communication protocols,&lt;/li>
&lt;li>detect the presence and communicate with smart cards.&lt;/li>
&lt;/ul>
&lt;p>The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="plugin">Plugin&lt;/h2>
&lt;p>In Keyple language a plugin is a service that allows the management of readers of a certain type.
The plugin is responsible for informing the application about the availability of readers.
The readers of the same plugin are usually hardware linked to the same physical interface.&lt;/p>
&lt;p>Depending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).&lt;/p>
&lt;p>The Plugin interface essentially allows to list and retrieve the available readers.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="smart-card-service">Smart card service&lt;/h2>
&lt;p>This is the &lt;strong>Keyple Core&lt;/strong> service that concentrates the knowledge of active plugins and readers.&lt;/p>
&lt;p>At startup, a Keyple application must register the plugins it uses. Conversely, it can also unregister them.&lt;/p>
&lt;p>The &lt;strong>SmartCardService&lt;/strong> will then make sure that the resources used are properly released.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="observation">Observation&lt;/h2>
&lt;p>The observation concept applies to readers as well as to plugins; optional, it is used depending on the needs.&lt;/p>
&lt;p>It consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.&lt;/p>
&lt;p>Not all plugins and readers are observable.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#reader-notifications">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="selection">Selection&lt;/h2>
&lt;p>In Keyple the concept of selection is derived from the application selection defined by the ISO7816-4 standard.&lt;/p>
&lt;p>It supplements it by managing cards that do not have the standard command using identification mechanisms based on Answer To Reset and the communication protocol, and also by allowing the execution of commands immediately following application selection or detection.&lt;/p>
&lt;p>This principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.&lt;/p>
&lt;p>Several targets can be defined by the application according to the different customer cards expected.&lt;/p>
&lt;p>The &lt;strong>default selection&lt;/strong> principle consists in providing an observable reader with a set of selection cases corresponding to the expected cards and receiving notifications containing not only the card identification but also the result of all additional commands that the application will have attached.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#card-selection">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="abstract-smart-card">Abstract smart card&lt;/h2>
&lt;p>The &lt;strong>abstract smart card&lt;/strong> concept is used by specific extensions (e.g. &lt;strong>Keyple Calypso&lt;/strong>) and by the &lt;strong>Keyple Core&lt;/strong> selection mechanism.
It corresponds to an abstract container model implemented by the extension specific to a card type and returned by the selection process.&lt;/p>
&lt;p>This container will be able to carry all the useful information known about the card.&lt;/p>
&lt;p>Note: this concept, mentioned here for understanding, should not appear to the application developer if he uses a card extension.&lt;/p>
&lt;p>
&lt;a href="./docs/architecture/keyple-core/#card-selection">More information&lt;/a>&lt;/p></description></item><item><title>Standalone application</title><link>https://keyple.org/docs/developer-guide/standalone-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/standalone-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A standalone application is an application that runs in a device in contact
with the end user.&lt;/p>
&lt;p>It has at least one local smart card reader and manages itself the
interaction with the user.&lt;/p>
&lt;p>In the ticketing industry, it is typically the software that runs a
validator, a vending machine or a control terminal.&lt;/p>
&lt;p>The diagram below illustrates the organization of the local standalone
components:
&lt;figure >
&lt;a data-fancybox="" href="./media/standalone-application/component/Local_Application_Components_Overview.svg" >
&lt;img src="./media/standalone-application/component/Local_Application_Components_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;hr>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read the
&lt;a href="./docs/developer-guide/common-concepts/">common concepts&lt;/a> page and become familiar with the basic
concepts on which &lt;strong>Keyple&lt;/strong> is based.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the
implementation of &lt;strong>Keyple Core&lt;/strong>, please study the
&lt;a href="#workflow">workflow&lt;/a> proposed in the following chapter.&lt;/li>
&lt;li>Explore the
&lt;a href="#keyplecoreapi">Keyple Core API&lt;/a> to discover all the
possibilities offered by &lt;strong>Keyple Core&lt;/strong>.&lt;/li>
&lt;li>Take inspiration from the
&lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the
&lt;a href="./docs/build-your-first-app/">Build your first app&lt;/a> section to configure your
environment.&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/">Java components&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/">C++ components&lt;/a> pages, import
&lt;strong>Keyple Core&lt;/strong> into your project and start playing with &lt;strong>Keyple&lt;/strong>.&lt;/li>
&lt;li>Don&amp;rsquo;t forget to explore the potential of Keyple card-specific
extensions such as &lt;strong>Keyple Calypso&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="workflow">Workflow&lt;/h2>
&lt;p>&lt;strong>Keyple Core&lt;/strong> is built around the concepts described
&lt;a href="./docs/developer-guide/common-concepts/">here&lt;/a> and sometimes proposes several ways to perform
an action or to achieve a result depending on the needs of the
application.&lt;/p>
&lt;p>The purpose of this section is to guide you in its use.&lt;/p>
&lt;h3 id="creation-of-the-smart-card-service">Creation of the Smart Card Service&lt;/h3>
&lt;p>This is the very first step in the realization of a Keyple application:&lt;/p>
&lt;pre>&lt;code class="language-java">/* Get the instance of the SmartCardService */
SmartCardService smartCardService = SmartCardService.getInstance();
&lt;/code>&lt;/pre>
&lt;p>The Smart Card Service is based on the SmartCardService object, which is
a singleton that must be held by the application all along its
execution.&lt;/p>
&lt;p>Its main role is to centralize Keyple resources and manage their
lifecycle.&lt;/p>
&lt;h3 id="choose-the-plugin">Choose the plugin&lt;/h3>
&lt;p>The Keyple application developer will choose the plugins he needs
according to the equipment on which his Keyple application will run.&lt;/p>
&lt;p>For example, if the environment is PC based, one will probably, but
without obligation, go for the PC/SC plugin.&lt;/p>
&lt;p>For an Andoid terminal environment, the plugin could be the standard
Android NFC plugin or one of the plugins available from the industrial
partners of the project. For a complete list of available plugins,
please see the
&lt;a href="https://keyple.org/components-java/">Java&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/">C++&lt;/a> pages.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A new plugin can also be &lt;a href="./docs/developer-guide/create-plugin/">created&lt;/a> if the envisaged hardware does not yet have its
plugin.
&lt;/div>
&lt;/div>
&lt;h3 id="register-the-plugin">Register the plugin&lt;/h3>
&lt;p>All Keyple plugins implement the &lt;code>Plugin&lt;/code> interface.&lt;/p>
&lt;p>The plugin registration consists in submitting its factory to the Smart
Card Service.&lt;/p>
&lt;pre>&lt;code class="language-java">/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, readerExceptionHandlerImpl));
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
&lt;p>The plugin factories all implement the interface expected by
SmartCardService.&lt;/p>
&lt;p>Depending on the case, the constructor of the factory provided by the
plugin can take parameters as argument.&lt;/p>
&lt;p>For example, in the code above, the PC/SC plugin expects exception
handlers, but in other cases it could be other parameters.&lt;/p>
&lt;/div>
&lt;/div>
&lt;h3 id="observation-of-the-plugin">Observation of the plugin&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The notion of plugin observation applies only to
hardware environments in which the readers are removable.
&lt;/div>
&lt;/div>
&lt;p>The observation of reader connections and disconnections is achieved
through a background task managed by &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;p>It is therefore imperative to provide an exception handler to allow
&lt;strong>Keyple Core&lt;/strong> to warn the application in case of an execution error
during monitoring or event notification.&lt;/p>
&lt;p>Here is an example of exception handler implementation in a PC/SC plugin
context:&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class PluginExceptionHandlerImpl implements PluginObservationExceptionHandler {
@Override
public void onPluginObservationError(String pluginName, Throwable throwable) {
logger.error(&amp;quot;An unexpected plugin error occurred: {}&amp;quot;, pluginName, throwable);
}
}
}
/* Create an exception handler for plugin observation */
PluginExceptionHandlerImpl pluginExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, null));
...
&lt;/code>&lt;/pre>
&lt;p>For the observation of the plugin itself, the application must provide
an object implementing the &lt;code>PluginObserver&lt;/code> interface to the plugin
after having casted it in &lt;code>ObservablePlugin&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservablePlugin) plugin).addObserver(new PluginObserver());
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PluginObserver&lt;/code> interface requires the implementation of the
&lt;code>update&lt;/code> method that will be called by Keyple Core when notifying
plugin events.&lt;/p>
&lt;pre>&lt;code class="language-java">class PluginObserver implements ObservablePlugin.PluginObserver {
@Override
public void update(PluginEvent event) {
switch (event.getEventType()) {
case READER_CONNECTED:
// here the processing to be done when a reader is connected
...
break;
case READER_DISCONNECTED:
// here the processing to be done when a reader is disconnected
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-the-reader">Retrieve the reader&lt;/h3>
&lt;p>Readers are objects implementing the &lt;code>Reader&lt;/code> interface and are
returned by the plugin&amp;rsquo;s &lt;code>getReader&lt;/code> method taking the name of the
reader as argument.&lt;/p>
&lt;p>The names of the readers available from the plugin are returned as a
list of strings by the &lt;code>getReaderNames&lt;/code> method.&lt;/p>
&lt;p>The &lt;code>getReaders&lt;/code> method also allows to retrieve all readers in a Map
whose key is the name of the reader and the value the &lt;code>Reader&lt;/code>
object.&lt;/p>
&lt;p>Here is an example to get the 1st PC/SC reader:&lt;/p>
&lt;pre>&lt;code class="language-java">String readerName = plugin.getReaderNames().get(0);
Reader reader = plugin.getReader(readerName);
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Depending on the type of plugin, the reader names are
more or less dynamic (e.g. a PC/SC based system vs. an embedded
terminal), it is sometimes necessary to implement an identification
mechanism in order to assign the right reader to the right place in the
system (for example by using regular expressions).
&lt;/div>
&lt;/div>
&lt;h3 id="customize-the-reader-settings">Customize the reader settings&lt;/h3>
&lt;p>Take a close look at the parameters proposed by the plugin and its
readers.&lt;/p>
&lt;p>In particular, it is necessary to configure the expected communication
protocols, but it is also possible that other settings exist depending
on the hardware context.&lt;/p>
&lt;h3 id="observation-of-the-reader">Observation of the reader&lt;/h3>
&lt;p>The observation of inserting and removing cards from readers is similar
to the observation of plugins in that it requires the same operations,
i.e. the use of an exception handler and an object implementing a
dedicated interface.&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class ReaderExceptionHandlerImpl implements ReaderObservationExceptionHandler {
@Override
public void onReaderObservationError(String pluginName, String readerName, Throwable throwable) {
logger.error(&amp;quot;An unexpected reader error occurred: {}:{}&amp;quot;, pluginName, readerName, throwable);
}
}
}
/* Create an exception handler for reader observation */
ReaderExceptionHandlerImpl readerExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, readerExceptionHandlerImpl));
...
&lt;/code>&lt;/pre>
&lt;p>The observation of the events of the reader is done in a similar way to
that of the plugin, by adding an observer:&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservableReader) reader).addObserver(new ReaderObserver());
&lt;/code>&lt;/pre>
&lt;p>and implementing the ReaderObserver interface:&lt;/p>
&lt;pre>&lt;code class="language-java">class ReaderObserver implements ObservableReader.ReaderObserver {
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_INSERTED:
// here the processing to be done when a card is inserted
...
break;
case CARD_MATCHED:
// here the processing to be done when a card matched the selection
...
break;
case CARD_REMOVED:
// here the processing to be done when a card is removed
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Observation of the readers is optional in Keyple. It
facilitates an event-driven programming mode, but an application
developer can choose not to observe a reader, either because this reader
is not designed to manage card insertions/withdrawals (for example an
Android OMAPI reader or a SAM reader), or because the application is
designed to directly manage the presence of a card (refer to the
&lt;code>Reader&lt;/code> interface).
&lt;/div>
&lt;/div>
&lt;h3 id="card-selection">Card selection&lt;/h3>
&lt;p>The card selection service offered by &lt;strong>Keyple Core&lt;/strong> gives multiple
possibilities to choose the processing according to the type of card
presented to the reader.&lt;/p>
&lt;p>It is based on a filtering process according to three possible criteria,
each of which is optional:&lt;/p>
&lt;ul>
&lt;li>the communication protocol of the card (usually also identifying a
card technology)&lt;/li>
&lt;li>the answer to reset of the card (ATR)&lt;/li>
&lt;li>the ISO standardized application identifier (AID)&lt;/li>
&lt;/ul>
&lt;p>Each of these criteria can be defined in a &lt;code>CardSelector&lt;/code> object.&lt;/p>
&lt;p>When a card is inserted, it is evaluated according to these criteria and
will be given the status &amp;ldquo;selected&amp;rdquo; or not.&lt;/p>
&lt;p>When a card is not selected, no other operation will be possible with
it. Depending on the chosen setting, the result of the selection will or
will not be made available to the application. It is thus possible to
directly ignore cards that do not correspond to the defined selection
criteria.&lt;/p>
&lt;p>When a card is selected, the result is an object that extends the
AbstractSmartCard and contains all the information known about the card
at that stage.&lt;/p>
&lt;p>In the case of a ISO standardized card, the application is selected with
the provided AID (additional settings are available to specify the
desired navigation within the card applications list).&lt;/p>
&lt;p>In addition to the selection process itself, specific APDU commands can
be sent to the card if the selection is successful. The output data of
these commands are available in the instance of the object
&lt;code>AbstractSmarCard&lt;/code>.&lt;/p>
&lt;p>The &lt;code>CardSelector&lt;/code> and the additional APDU commands are grouped in a
&lt;code>CardSelectionRequest&lt;/code> object.&lt;/p>
&lt;p>One or more &lt;code>CardSelectionRequest&lt;/code> can be set up to perform as many
selection cases, each targeting a particular card or application.&lt;/p>
&lt;p>The final selection process takes as input a list of
&lt;code>CardSelectionRequest&lt;/code> and gets in return a list of
&lt;code>CardSelectionResponse&lt;/code>.&lt;/p>
&lt;h4 id="card-selection-steps">Card selection steps&lt;/h4>
&lt;p>In this guide we will not show the addition of supplementary APDU
commands. Please refer to the Calypso guide for an implementation
example.&lt;/p>
&lt;h5 id="create-the-card-selection-service">Create the card selection service&lt;/h5>
&lt;p>The card selection service will be used all along the card search
process.&lt;/p>
&lt;pre>&lt;code class="language-java"> cardSelectionService = new CardSelectionsService();
&lt;/code>&lt;/pre>
&lt;h5 id="create-the-selection-cases">Create the selection cases&lt;/h5>
&lt;p>The application can create as many selection cases as the type of cards
expected. The order in which the selection cases are prepared is
important because it will favor the latency delay for the processing of
the cards corresponding to the first case. It is therefore recommended
to place the most common card profile in the application context first.&lt;/p>
&lt;pre>&lt;code class="language-java">/** Create a new class extending AbstractCardSelection */
public final class GenericCardSelection extends AbstractCardSelection {
public GenericCardSelection(CardSelector cardSelector) {
super(cardSelector);
}
@Override
protected AbstractSmartCard parse(CardSelectionResponse cardSelectionResponse) {
class GenericSmartCard extends AbstractSmartCard {
public GenericSmartCard(CardSelectionResponse cardSelectionResponse) {
super(cardSelectionResponse);
}
public String toJson() {
return &amp;quot;{}&amp;quot;;
}
}
return new GenericSmartCard(cardSelectionResponse);
}
}
final String aid1 = &amp;quot;AABBCCDDEE&amp;quot;;
final String aid2 = &amp;quot;EEDDCCBBAA&amp;quot;;
// first selection case targeting cards with AID1
GenericCardSelection cardSelector1 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid1).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector1);
// first selection case targeting cards with AID1
GenericCardSelection cardSelector2 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid2).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector2);
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-a-non-observable-reader">Proceed to the selection with a non-observable reader&lt;/h5>
&lt;p>The &lt;code>processExplicitSelections&lt;/code> method of &lt;code>CardSelectionService&lt;/code>
performs the actual communication with the card.&lt;/p>
&lt;pre>&lt;code class="language-java">...
// Check if a card is present in the reader
if (!reader.isCardPresent()) {
logger.error(&amp;quot;No Po Card is present in the reader.&amp;quot;);
return;
}
// Actual card communication: operate through a single request the card selection
CardSelectionsResult cardSelectionsResult =
cardSelectionsService.processExplicitSelections(reader);
...
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-an-observable-reader">Proceed to the selection with an observable reader&lt;/h5>
&lt;p>In the case of an observable reader, the selection request is provided
to the reader (it is then named Default Selection) and will be processed
automatically as soon as a card is presented. The application is then
notified of the event with the data resulting from the selection.
Depending on the selection settings, the application will be notified of
all card presentations (&lt;code>CARD_INSERTED&lt;/code> event) or only those
presentations that led to a successful selection (&lt;code>CARD_MATCHED&lt;/code>
event).&lt;/p>
&lt;h6 id="add-a-default-selection">Add a default selection&lt;/h6>
&lt;pre>&lt;code class="language-java">// Provide the Reader with the selection operation to be processed when a card is inserted.
((ObservableReader) reader)
.setDefaultSelectionRequest(
cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(),
ObservableReader.NotificationMode.MATCHED_ONLY,
ObservableReader.PollingMode.REPEATING);
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>NotificationMode&lt;/code> allows you to specify whether all card
insertions should be reported to the application or only those that led
to a successful selection.&lt;/p>
&lt;p>&lt;code>PollingMode&lt;/code> indicates whether to go back to waiting for the card
after processing (&lt;code>REPEATING&lt;/code>) or let the application decide when to
restart the search (&lt;code>SINGLESHOT&lt;/code>) with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;p>Note: when the default selection is set with the &lt;code>PollingMode&lt;/code>
parameter, the card detection is started automatically. However, it is
possible to set a default selection without automatic start and by
starting the detection independently with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;h6 id="receive-the-result-as-an-event">Receive the result as an event&lt;/h6>
&lt;pre>&lt;code class="language-java">...
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_MATCHED:
AbstractSmartCard selectedCard = null;
try {
selectedCard =
getDefaultSelection()
.processDefaultSelectionsResponse(event.getDefaultSelectionsResponse())
.getActiveSmartCard();
} catch (KeypleException e) {
logger.error(&amp;quot;Exception: {}&amp;quot;, e.getMessage());
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
if (selectedCard != null) {
logger.info(&amp;quot;Observer notification: the selection of the card has succeeded.&amp;quot;);
// insert the processing of the card here
...
logger.info(&amp;quot;= #### End of the card processing.&amp;quot;);
} else {
logger.error(
&amp;quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
}
break;
case CARD_INSERTED:
logger.error(
&amp;quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
break;
case CARD_REMOVED:
logger.trace(&amp;quot;There is no PO inserted anymore. Return to the waiting state...&amp;quot;);
break;
default:
break;
}
if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED
|| event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) {
// Informs the underlying layer of the end of the card processing, in order to manage the
// removal sequence.
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
}
...
&lt;/code>&lt;/pre>
&lt;h5 id="get-the-selection-result">Get the selection result&lt;/h5>
&lt;p>The result of the selection is available in the &lt;code>AbstractSmartCard&lt;/code>
object.&lt;/p>
&lt;pre>&lt;code class="language-java">...
if (!cardSelectionsResult.hasActiveSelection()) {
logger.warn(&amp;quot;The selection of the application &amp;quot; + cardAid + &amp;quot; failed.&amp;quot;);
}
AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard();
logger.info(&amp;quot;The selection of the card has succeeded.&amp;quot;);
if (smartCard.hasFci()) {
String fci = ByteArrayUtil.toHex(smartCard.getFciBytes());
logger.info(&amp;quot;Application FCI = {}&amp;quot;, fci);
}
if (smartCard.hasAtr()) {
String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes());
logger.info(&amp;quot;Card ATR = {}&amp;quot;, atr);
}
...
&lt;/code>&lt;/pre>
&lt;h3 id="implementation-of-the-application-service">Implementation of the application service&lt;/h3>
&lt;p>The applicative processing of the card that follows the selection of the
card is to be inserted in the processing of the &lt;code>CARD_INSERTED&lt;/code> or
&lt;code>CARD_MATCHED&lt;/code> event.&lt;/p>
&lt;p>It can be processed in the thread provided by the monitoring task or
detached in a separate thread. The application developer must pay
attention to the handling of exceptions in this part of the application.
Indeed, in case of a runtime exception, the information will be given to
the application via the exception handler configured beforehand.&lt;/p>
&lt;h3 id="stopping-the-application">Stopping the application&lt;/h3>
&lt;p>The clean shutdown of a Keyple application requires the release of
resources and in particular the shutdown of the observation threads.&lt;/p>
&lt;p>This is done by unregistering the plugins in the following way:&lt;/p>
&lt;pre>&lt;code class="language-java">smartCardService.unregisterPlugin(plugin.getName());
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="keyple-core-api">Keyple Core API&lt;/h2>
&lt;p>To learn all the details of the &lt;strong>Keyple Core&lt;/strong> API, please consult the
&lt;a href="./docs/api-reference/">Javadoc documentation&lt;/a>.&lt;/p>
&lt;p>However, here are two diagrams showing the main features of Keyple Core:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the
&lt;strong>Smart Card Service&lt;/strong> with in particular the observation mechanisms.
&lt;figure >
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" >
&lt;img src="./media/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The diagram below represents the main classes used for selection
operations.
&lt;figure >
&lt;a data-fancybox="" href="./media/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" >
&lt;img src="./media/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>To help in the implementation of the different facilities offered by
Keyple to process smart cards, a set of examples is present in the
project repository
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone" target="_blank" rel="noopener">
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i> examples&lt;/a>&lt;/p>
&lt;p>Nevertheless, you will find below a brief description of them:&lt;/p>
&lt;h3 id="explicit-selection">Explicit Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection without observing the
reader, based on testing the presence of the card by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase1_ExplicitSelectionAid" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="default-selection">Default Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection with observation of the
reader. A default selection is prepared, the presentation of a card
triggers the notification of a reader event to the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase2_DefaultSelectionNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="sequential-multiple-selection">Sequential Multiple Selection&lt;/h3>
&lt;p>Executes successively several independent selection operations with the
use of the ISO &amp;lsquo;NEXT&amp;rsquo; navigation flag.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase3_SequentialMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;p>Illustrates the case of a card exploration with maintenance of the physical channel open.&lt;/p>
&lt;h3 id="grouped-multiple-selection">Grouped Multiple Selection&lt;/h3>
&lt;p>Executes a multiple selection with logical channel closure between each
selection.&lt;/p>
&lt;p>Allows the exploration of the applications of a card in a single
operation but without selection at the end.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase4_GroupedMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-card-protocol-detection">Demo Card Protocol Detection&lt;/h3>
&lt;p>Demonstrates the use of Keyple in a context where several card
technologies are likely to be processed by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_CardProtocolDetection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-observable-reader-notification">Demo Observable Reader Notification&lt;/h3>
&lt;p>Demonstrates the use of Keyple to implement the observation of a plugin
and its readers. Readers are dynamically created and an observer is
assigned to them.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_ObservableReaderNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>The artifact &lt;strong>Keyple Core&lt;/strong> and how to integrate it into your
application is available here:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/">Keyple Core Java component&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/core/">Keyple Core C++ component&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Distributed application</title><link>https://keyple.org/docs/developer-guide/distributed-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/distributed-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Keyple provides the &amp;ldquo;Keyple Distributed&amp;rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal&lt;/strong>.&lt;/p>
&lt;p>In this way, you can manage transactions within a distributed architecture.&lt;/p>
&lt;p>The diagram below shows the role of the &lt;strong>Keyple Distributed&lt;/strong> components in the software layers used in a distributed architecture :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/component/Distributed_Component_Overview.svg" >
&lt;img src="./media/distributed-application/component/Distributed_Component_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;hr>
&lt;h2 id="how-to-use-it-">How to use it ?&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read page
&lt;a href="./docs/developer-guide/standalone-application/">Standalone application&lt;/a> to understand the main concepts of Keyple in a standalone application.&lt;/li>
&lt;li>Read chapter
&lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/li>
&lt;li>Read the introduction of chapter
&lt;a href="#configuration-modes">Configuration modes&lt;/a> to be informed about the different features and APIs proposed by the solution.&lt;/li>
&lt;li>Using chapter
&lt;a href="#use-cases">Use cases&lt;/a>, find your use case. This will help you to determine exactly which library and API to use.&lt;/li>
&lt;li>Using chapter
&lt;a href="#download">Download&lt;/a>, import into your project the libraries specified by your use case.&lt;/li>
&lt;li>Using chapter
&lt;a href="#network-configuration">Network configuration&lt;/a>, implement the transport layer adapted to your network configuration.&lt;/li>
&lt;li>Implement your ticketing services as specified in the associated use case.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this developer guide :&lt;/p>
&lt;div id="concepts-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Concept&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Remote Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-remote&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-local&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-network&lt;/code>.&lt;br>This library is &lt;strong>implicitly&lt;/strong> imported by &lt;strong>Remote Lib&lt;/strong> and &lt;strong>Local Lib&lt;/strong> because it contains common network elements.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple plugin which provides only &lt;strong>Remote Readers&lt;/strong> to the application. It manages data exchanges with the &lt;strong>Local Service&lt;/strong>. This plugin must be registered to the smart card service like any Keyple plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Reader&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Plugin&lt;/strong>, this is a Keyple reader which has some specificities :&lt;br>- each remote reader is connected to a local reader ;&lt;br>- any command sent by the application to a remote reader will be forwarded to the associated local reader ;&lt;br>- any event occurs on a local reader or plugin will be forwarded to the associated remote reader or plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Local Lib&lt;/strong>, this service ensures data exchange between the &lt;strong>Remote Plugin&lt;/strong> and local plugins and readers. It must be initialized and started by the host application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific factory class to initialize them.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific utility class to access them everywhere in the code.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each are bind to a specific internal node which is responsible for the interfacing with the &lt;strong>Network Endpoint&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Endpoint&lt;/strong>&lt;/td>
&lt;td>At the user&amp;rsquo;s charge, this component ensures the network exchanges between the &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> nodes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#concepts-table-1 table th:first-of-type {
width: 130px;
}
&lt;/style>
&lt;p>The diagram below illustrates the main functional concepts through a standard use case :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/component/Distributed_Component_Concepts_1.svg" >
&lt;img src="./media/distributed-application/component/Distributed_Component_Concepts_1.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.&lt;/p>
&lt;p>These could be for example a ticketing reloading service, where the business logic would be on the terminal with remote readers, with thin clients on A &amp;amp; B terminals communicating locally with the cards.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for card communication.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/component/Distributed_Component_Concepts_2.svg" >
&lt;img src="./media/distributed-application/component/Distributed_Component_Concepts_2.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>Here is another example, but this time it illustrates several &lt;strong>Remote Plugin&lt;/strong> components connected to the same &lt;strong>Local Service&lt;/strong>.&lt;/p>
&lt;p>These could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for SAM communication.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/component/Distributed_Component_Concepts_3.svg" >
&lt;img src="./media/distributed-application/component/Distributed_Component_Concepts_3.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;hr>
&lt;h2 id="configuration-modes">Configuration modes&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution provides &lt;strong>3&lt;/strong> different configuration modes, each one having a specific
&lt;a href="#apis">API&lt;/a> designed on a &lt;strong>Client-Server&lt;/strong> model :&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Configuration mode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#reader-client-side">Reader Client Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#reader-server-side">Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 190px;
}
&lt;/style>
&lt;p>Each mode provides a different &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components and their associated factories and utility classes.&lt;/p>
&lt;p>Each &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> has a default name, but it&amp;rsquo;s possible to specify a custom name during the initialization phase.&lt;/p>
&lt;p>In an application, it is thus possible to use simultaneously several configuration modes and as many instances of a configuration mode as you want, as long as the components are initialized with different names.&lt;/p>
&lt;h3 id="reader-client-side">Reader Client Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClient&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory by providing the network and plugin observer implementation. Please note that &lt;strong>this plugin is observable only to trigger ticketing services&lt;/strong> on the server side, but does not allow observation on the local plugin (reader insertion, etc&amp;hellip;),&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>await for events of type &lt;code>PluginEvent.READER_CONNECTED&lt;/code>,&lt;/li>
&lt;li>when an event occurs, get the specified remote reader from the &lt;strong>Remote Plugin&lt;/strong>,&lt;/li>
&lt;li>use information inside the remote reader to identify the ticketing service to execute,&lt;/li>
&lt;li>execute the specified ticketing service using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service and get the local reader to connect to the server,&lt;/li>
&lt;li>execute the remote service using the &lt;strong>Local Service&lt;/strong> API by indicating the ticketing service id to execute and transmitting to the server if needed personal information or smart card content previously read.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="illustration">ILLUSTRATION&lt;/h4>
&lt;p>The following sequence diagram shows the capabilities of the plugin through an arbitrary example that illustrates :&lt;/p>
&lt;ul>
&lt;li>the initialization phase of the local and remote components ;&lt;/li>
&lt;li>the registration of the local plugin and observable reader ;&lt;/li>
&lt;li>the selection phase of an observable reader carried out directly by the client ;&lt;/li>
&lt;li>the sending of the selection result and additional information to the server to remotely perform a specific ticketing service (materialization, validation, etc&amp;hellip;) ;&lt;/li>
&lt;li>the reception by the server of the transmitted data ;&lt;/li>
&lt;li>the execution of the remote ticketing service ;&lt;/li>
&lt;li>the server subscription to observable reader events ;&lt;/li>
&lt;li>the sending of information to the client at the end of processing.&lt;/li>
&lt;/ul>
&lt;p>Note that the network layer is deliberately hide in this diagram. Its implementation is described in the
&lt;a href="#network-configuration">Network configuration&lt;/a> chapter.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/sequence/Distributed_Sequence_ReaderClientSide_API.svg" >
&lt;img src="./media/distributed-application/sequence/Distributed_Sequence_ReaderClientSide_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="reader-server-side">Reader Server Side&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
This configuration mode will only be available from version &lt;strong>1.1&lt;/strong> onwards.
&lt;/div>
&lt;/div>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/p>
&lt;p>It also allows to observe the plugin events (such as reader connection, etc&amp;hellip;) if desired.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code> or&lt;br>&lt;code>ObservableRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-1">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local plugin (or observable plugin) with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="pool-reader-server-side">Pool Reader Server Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-2">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local pool plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local pool plugin with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="use-cases">Use cases&lt;/h2>
&lt;p>Here is a summary table of all proposed use cases. Search for the one that corresponds to your need and then look at the associated description :&lt;/p>
&lt;div id="use-cases-table-2">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Use Case&lt;/th>
&lt;th style="text-align:center">Reader type&lt;/th>
&lt;th style="text-align:center">Reader endpoint&lt;/th>
&lt;th style="text-align:center">Reader observation&lt;/th>
&lt;th style="text-align:center">Plugin observation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-1">UC 1&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-2">UC 2&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-3">UC 3&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-4">UC 4&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-5">UC 5&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-6">UC 6&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-7">UC 7&lt;/a>&lt;/td>
&lt;td style="text-align:center">Pool&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#use-cases-table-2 table th:nth-of-type(6) {
width: 240px;
}
&lt;/style>
&lt;h4 id="uc-1">UC 1&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the client side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>RemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-2">UC 2&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withReaderObservation(...)&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableRemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>To observe &amp;ldquo;remotely&amp;rdquo; the reader events, you must :&lt;/p>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>register at least one observer to the remote reader created during the first client call and await for reader events,&lt;/li>
&lt;li>retrieve the remote reader from the &lt;strong>Remote Plugin&lt;/strong> &lt;strong>imperatively&lt;/strong> using the reader name contained in the received event,&lt;/li>
&lt;li>execute the ticketing service associated to the event using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service associated to the event using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>execute a remote service first in order to connect a remote reader to the local reader and to allow the remote application to subscribe to the events of the remote reader.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="uc-3">UC 3&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-4">UC 4&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-5">UC 5&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-6">UC 6&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-7">UC 7&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a> configuration mode.&lt;/p>
&lt;p>This unique mode proposed for this plugin does not allow to observe the local reader.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="network-configuration">Network configuration&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution &lt;strong>does not provide&lt;/strong> the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components.&lt;/p>
&lt;h3 id="synchronous">Synchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Client-Server &lt;strong>Synchronous&lt;/strong> communication protocol, such as standard HTTP for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>SyncEndpointClient&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>SyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>SyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withSyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>getSyncNode()&lt;/code> or&lt;br> &lt;code>getSyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement in a context with a &lt;strong>single server instance&lt;/strong> :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/sequence/Distributed_Sequence_SyncNode_API.svg" >
&lt;img src="./media/distributed-application/sequence/Distributed_Sequence_SyncNode_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a &lt;code>serverNodeId&lt;/code> are routed to the server associated with a &lt;code>SyncNodeServer&lt;/code> node having the &lt;code>serverNodeId&lt;/code>.&lt;/p>
&lt;h3 id="asynchronous">Asynchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Full-Duplex &lt;strong>Asynchronous&lt;/strong> communication protocol, such as Web Sockets for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>AsyncEndpointClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncEndpointServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>AsyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/sequence/Distributed_Sequence_AsyncNode_API.svg" >
&lt;img src="./media/distributed-application/sequence/Distributed_Sequence_AsyncNode_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="exchanged-data">Exchanged data&lt;/h3>
&lt;p>The data exchanged between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components are contained in the DTO (Data Transfer Object) &lt;code>MessageDto&lt;/code>. It is built and processed by the plugin and &lt;strong>you don&amp;rsquo;t need to modify it&lt;/strong>.&lt;/p>
&lt;p>However, it is necessary in some contexts to access certain information such as the &lt;code>sessionId&lt;/code> in the case of asynchronous communication or the &lt;code>serverNodeId&lt;/code> in the case of synchronous communication with several server instances.&lt;/p>
&lt;hr>
&lt;h2 id="apis">APIs&lt;/h2>
&lt;p>The class diagrams below shows the different APIs exposed and SPIs required by the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/p>
&lt;p>An &lt;strong>SPI&lt;/strong> (Service Provider Interface) is an interface that must be implemented by the user.&lt;/p>
&lt;p>Here are the available APIs depending on the library imported by your project :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th style="text-align:center">Remote Lib&lt;/th>
&lt;th style="text-align:center">Local Lib&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#network-api">Network API&lt;/a>&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#remote-api">Remote API&lt;/a>&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#local-api">Local API&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The associated &lt;strong>API&lt;/strong> documentations are accessible from the page
&lt;a href="./docs/api-reference/">API Reference&lt;/a>.&lt;/p>
&lt;h3 id="network-api">Network API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-network/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/class/Distributed_Class_Network_API.svg" >
&lt;img src="./media/distributed-application/class/Distributed_Class_Network_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="remote-api">Remote API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-remote/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/class/Distributed_Class_Remote_API.svg" >
&lt;img src="./media/distributed-application/class/Distributed_Class_Remote_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="local-api">Local API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-local/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="./media/distributed-application/class/Distributed_Class_Local_API.svg" >
&lt;img src="./media/distributed-application/class/Distributed_Class_Local_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/distributed" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="./components-java/distributed-systems/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso application</title><link>https://keyple.org/docs/developer-guide/calypso-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/calypso-application/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Create a plugin</title><link>https://keyple.org/docs/developer-guide/create-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/create-plugin/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Create an extension</title><link>https://keyple.org/docs/developer-guide/create-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/create-extension/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Upgrade from an earlier version of Keyple</title><link>https://keyple.org/docs/developer-guide/upgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/upgrade/</guid><description>&lt;hr>
&lt;p>This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.&lt;/p>
&lt;p>Upgrade from:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="#upgrade-from-090-to-100">0.9.0 to 1.0.0&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#upgrade-from-081-to-090">0.8.1 to 0.9.0&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Note: here we describe the evolutions in broad outline, for the details of the APIs, the reader is invited to consult
the
&lt;a href="https://keyple.org/docs/api-reference/">API reference&lt;/a> section.&lt;/p>
&lt;hr>
&lt;h2 id="upgrade-from-090-to-100">Upgrade from 0.9.0 to 1.0.0&lt;/h2>
&lt;h3 id="whats-changed">What&amp;rsquo;s changed?&lt;/h3>
&lt;p>Compared to version 0.9, the goal of Keyple 1.0 is mainly to fix bugs,
add features to make Keyple more robust and rename/reorganize classes to make it easier to learn.&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="#class-renaming">Renamings&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#internal-exception-handling">Internal exception handling&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#pcsc-plugin">PC/SC plugin&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#keyple-distributed">Keyple Distributed&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="class-renaming">Class renaming&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Module&lt;/th>
&lt;th>Old name (0.9.0)&lt;/th>
&lt;th>New name (1.0.0)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeProxyService&lt;/td>
&lt;td>SmartCardService&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>ReaderPlugin&lt;/td>
&lt;td>Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeReader&lt;/td>
&lt;td>Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>ReaderPoolPlugin&lt;/td>
&lt;td>PoolPlugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeSelection&lt;/td>
&lt;td>CardSelectionService&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeSelector&lt;/td>
&lt;td>CardSelector&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>AbstractMatchingSe&lt;/td>
&lt;td>AbstractSmartCard&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Calypso&lt;/td>
&lt;td>PoSelectionRequest&lt;/td>
&lt;td>PoSelection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Calypso&lt;/td>
&lt;td>SamSelectionRequest&lt;/td>
&lt;td>SamSelection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="internal-exception-handling">Internal exception handling&lt;/h4>
&lt;p>New possibilities have been added in the management of observable objects (&lt;em>Plugin&lt;/em> and &lt;em>Reader&lt;/em>).&lt;/p>
&lt;p>If the Plugin or Reader is observable, it is now necessary to define exception handlers that will be called by the internal layers of Keyple in the case of an exception raised by an observation process.&lt;/p>
&lt;p>Two new interfaces have been added to the &lt;em>event&lt;/em> package to allow applications via the factories of the concerned plugins to define the method that will be called when needed:&lt;/p>
&lt;ul>
&lt;li>&lt;code>PluginObservationExceptionHandler&lt;/code>&lt;/li>
&lt;li>&lt;code>ReaderObservationExceptionHandler&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These handlers are usually provided by the application via the constructor of the plugin&amp;rsquo;s factory.&lt;/p>
&lt;h4 id="pcsc-plugin">PC/SC plugin&lt;/h4>
&lt;p>The generic parameterization interface for plugins and readers has been removed in favor of methods specific to each plugin.&lt;/p>
&lt;p>In the case of the PC/SC plugin, the following methods have appeared:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>PcscPlugin&lt;/td>
&lt;td>&lt;code>setReaderNameFilter&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscPlugin&lt;/td>
&lt;td>&lt;code>setProtocolIdentificationRule&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setSharingMode&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setContactless&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setIsoProtocol&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setDisconnectionMode&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="keyple-distributed">Keyple Distributed&lt;/h4>
&lt;p>The use of Keyple in a remote context has been extensively reviewed and its description is beyond the scope of this guide. Please refer to the
&lt;a href="./docs/developer-guide/distributed-application/">distributed application&lt;/a> section.&lt;/p>
&lt;hr>
&lt;h2 id="upgrade-from-081-to-090">Upgrade from 0.8.1 to 0.9.0&lt;/h2>
&lt;h3 id="whats-changed-1">What&amp;rsquo;s changed?&lt;/h3>
&lt;p>From a user API point of view, the changes relate to the following topics:
From a user API point of view, the changes relate to the following topics:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="#plugin-registration-in-the-seproxyservice">plugin registration in the SeProxyService&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#preparation-of-selection-cases">preparation of selection cases&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#retrieving-selection-results">retrieving selection results&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#definition-of-the-security-settings-of-the-transaction">definition of the security settings of the transaction&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#creation-of-the-potransaction-object">creation of the PoTransaction object&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#transaction-commands-preparation">transaction commands preparation&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#transaction-commands-processing">transaction commands processing&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#retrieving-data-read-from-pos">retrieving data read from POs&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#error-handling">error handling&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="plugin-registration-in-the-seproxyservice">Plugin registration in the SeProxyService&lt;/h3>
&lt;p>The &lt;code>registerPlugin&lt;/code> method of the &lt;code>SeProxyService&lt;/code> class now returns the reference of the registered plugin.&lt;/p>
&lt;p>This makes it possible, for example, to perform a reader setup in an application such as this one:&lt;/p>
&lt;pre>&lt;code class="language-java"> // Create a PcscPlugin and register it into the SeProxyService
ReaderPlugin pcscPlugin = seProxyService.registerPlugin(new PcscPluginFactory());`
// Get the PO reader from the plugin
SeReader poReader = pcscPlugin.getReader(&amp;quot;ASK LoGO 0&amp;quot;);
&lt;/code>&lt;/pre>
&lt;h3 id="preparation-of-selection-cases">Preparation of selection cases&lt;/h3>
&lt;p>The &lt;code>AidSelector&lt;/code>, &lt;code>Selector&lt;/code> and &lt;code>PoSelector&lt;/code> classes now follow the Fluent Builder pattern for better handling of optional parameters.&lt;/p>
&lt;p>The construction of an &lt;code>AidSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector appAidSelector = AidSelector.builder()
.aidToSelect(AID)
.fileControlInformation(AidSelector.FileControlInformation.FCI)
.fileOccurrence(AidSelector.FileOccurrence.FIRST)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>fileControlInformation&lt;/code> and &lt;code>fileOccurrence&lt;/code> fields are optional (shown here with their default values), so a simple version can be :&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector aidSelector = AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build();
&lt;/code>&lt;/pre>
&lt;p>The construction of a &lt;code>SeSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PoSelector&lt;/code> adds the possibility to specify that an invalidated PO should be processed&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.invalidatedPo(InvalidatedPo.ACCEPT)
.build();
&lt;/code>&lt;/pre>
&lt;p>The management of PO commands to be performed after the selection step (when it has been successful) is handled by the methods of the &lt;code>PoSelectionRequest&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>preparing to read files has been simplified and is done using the unique following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareReadRecordFile(byte sfi, int recordNumber)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>preparing to select files is done using the following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareSelectFile(byte[] lid)
public void prepareSelectFile(short lid)
&lt;/code>&lt;/pre>
&lt;p>Note that from now the &amp;ldquo;prepare&amp;rdquo; methods no longer return indexes, the data will be placed in the CalypsoPo object.&lt;/p>
&lt;h3 id="retrieving-selection-results">Retrieving selection results&lt;/h3>
&lt;p>The &lt;code>MatchingSelection&lt;/code> class no longer exists.
In the class &lt;code>SelectionsResult&lt;/code> (see &lt;code>processDefaultSelection/processExplicitSelection&lt;/code>):&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>getActiveSelection&lt;/code> is replaced by &lt;code>getActiveMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelection&lt;/code> is replaced by &lt;code>getMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (may be null if the index provided does not correspond to a successful selection case)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelections&lt;/code> now returns a Map containing a list of associated &lt;code>AbstractMatchingSe&lt;/code> with the selection index that produced it (&lt;code>Map&amp;lt;Integer, AbstractMatchingSe&amp;gt;&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>hasSelectionMatched&lt;/code> method indicates whether the selection index provided corresponds to a successful selection case&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>getActiveSelectionIndex&lt;/code> method returns the index of the active selection (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="definition-of-the-security-settings-of-the-transaction">Definition of the security settings of the transaction&lt;/h3>
&lt;p>These parameters are defined via the &lt;code>PoSecuritySettings&lt;/code> class, whose construction now follows the Fluent Builder pattern.&lt;/p>
&lt;p>All parameters are optional except the &lt;code>SamResource&lt;/code>.&lt;/p>
&lt;p>Here is an example of a complete &lt;code>PoSecuritySettings&lt;/code> build:&lt;/p>
&lt;pre>&lt;code class="language-java">poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.sessionDefaultKif(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KIF_PERSO)
.sessionDefaultKif(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KIF_LOAD)
.sessionDefaultKif(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KIF_DEBIT)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KEY_RECORD_NUMBER_PERSO)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KEY_RECORD_NUMBER_LOAD)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KEY_RECORD_NUMBER_DEBIT)
.sessionModificationMode(ModificationMode.ATOMIC)
.ratificationMode(RatificationMode.CLOSE_RATIFIED)
.sessionAuthorizedKvcList(authKvcs)
.build();
&lt;/code>&lt;/pre>
&lt;h3 id="creation-of-the-potransaction-object">Creation of the PoTransaction object&lt;/h3>
&lt;p>Since PoSecuritySettings now integrates SamResource, the construction of PoTransaction has evolved slightly.&lt;/p>
&lt;p>Here is an example:&lt;/p>
&lt;pre>&lt;code class="language-java">PoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo), poSecuritySettings);
&lt;/code>&lt;/pre>
&lt;h3 id="transaction-commands-preparation">Transaction commands preparation&lt;/h3>
&lt;p>Just as with the &amp;ldquo;prepare&amp;rdquo; commands used for selection, the &amp;ldquo;prepare&amp;rdquo; commands used for transactions no longer return indexes.&lt;/p>
&lt;p>The available commands in version 0.9 are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final void prepareSelectFile(SelectFileControl control)
public final void prepareSelectFile(short lid)
public final void prepareSelectFile(byte[] lid)
public final void prepareReadRecordFile(byte sfi, int recordNumber)
public final void prepareReadRecordFile(byte sfi, int firstRecordNumber, int numberOfRecords, int recordSize))
public final void prepareReadCounterFile(byte sfi, int countersNumber)
public final void prepareUpdateRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareWriteRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareAppendRecord(byte sfi, byte[] recordData)
public final void prepareIncreaseCounter(byte sfi, int counterNumber, int incValue)
public final void prepareDecreaseCounter(byte sfi, int counterNumber, int decValue)
&lt;/code>&lt;/pre>
&lt;h3 id="transaction-commands-processing">Transaction commands processing&lt;/h3>
&lt;p>The &amp;ldquo;process&amp;rdquo; commands have also been revised and simplified.&lt;/p>
&lt;p>They all return &lt;code>void&lt;/code>.&lt;/p>
&lt;p>In case of failure a exception is raised (see below).&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processOpening(PoTransaction.SessionSetting.AccessLevel accessLevel)
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>ModificationMode&lt;/code> is no longer required since it is integrated in the &lt;code>PoSecuritySettings&lt;/code>.&lt;/p>
&lt;p>Parameters previously used to specify that a file is read at login are removed.&lt;/p>
&lt;p>Instead, the first prepareReadFile command will be automatically taken into account.&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processPoCommands()
public final void processPoCommandsInSession()
public final void processCancel(ChannelControl channelControl)
public final void processClosing(ChannelControl channelControl)
&lt;/code>&lt;/pre>
&lt;h3 id="retrieving-data-read-from-pos">Retrieving data read from POs&lt;/h3>
&lt;p>This is a major evolution of the Keyple API. Previously, data read from Calyspo POs were retrieved by applications using &amp;ldquo;parser&amp;rdquo; methods.&lt;/p>
&lt;p>With Keyple API 0.9, Calypso PO data is made available in the CalypsoPo object obtained during selection and enriched all along the operations performed with PoTransaction.&lt;/p>
&lt;p>The public getter methods of CalypsoPo are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final String getDfName()
public final byte[] getDfNameBytes()
public final String getApplicationSerialNumber()
public final byte[] getApplicationSerialNumberBytes()
public final String getAtr()
public final String getStartupInfo()
public final PoRevision getRevision()
public final byte getSessionModification()
public final byte getApplicationType()
public final byte getApplicationSubtype()
public final byte getPlatform()
public final byte getSoftwareIssuer()
public final byte getSoftwareVersion()
public final byte getSoftwareRevision()
public final boolean isDeselectRatificationSupported()
public final boolean isConfidentialSessionModeSupported()
public final boolean isPublicAuthenticationSupported()
public final boolean isPinFeatureAvailable()
public final boolean isSvFeatureAvailable()
public final boolean isDfInvalidated()
public final boolean isDfRatified()
public final DirectoryHeader getDirectoryHeader()
public final ElementaryFile getFileBySfi(byte sfi)
public final ElementaryFile getFileByLid(short lid)
public final Map&amp;lt;Byte, ElementaryFile&amp;gt; getAllFiles()
&lt;/code>&lt;/pre>
&lt;p>Four new classes &lt;code>DirectoryHeader&lt;/code>, &lt;code>ElementaryFile&lt;/code>, &lt;code>FileHeader&lt;/code> and &lt;code>FileData&lt;/code> have been added.&lt;/p>
&lt;h5 id="directoryheader">DirectoryHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public byte getDfStatus()
public byte getKif(AccessLevel level)
public byte getKvc(AccessLevel level)
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="elementaryfile">ElementaryFile&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte getSfi()
public FileHeader getHeader()
public FileData getData()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="fileheader">FileHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public int getRecordsNumber()
public int getRecordSize()
public FileType getType()
public byte getDfStatus()
public boolean isShared()
public Short getSharedReference()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="filedata">FileData&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte[] getContent()
public byte[] getContent(int numRecord)
public byte[] getContent(int numRecord, int dataOffset, int dataLength)
public SortedMap&amp;lt;Integer, byte[]&amp;gt; getAllRecordsContent()
public int getContentAsCounterValue(int numCounter)
public SortedMap&amp;lt;Integer, Integer&amp;gt; getAllCountersValue()
public String toString()
&lt;/code>&lt;/pre>
&lt;p>So, for example to extract the contents of contract files present in the PO, the code might look like this:&lt;/p>
&lt;pre>&lt;code class="language-java">[...]
/* Read all 4 contracts command, record size set to 29 */
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Contracts,
CalypsoClassicInfo.RECORD_NUMBER_1, 4, 29);
/* proceed with the sending of commands, don't close the channel */
poTransaction.processPoCommandsInSession();
ElementaryFile efContracts = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_Contracts);
SortedMap&amp;lt;Integer, byte[]&amp;gt; records = efContracts.getData().getAllRecordsContent();
for (Map.Entry&amp;lt;Integer, byte[]&amp;gt; entry : records.entrySet()) {
logger.info(&amp;quot;Contract #{}: {}&amp;quot;, entry.getKey(),
ByteArrayUtil.toHex(entry.getValue()));
}
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="error-handling">Error handling&lt;/h2>
&lt;p>Since version 0.9, all Keyple exceptions are of the RuntimeException type.&lt;/p>
&lt;p>Catching exceptions is therefore now optional.&lt;/p>
&lt;p>However, it is possible to selectively catch certain exceptions in order to deal with particular cases.&lt;/p>
&lt;p>The new hierarchy of Keyple exceptions is shown
&lt;a href="https://keyple.atlassian.net/projects/KEYP/issues/KEYP-154?filter=allissues&amp;amp;orderby=priority%20DESC&amp;amp;keyword=exceptions" target="_blank" rel="noopener">here&lt;/a>&lt;/p></description></item><item><title>Java API reference</title><link>https://keyple.org/docs/api-reference/java-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/api-reference/java-api/</guid><description>&lt;hr>
&lt;p>The JavaDoc for the Keyple project is available online. The documentation is split into the following parts:&lt;/p>
&lt;div>
&lt;select id="version_selection" style="float: right;" onchange="selectVersion()">
&lt;option>1.0.0&lt;/option>
&lt;option>0.9.0&lt;/option>
&lt;option>0.8.1&lt;/option>
&lt;/select>
&lt;h3>Modules&lt;/h3>
&lt;/div>
&lt;ul id="module_list">&lt;/ul>
&lt;script src="select-api-version.js">&lt;/script></description></item><item><title>C++ API reference</title><link>https://keyple.org/docs/api-reference/cpp-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/api-reference/cpp-api/</guid><description>&lt;hr>
&lt;p>The Doxygen document for the Keyple project is available online. The documentation is split into the following parts:&lt;/p>
&lt;div>
&lt;select id="version_selection" style="float: right;" onchange="selectVersion()">
&lt;option>0.9.0&lt;/option>
&lt;/select>
&lt;h3>Modules&lt;/h3>
&lt;/div>
&lt;ul id="module_list">&lt;/ul>
&lt;script src="select-api-version.js">&lt;/script></description></item><item><title>Release 0.9.0 C++ on the field</title><link>https://keyple.org/post/release-0-9-0-cpp/</link><pubDate>Tue, 26 Jan 2021 14:57:56 +0200</pubDate><guid>https://keyple.org/post/release-0-9-0-cpp/</guid><description>&lt;p>We are pleased to announce that the version 0.9.0 of the C++ implementation of Eclipse Keyple™ was released January 26th, 2021.&lt;/p>
&lt;p>This 0.9.0 C++ Keyple implementation follows the API design for the 0.9.0 Java Keyple implementation.&lt;/p>
&lt;ul>
&lt;li>New simplifications are introduced on the Calypso API. Keyple 0.8 had a high-level API for building map commands, but the map response data needed to be parsed with a low-level API. The Calypso 0.9.0 API provided a high-level API for retrieving map response data from a map image for which the file structure could be browsed.&lt;/li>
&lt;li>The Core 0.9.0 has also made the reader observation function more reliable in order to be notified in case of card withdrawal.&lt;/li>
&lt;/ul>
&lt;p>C++ API reference
&lt;a href="https://keyple.org/docs/api-reference/cpp-api/">https://keyple.org/docs/api-reference/cpp-api/&lt;/a>&lt;/p>
&lt;p>Build your first C++ application
&lt;a href="https://keyple.org/docs/build-your-first-app/cpp-app/">https://keyple.org/docs/build-your-first-app/cpp-app/&lt;/a>&lt;/p>
&lt;p>The source of Keyple C++ is available on
&lt;a href="https://github.com/eclipse/keyple-cpp" target="_blank" rel="noopener">https://github.com/eclipse/keyple-cpp&lt;/a>.
Some dedicated support is provided on keyple.org:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/docs/api-reference/cpp-api/" target="_blank" rel="noopener">the documentation of the C++ API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/docs/build-your-first-app/cpp-app/" target="_blank" rel="noopener">a guide to Build a first C++ application&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Release 1.0.0 of Eclipse Keyple Java</title><link>https://keyple.org/post/release-1-0-0-java/</link><pubDate>Thu, 17 Dec 2020 17:24:41 +0100</pubDate><guid>https://keyple.org/post/release-1-0-0-java/</guid><description>&lt;p>The
&lt;a href="https://github.com/eclipse/keyple-java/releases/tag/1.0.0" target="_blank" rel="noopener">release 1.0.0 of Eclipse Keyple Java&lt;/a> is available.&lt;/p>
&lt;p>Most of the improvements concerns the Keyple Core:&lt;/p>
&lt;ul>
&lt;li>the new Core extension to manage &amp;ldquo;distributed architecture&amp;rdquo; and operate remote smart card readers,&lt;/li>
&lt;li>some packages &amp;amp; classes renaming to facilitate the understanding,&lt;/li>
&lt;li>the setting of smart card reader has also been simplified.
The NFC &amp;amp; OMAPI Android plugins have been optimized for all Android versions from 4.4.&lt;/li>
&lt;/ul>
&lt;p>A new
&lt;a href="https://keyple.org/" target="_blank" rel="noopener">Keyple website&lt;/a> provides the documentation and guides to handle the Keyple solution.&lt;/p></description></item><item><title>Webinar Eclipse Keyple™ for Developers, Thursday, October 15, 2020</title><link>https://keyple.org/post/webinar-eclipse-keyple-developers-oct15-2020/</link><pubDate>Fri, 25 Sep 2020 14:57:23 +0200</pubDate><guid>https://keyple.org/post/webinar-eclipse-keyple-developers-oct15-2020/</guid><description>&lt;h2 id="are-you-a-mobility-aggregator-a-system-integrator-an-event-manager-a-developer-or-a-multi-mobility-startup">Are you a mobility aggregator, a system integrator, an event manager, a developer or a multi-mobility startup?&lt;/h2>
&lt;p>Do you want to have easy access to a highly secure and interoperable standard, Calypso®, to reduce your costs and
accelerate your developments, to move from a black box to an open and modular solution with access to multiple
hardware platforms, to enable partnerships with multimodal transport, building facilities including parking,
tourism and events… or just discover what Eclipse Keyple™ is and how it works?&lt;/p>
&lt;p>On October 15, 2020, we organized a webinar Eclipse Keyple™ for Developers!&lt;/p>
&lt;p>See the whole event on video:
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/v6EKq6ZwJUc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;p>
&lt;i class="fas fa-file-pdf pr-1 fa-fw">&lt;/i> Discover the
&lt;a href="https://drive.google.com/file/d/1HdrThZD70bFIun8jFLYKfgozyCvX9SQg/view" target="_blank" rel="noopener">presentation&lt;/a>.&lt;/p></description></item><item><title>Release 0.9.0 Java on the field</title><link>https://keyple.org/post/release-0-9-0-java/</link><pubDate>Fri, 18 Sep 2020 14:57:56 +0200</pubDate><guid>https://keyple.org/post/release-0-9-0-java/</guid><description>&lt;p>We are pleased to announce that the version 0.9.0 of the Java implementation of Eclipse Keyple™ was released September 11th, 2020.&lt;/p>
&lt;p>The main improvement on the Calypso® extension is the addition of high-level API to manage the portable object response.
Now the APDU responses of the Calypso® cards are automatically parsed to fill card images.
Currently all the components of Eclipse Keyple™ Java are following the same versioning.&lt;/p>
&lt;p>From the version 1.0.0 scheduled for November 2020, the components will be defined with their own versioning in order to stabilize as possible the different APIs.&lt;/p>
&lt;p>
&lt;a href="https://keyple.org/docs/">Documentation&lt;/a> currently available:&lt;/p>
&lt;ul>
&lt;li>the project plan,&lt;/li>
&lt;li>the guides of the different public API,&lt;/li>
&lt;li>and a guide to manage the migration between the release 0.8.1 &amp;amp; 0.9.0.&lt;/li>
&lt;/ul></description></item><item><title>First Meet Up Eclipse Keyple™</title><link>https://keyple.org/post/first-meetup-eclipse-keyple/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://keyple.org/post/first-meetup-eclipse-keyple/</guid><description>&lt;p>On October 17, 2019, we organized the first Meet Up Eclipse Keyple™!
Great moments of exchanges around the first Open Source SDK for Ticketing with Benoît Boute,
Nicolas Generali, Pierre Terree, Hicham Elbizy, Benoist Laforge, Gaël Blondelle, Camille Moulin,
Philippe Vappereau, Valentina Zajackowski. Many thanks to them for their interventions and also
to Manon Chaix, Jean-Pierre Fortune, Olivier Delcroix, Ludovic Teixeira Costa and all the participants!&lt;/p>
&lt;p>See the whole event on video:
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/4j5rkvdXU7g" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;p>
&lt;i class="fas fa-file-pdf pr-1 fa-fw">&lt;/i> Discover the
&lt;a href="https://drive.google.com/file/d/1GAAhW-mv-E6kxqVySv8-KSjMJ15tZBkM/view" target="_blank" rel="noopener">presentation&lt;/a>.&lt;/p>
&lt;p>
&lt;i class="fas fa-images pr-1 fa-fw">&lt;/i> Discover the
&lt;a href="https://drive.google.com/drive/folders/1StRgiAxKrn0mHsP9WwIQ_bopQW-eGVb8" target="_blank" rel="noopener">photos&lt;/a>.&lt;/p></description></item></channel></rss>