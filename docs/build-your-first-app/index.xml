<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Build your first app | Eclipse Keyple</title><link>https://keyple.org/docs/build-your-first-app/</link><atom:link href="https://keyple.org/docs/build-your-first-app/index.xml" rel="self" type="application/rss+xml"/><description>Build your first app</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Â© Eclipse Foundation, Inc. All Rights Reserved.</copyright><image><url>https://keyple.org/images/logo_hu673a59176cd62c570f44ed2728665b48_42188_300x300_fit_lanczos_2.png</url><title>Build your first app</title><link>https://keyple.org/docs/build-your-first-app/</link></image><item><title>Build your first Java application</title><link>https://keyple.org/docs/build-your-first-app/java-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/java-app/</guid><description>&lt;hr>
&lt;p>This quick start describes how to create a ready-to-execute Java
command-line application that runs a simple transaction based on
a Calypso portable object (PO) involving two smart card readers.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The demonstration application created for this quick start requires a
Calypo PO (contactless smart card, mobile phone with contactless
communication) and a Calypo Secure Access Module (SAM).
&lt;/div>
&lt;/div>
&lt;p>We will use three main components of Keyple:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/">Keyple Core&lt;/a>
which is the base component to which all the others refer,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-java/plugins/pcsc/">Keyple PC/SC plugin&lt;/a>
to provide the ability to manage PC/SC readers,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-java/extensions/calypso/">Keyple Calypso extension&lt;/a>
to handle the commands sent to the Calypso PO and the Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>In this guide
&lt;a href="https://gradle.org/" target="_blank" rel="noopener">Gradle&lt;/a> is used as build automation
tool, but it is easy to transpose these explanations to another tool
such as Maven for example.&lt;/p>
&lt;p>The example can run on any machine: Linux, Windows and macOS. If not
installed in your machine, you will need to download :&lt;/p>
&lt;ul>
&lt;li>Java 1.6 or newer&lt;/li>
&lt;li>
&lt;a href="https://gradle.org/install/" target="_blank" rel="noopener">Gradle (any version)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>We recommend that you use a Java IDE like
&lt;a href="https://www.eclipse.org/ide/" target="_blank" rel="noopener">Eclipse&lt;/a> or
&lt;a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">Intellij IDEA&lt;/a> to create your new
Gradle project.&lt;/p>
&lt;hr>
&lt;h2 id="create-a-gradle-based-empty-project">Create a Gradle-based empty project&lt;/h2>
&lt;p>Create a new Java project and add the following statements to your
&lt;code>build.gradle&lt;/code> file to import the Keyple components into your
project:&lt;/p>
&lt;pre>&lt;code class="language-gradle">apply plugin: 'java'
repositories {
mavenCentral()
}
dependencies {
//Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core
implementation 'org.eclipse.keyple:keyple-java-core:1.0.0'
//Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso
implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0'
//Import PC/SC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc
implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'
//Import logger lib
implementation 'org.slf4j:slf4j-api:1.7.25'
implementation &amp;quot;org.slf4j:slf4j-simple:1.7.25&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>If necessary, also create the usual tree in which the Java code of this
guide will be placed, namely the folders: &lt;code>\src\main\java&lt;/code>&lt;/p>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;p>Now let&amp;rsquo;s see step by step how to create in one single class the
elements that allow a certified reading of data through a Calypso secure
session.&lt;/p>
&lt;p>In a real ticketing application, the organization of the code would
probably be different, but the point here is to show how Keyple makes it
possible to perform very simply operations that normally require a
quantity of code and knowledge that far exceeds what is implemented
here.&lt;/p>
&lt;p>You can either progressively copy each of the small portions of code
that follow or copy the whole class at the bottom of this page.&lt;/p>
&lt;h3 id="create-the-class-skeleton">Create the class skeleton&lt;/h3>
&lt;p>Copy the source code below in a new Java Class named
DemoPoAuthentication.&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.calypso.command.sam.SamRevision;
import org.eclipse.keyple.calypso.transaction.*;
import org.eclipse.keyple.core.card.selection.*;
import org.eclipse.keyple.core.service.*;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.plugin.pcsc.*;
public class DemoPoAuthentication {
public static void main(String[] args) {
// ...
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="configure-the-pcsc-plugin-and-the-readers">Configure the PC/SC plugin and the readers&lt;/h3>
&lt;p>The first step to use Keyple is to initialize the plugin and smart card readers.&lt;/p>
&lt;p>In this snippet the PC/SC plugin is registered to the SmartCardService.&lt;/p>
&lt;p>Two readers needs to be connected to the local machine. Replace
&amp;ldquo;PO_READER_NAME&amp;rdquo; and &amp;ldquo;SAM_READER_NAME&amp;rdquo; with the name of the USB readers.&lt;/p>
&lt;p>If you don&amp;rsquo;t know the names of the readers, read how to find them in the
&lt;a href="#faq">FAQ&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-java">//...
// Get the instance of the SmartCardService : main service of Keyple SDK
SmartCardService smartCardService = SmartCardService.getInstance();
// Register the PcscPlugin within the SmartCardService to use PC/SC readers
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory());
// Get the PO reader
PcscReader poReader = (PcscReader) plugin.getReader(&amp;quot;PO_READER_NAME&amp;quot;);
// Configure the PO reader parameters
poReader.setContactless(true);
// Get the SAM reader
PcscReader samReader = (PcscReader) plugin.getReader(&amp;quot;SAM_READER_NAME&amp;quot;);
// ...
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-sam">Select the Calypso SAM&lt;/h3>
&lt;p>Before executing a transaction each smart card should be selected. The
next step is the selection of the Calypso SAM resulting in a
CalypsoSam object.&lt;/p>
&lt;p>It is then combined with the SAM reader to form the SAM resource needed
later within the transaction service.&lt;/p>
&lt;pre>&lt;code class="language-java">//...
// Prepare a SamSelector that identifies the Calypso SAM
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build();
// Perform the SAM selection
CardSelectionService samSelection = new CardSelectionService();
samSelection.prepareSelection(new SamSelection(samSelector));
if (!samReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader.getName());
}
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
// Associate the calypsoSam and the samReader to create a samResource
CardResource&amp;lt;CalypsoSam&amp;gt; samResource = new CardResource&amp;lt;CalypsoSam&amp;gt;(samReader, calypsoSam);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-po">Select the Calypso PO&lt;/h3>
&lt;p>1st PO exchange:&lt;/p>
&lt;p>The Calypso PO selection is made using the portable object application&amp;rsquo;s AID
and results in a CalypsoPo object that will contain all the information extracted
from the Calypso PO all along the transaction.&lt;/p>
&lt;pre>&lt;code class="language-java">// Prepare a Calypso PO selection
final String AID = &amp;quot;315449432E49434131&amp;quot;; /* AID: Keyple test kit profile 1, Application 2 */
CardSelectionService cardSelectionService = new CardSelectionService();
// Setting up a selection based on the AID of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication protocol
PoSelection poSelection = new PoSelection(
PoSelector.builder()
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier
.invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not
.build());
// Add the selection case to the current selection
// (we could have added other cases)
cardSelectionService.prepareSelection(poSelection);
if (!poReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;The selection of the PO has failed.&amp;quot;);
}
// Perform the PO selection and get a CalypoPo container in return
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard();
//...
&lt;/code>&lt;/pre>
&lt;h3 id="open-the-calypso-secure-session">Open the Calypso secure session&lt;/h3>
&lt;p>2nd PO exchange :&lt;/p>
&lt;p>The secure session opening operated by the PoTransaction service is
combined with the reading of the environment file (SFI=07h).&lt;/p>
&lt;p>The mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.&lt;/p>
&lt;pre>&lt;code class="language-java">// Prepare the security settings used during the Calypso transaction
PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build();
// Create a PoTransaction service to manage the Calypso transaction
PoTransaction poTransaction = new PoTransaction(
new CardResource&amp;lt;CalypsoPo(poReader, calypsoPo),
poSecuritySettings);
final byte RECORD_NUMBER_1 = 1;
final byte SFI_Environment = (byte) 0x07;
// Schedule the reading of the Environment file after the secure session is opened
// (we could have added other commands)
poTransaction.prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Perform the session opening with the debit key
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the Environment data from the card image CalypsoPo
ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment);
String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent());
System.out.println(&amp;quot;Environment file content: &amp;quot;+ environmentLog);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="close-the-calypso-secure-session">Close the Calypso secure session&lt;/h3>
&lt;p>3rd PO exchange:&lt;/p>
&lt;p>Simply close the Calypso secure session&lt;/p>
&lt;p>The mutual authentication is finalized, it includes the authentication
of the data in the read file.&lt;/p>
&lt;p>Note: any technical, crytographic or content-related incident in the Calypso PO
would be signalled by an exception and would interrupt the thread of
execution.&lt;/p>
&lt;pre>&lt;code class="language-java">// Schedule the closure of the channel with the PO after the closing of the secure session
poTransaction.prepareReleasePoChannel();
// Perform the closing of the Calypso Secure Session
poTransaction.processClosing();
System.out.println(&amp;quot;The data read in session have been certified by the successful closing.&amp;quot;);
//...
&lt;/code>&lt;/pre>
&lt;h3 id="unregister-the-plugin">Unregister the plugin&lt;/h3>
&lt;p>Finally unregister the plugin before shutting down the application&lt;/p>
&lt;pre>&lt;code class="language-java">// Shutdown the application
smartCardService.unregisterPlugin(plugin.getName());
System.exit(0);
&lt;/code>&lt;/pre>
&lt;p>Find the complete code source
&lt;a href="#full-code">below&lt;/a>.&lt;/p>
&lt;hr>
&lt;h2 id="run">Run&lt;/h2>
&lt;ol>
&lt;li>Connect two USB PC/SC Readers.&lt;/li>
&lt;li>Insert the Calypso SAM in the SAM reader.&lt;/li>
&lt;li>Insert the Calypso PO in the PO reader.&lt;/li>
&lt;li>Run the application.&lt;/li>
&lt;/ol>
&lt;div class="alert alert-note">
&lt;div>
All project dependencies, including Keyple
components, are downloaded during the first run, which can take some
time.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How do I find out the names of the readers?&lt;/strong>&lt;/p>
&lt;p>To find out the names of the readers connected to your computer, we will
use Keyple with the following class which prints in the console the
number and names of the readers present:&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.core.service.Plugin;
import org.eclipse.keyple.core.service.SmartCardService;
import org.eclipse.keyple.plugin.pcsc.PcscPluginFactory;
import java.util.Set;
public class ReaderDiscovery {
public static void main(String[] args) {
SmartCardService smartCardService = SmartCardService.getInstance();
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory());
Set&amp;lt;String&amp;gt; names = plugin.getReaderNames();
System.out.println(names.size() + &amp;quot; readers found.&amp;quot;);
for (String name : names) {
System.out.println('&amp;quot;' + name + '&amp;quot;');
}
}
}
&lt;/code>&lt;/pre>
&lt;p>The console output should look something like:&lt;/p>
&lt;pre>&lt;code>2 readers found.
&amp;quot;ASK LoGO 0&amp;quot;
&amp;quot;Identive CLOUD 2700 R Smart Card Reader 0&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Identify which reader will be the PO (contactless) reader and the SAM
(contact) reader and replace &lt;code>PO_READER_NAME&lt;/code> and
&lt;code>SAM_READER_NAME&lt;/code> with their values.&lt;/p>
&lt;p>&lt;strong>How to activate the Keyple&amp;rsquo;s logs?&lt;/strong>&lt;/p>
&lt;p>As soon as the &lt;code>slf4j&lt;/code> library is imported into the project, Keyple
modules are able to produce logs.&lt;/p>
&lt;p>However, to take full advantage of the possibilities of this library, it
is necessary to create a &lt;code>simplelogger.properties&lt;/code> file in the
&lt;code>/src/main/resources&lt;/code> folder of the project.&lt;/p>
&lt;p>The self-documented content of this file may be:&lt;/p>
&lt;pre>&lt;code># SLF4J's SimpleLogger configuration file
# Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err.
# Default logging detail level for all instances of SimpleLogger.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, defaults to &amp;quot;info&amp;quot;.
org.slf4j.simpleLogger.defaultLogLevel=debug
# Logging detail level for a SimpleLogger instance named &amp;quot;xxxxx&amp;quot;.
# Must be one of (&amp;quot;trace&amp;quot;, &amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warn&amp;quot;, or &amp;quot;error&amp;quot;).
# If not specified, the default logging detail level is used.
#org.slf4j.simpleLogger.log.xxxxx=
# Set to true if you want the current date and time to be included in output messages.
# Default is false, and will output the number of milliseconds elapsed since startup.
org.slf4j.simpleLogger.showDateTime=true
# The date and time format to be used in the output messages.
# The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat.
# If the format is not specified or is invalid, the default format is used.
# The default format is yyyy-MM-dd HH:mm:ss:SSS Z.
org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS]
# Set to true if you want to output the current thread name.
# Defaults to true.
org.slf4j.simpleLogger.showThreadName=true
# Set to true if you want the Logger instance name to be included in output messages.
# Defaults to true.
org.slf4j.simpleLogger.showLogName=false
# Set to true if you want the last component of the name to be included in output messages.
# Defaults to false.
org.slf4j.simpleLogger.showShortLogName=true
org.slf4j.simpleLogger.levelInBrackets=true
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Why do I see a warning in the console about illegal reflexive access
when running the application?&lt;/strong>&lt;/p>
&lt;p>A known problem on Windows 8/10 platforms causes the smartcard service
to stop when the last reader is removed. This problem prevents a
&amp;ldquo;classic&amp;rdquo; monitoring of connections and disconnections of readers with
the smartcard.io library (Java PC/SC). So for the moment we are using a
workaround based on reflexivity to overcome this problem and allow a
correct monitoring of the readers in the PC/SC plugin. This has the
disadvantage of generating a warning message with recent versions of the
JVM. However, we have not found any problems with this implementation of
the PC/SC plugin so far.&lt;/p>
&lt;h4 id="full-code">Full code&lt;/h4>
&lt;p>Here is the complete code of this quick start in one single block.&lt;/p>
&lt;pre>&lt;code class="language-java">import org.eclipse.keyple.calypso.command.sam.SamRevision;
import org.eclipse.keyple.calypso.transaction.*;
import org.eclipse.keyple.core.card.selection.*;
import org.eclipse.keyple.core.service.*;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.plugin.pcsc.*;
public class DemoPoAuthentication {
public static void main(String[] args) {
// Get the instance of the SmartCardService : main service of Keyple SDK
SmartCardService smartCardService = SmartCardService.getInstance();
// Register a PcscPlugin within the SmartCardService to use PC/SC USB Readers
Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, null));
// Get the PO reader
PcscReader poReader = (PcscReader) plugin.getReader(&amp;quot;ASK LoGO 0&amp;quot;);
// Configure the PO reader parameters
poReader.setContactless(true);
// Get a SAM reader
PcscReader samReader = (PcscReader) plugin.getReader(&amp;quot;Identive CLOUD 2700 R Smart Card Reader 0&amp;quot;);
// Prepare a SamSelector that identifies the Calypso SAM
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build();
// Perform the SAM selection
CardSelectionsService samSelection = new CardSelectionsService();
samSelection.prepareSelection(new SamSelection(samSelector));
if (!samReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader.getName());
}
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
// Associate the calypsoSam and the samReader to create a samResource
CardResource&amp;lt;CalypsoSam&amp;gt; samResource = new CardResource&amp;lt;CalypsoSam&amp;gt;(samReader, calypsoSam);
// Prepare a Calypso PO selection
final String AID = &amp;quot;315449432E49434131&amp;quot;; /* AID: Keyple test kit profile 1, Application 2 */
final byte RECORD_NUMBER_1 = 1;
final byte SFI_Environment = (byte) 0x07;
CardSelectionsService cardSelectionService = new CardSelectionsService();
// Setting up a selection based on the AID of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication protocol
PoSelection poSelection = new PoSelection(
PoSelector.builder()
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier
.invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not
.build());
// Add the selection case to the current selection
// (we could have added other cases)
cardSelectionService.prepareSelection(poSelection);
if (!poReader.isCardPresent()) {
throw new IllegalStateException(&amp;quot;The selection of the PO has failed.&amp;quot;);
}
// Perform the PO selection and get a CalypoPo container in return
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard();
// Prepare the security settings used during the Calypso transaction
PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build();
// Create a PoTransaction service to manage the Calypso transaction
PoTransaction poTransaction = new PoTransaction(
new CardResource&amp;lt;CalypsoPo&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
// Schedule the reading of the Environment file after the secure session is opened
// (we could have added other commands)
poTransaction.prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Perform the session opening with the debit key
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the Environment data from the card image CalypsoPo
ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment);
String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent());
System.out.println(&amp;quot;Environment file content: &amp;quot;+ environmentLog);
// Schedule the closure of the channel with the PO after the closing of the secure session
poTransaction.prepareReleasePoChannel();
// Perform the closing of the Calypso Secure Session
poTransaction.processClosing();
System.out.println(&amp;quot;The data read in session have been certified by the successful closing.&amp;quot;);
// Shutdown the application
smartCardService.unregisterPlugin(plugin.getName());
System.exit(0);
}
}
&lt;/code>&lt;/pre></description></item><item><title>Build your first Android application</title><link>https://keyple.org/docs/build-your-first-app/android-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/android-app/</guid><description>&lt;hr>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h3 id="overview">Overview&lt;/h3>
&lt;p>&lt;strong>Since Keyple is supported by the Android operating system, developers can take advantage of this quick and easy way to implement solution to provide SmartCard communication functionalities in their own mobile application.&lt;/strong>&lt;/p>
&lt;p>For example, Keyple could be used to facilitate the development of a ticketing application based on the use of conteners on a SIM card and relying on
&lt;a href="https://developer.android.com/reference/android/se/omapi/package-summary" target="_blank" rel="noopener">Android SE OMAPI&lt;/a>.
Keyple could also be used to develop an application reading SmartCard content through NFC using
&lt;a href="https://developer.android.com/guide/topics/connectivity/nfc/advanced-nfc" target="_blank" rel="noopener">Android NFC&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/android-app/component/Android_App_Overview.png" >
&lt;img src="../../media/android-app/component/Android_App_Overview.png" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>As Keyple request low level reader access, the key features of Keyple SDK relies on components called &lt;strong>Plugins&lt;/strong>. These are the plugins that allow access to the hardware functionality of the terminal by using the native Android SDK or the terminal manufacturer&amp;rsquo;s own custom SDKs.&lt;/p>
&lt;p>This guide will describe how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso SmartCard. As we want to focus on Keyple integration, the Android application architecture will remain the simplest as possible.&lt;/p>
&lt;h3 id="what-to-we-need-for-this-guide">What to we need for this guide?&lt;/h3>
&lt;ul>
&lt;li>Retail Device with NFC powered by android.nfc library (integrated into standard Android SDK).&lt;/li>
&lt;li>Android OS 19+&lt;/li>
&lt;li>A NFC SmartCard with Calypso PO&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="integration">Integration&lt;/h2>
&lt;h3 id="application-setup">Application setup&lt;/h3>
&lt;p>Like for any other Android NFC Application, we need to declare items in the application manifest.&lt;/p>
&lt;pre>&lt;code class="language-xml">&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
...
&amp;lt;uses-permission android:name=&amp;quot;android.permission.NFC&amp;quot; /&amp;gt;
&amp;lt;uses-feature android:name=&amp;quot;android.hardware.nfc&amp;quot; android:required=&amp;quot;true&amp;quot; /&amp;gt;
...
&amp;lt;/manifest&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="sdk-integration">SDK Integration&lt;/h3>
&lt;h4 id="keyple-core">Keyple Core&lt;/h4>
&lt;p>This high-level API is convenient for developers implementing smart card processing application for terminal interfaced
with smart card readers. Access to the readers is provided by the plugins.&lt;/p>
&lt;p>To use Keyple core API (and in fact, anything keyple&amp;rsquo;s related) import the jar within the gradle dependencies of your
Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-core:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Please refer to Architecture/Keyle Core&lt;/p>
&lt;h4 id="keyple-plugins">Keyple Plugins&lt;/h4>
&lt;p>There are many Keyple plugins available, the one to use depends on the device and ticketing tools you are aiming to
use.&lt;/p>
&lt;p>To use the NFC plugin simply import it within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-android-nfc:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;h4 id="keyple-calypso">Keyple Calypso&lt;/h4>
&lt;p>The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Objects.&lt;/p>
&lt;p>Please refer to Architecture/Keyle Calypso&lt;/p>
&lt;p>To use Keyple Calypso User API simply import the jar within the gradle dependencies of your Android application.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation &amp;quot;org.eclipse.keyple:keyple-java-calypso:$keyple_version&amp;quot;
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;h3 id="initializing-the-sdk">Initializing the SDK&lt;/h3>
&lt;h4 id="register-a-plugin">Register a plugin&lt;/h4>
&lt;p>In order to setup Keyple, we need to register at least one plugin. Here we register our NFC plugin. To do so, we use the singleton SmartCardService and the plugin Factory. (See plugin development guide to know more about plugins)&lt;/p>
&lt;pre>&lt;code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
/* register Android NFC Plugin to the SmartCardService */
try {
val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -&amp;gt;}
SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler))
}catch (e: KeypleException){
/* do something with it */
}
}
&lt;/code>&lt;/pre>
&lt;p>Note: Plugins Factory&amp;rsquo;s initialisation could request more steps to execute before passing it to registerPlugin(). It depends on plugins, please check the documentation or usage example of desired plugin.&lt;/p>
&lt;h4 id="unregister-a-plugin">Unregister a plugin&lt;/h4>
&lt;p>Clean resources.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">override fun onDestroy() {
...
/* Unregister Android NFC Plugin to the SmartCardService */
SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME)
reader = null
super.onDestroy()
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-a-specific-reader">Retrieve a specific reader&lt;/h3>
&lt;p>With the plugin registered we can retrieve all instances of the component mapping the SmartCard readers. Here we want to retrieve the NFC reader.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//We keep a reference to the reader for later use
private lateinit var reader: AndroidNfcReader
...
//PLUGIN_NAME and READER_NAME are constants provided by the used Keyple plugin
reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader
&lt;/code>&lt;/pre>
&lt;h3 id="add-observer-to-handle-nfc-events">Add observer to handle NFC events&lt;/h3>
&lt;p>When native NFC is activated on an Android device, the OS dispatches insertion events occurring in the NFC detection field. In our application, we need detect it in order to proceed to exchanges with the SmartCard.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">//To keep it simple we choose to have our MainActivity implementing ObservableReader.ReaderObserver
//interface.
class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
...
reader.addObserver(this)
...
//Belongs to ObservableReader.ReaderObserver
//NFC Reader events will be received here.
//this method is not triggered in UI thread
override fun update(event: ReaderEvent) {
if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){
//We'll select PO when SmartCard is presented in field
//Method handlePo is described below
handlePo()
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="activate-a-protocol">Activate a protocol&lt;/h3>
&lt;p>Before starting to read a NFC tag, you must activate the protocol in which you wish to detect it.
If you do not activate any protocol, no card will be detected by the Keyple library.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
...
// with this protocol settings we activate the nfc for ISO1443_4 protocol
reader.activateProtocol(
ContactlessCardCommonProtocols.ISO_14443_4.name,
AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name)
)
...
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="deactivate-a-protocol">Deactivate a protocol&lt;/h3>
&lt;p>When your are done with your NFC operations, you can deactivate the NFC protocol :&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onDestroy() {
...
//Deactivate nfc for ISO1443_4 protocol
reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
...
super.onDestroy()
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we have an access to our NFC Reader, we can activate Card Detection.&lt;/p>
&lt;h3 id="activate-card-detection">Activate Card detection&lt;/h3>
&lt;p>We will start detection as soon as our application comes in foreground and stop when application go background.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onResume() {
super.onResume()
reader?.let {
//We choose to continue waiting for a new card persentation
it.startCardDetection(ObservableReader.PollingMode.REPEATING)
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="deactivate-card-detection">Deactivate Card detection&lt;/h3>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
override fun onPause() {
reader?.let {
it.stopCardDetection()
}
super.onPause()
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we can detect when a SmartCard is presented in the field, we can proceed to card application selection and data reading.&lt;/p>
&lt;h3 id="handling-a-calypso-po">Handling a Calypso PO&lt;/h3>
&lt;h4 id="calypso-selection-api">Calypso Selection API&lt;/h4>
&lt;p>With Keyple, PO selection and FCI retrieving can be done using only Keyple Core, but Keyple Calypso API provides specific tools to handle Calypso POs and make the process a bit more simple.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">fun handlePo(){
reader?.let {
//check if card is in the NFC field
if(it.isCardPresent){
//Instanciate class handling card selection service
val cardSelectionService = CardSelectionsService()
//We only want to select the PO so we choose to close communication channel once
//selection is done
cardSelectionService.prepareReleaseChannel()
//We build a selection request managing specific characteristics of Calypso POs
val poSelection = PoSelection(
PoSelector
.builder()
//Smarcard standard protocol
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
.aidSelector(
CardSelector.AidSelector.builder()
.aidToSelect(YOUR_AID) //Set the AID of your Calypso PO
//indicates how to carry out the file occurrence in accordance with
//ISO7816-4
.fileOccurrence(CardSelector.AidSelector.FileOccurrence.FIRST)
//indicates which template is expected in accordance with ISO7816-4
.fileControlInformation(
CardSelector.AidSelector.FileControlInformation.FCI)
.build()
).build())
cardSelectionService.prepareSelection(poSelection)
//Proceed to selection using the reader
val selectionResult = cardSelectionService.processExplicitSelections(it)
runOnUiThread {
//We check the selection result and read the FCI
if(selectionResult.hasActiveSelection()){
val matchedSmartCard = selectionResult.activeSmartCard
val fci = matchedSmartCard.fciBytes
Toast.makeText(this, String.format(&amp;quot;Selected, Fci %s&amp;quot;,
ByteArrayUtil.toHex(fci)), Toast.LENGTH_LONG).show()
}else {
Toast.makeText(this,
String.format(&amp;quot;Not selected&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>Now we&amp;rsquo;ve seen we can select our PO we can retrieve more data from it.&lt;/p>
&lt;h4 id="reading-environment-and-usage">Reading Environment and usage&lt;/h4>
&lt;p>In the below example we&amp;rsquo;ll read Environment and Usage data of an Hoplink container.&lt;/p>
&lt;pre>&lt;code class="language-kotlin"> ...
//Data related to Hoplink
val poAid= &amp;quot;A000000291A000000191&amp;quot;
val sfiHoplinkEFEnvironment = 0x14.toByte()
val sfiHoplinkEFUsage = 0x1A.toByte()
...
private fun handlePo(){
...
//Prepare the reading order. We'll read the first record of the EF
//specified by its SFI. This reading will be done within explicit selection.
poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1)
poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1)
...
//Hoplink is a Calypso PO, we can cast the SmartCard
//with CalypsoPo class, representing the PO content.
val calypsoPO = selectionResult.activeSmartCard as CalypsoPo
val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment)
val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage)
Toast.makeText(this, String.format(&amp;quot;Environment %s&amp;quot;,
ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show()
Toast.makeText(this, String.format(&amp;quot;Usage %s&amp;quot;,
ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show()
}
&lt;/code>&lt;/pre>
&lt;h3 id="full-code">Full code&lt;/h3>
&lt;pre>&lt;code class="language-xml">&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
package=&amp;quot;org.eclipse.keyple.android.quickstart&amp;quot;&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.NFC&amp;quot; /&amp;gt;
&amp;lt;uses-feature
android:name=&amp;quot;android.hardware.nfc&amp;quot;
android:required=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;application
android:allowBackup=&amp;quot;true&amp;quot;
android:screenOrientation=&amp;quot;portrait&amp;quot;
android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
android:label=&amp;quot;@string/app_name&amp;quot;
android:roundIcon=&amp;quot;@mipmap/ic_launcher_round&amp;quot;
android:supportsRtl=&amp;quot;true&amp;quot;
android:theme=&amp;quot;@style/AppTheme&amp;quot;&amp;gt;
&amp;lt;activity android:name=&amp;quot;.MainActivity&amp;quot;&amp;gt;
&amp;lt;intent-filter&amp;gt;
&amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;
&amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
&amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-kotlin">class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver {
private var reader: AndroidNfcReader? = null
val poAid= &amp;quot;A000000291A000000191&amp;quot;
val sfiHoplinkEFEnvironment = 0x14.toByte()
val sfiHoplinkEFUsage = 0x1A.toByte()
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
try {
val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -&amp;gt;}
val plugin = SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler))
val reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader
reader.addObserver(this)
reader.activateProtocol(
ContactlessCardCommonProtocols.ISO_14443_4.name,
AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name)
)
this.reader = reader
}catch (e: KeypleException){
Timber.e(e)
Toast.makeText(this, String.format(&amp;quot;Error: %s&amp;quot;, e.message), Toast.LENGTH_LONG).show()
}
}
override fun onResume() {
super.onResume()
reader?.let {
it.startCardDetection(ObservableReader.PollingMode.SINGLESHOT)
Toast.makeText(this, String.format(&amp;quot;Hunt enabled&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
override fun onPause() {
reader?.let {
it.stopCardDetection()
}
super.onPause()
}
override fun onDestroy() {
/* Deactivate nfc for ISO1443_4 protocol */
reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
/* Unregister Android NFC Plugin to the SmartCardService */
SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME)
reader = null
super.onDestroy()
}
override fun update(event: ReaderEvent) {
Timber.d(&amp;quot;Event: %s&amp;quot;, event.eventType.name)
runOnUiThread {
Toast.makeText(this, String.format(&amp;quot;Event: %s&amp;quot;, event.eventType.name),
Toast.LENGTH_SHORT).show()
}
if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){
handlePo()
}
}
//With Calypso API
private fun handlePo(){
reader?.let {
if(it.isCardPresent){
val cardSelectionService = CardSelectionService()
cardSelectionService.prepareReleaseChannel()
val poSelection = PoSelection(
PoSelector
.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name)
.aidSelector(
CardSelector.AidSelector.builder()
.aidToSelect(poAid)
.fileOccurrence(
CardSelector.AidSelector.FileOccurrence.FIRST)
.fileControlInformation(
CardSelector.AidSelector.FileControlInformation.FCI)
.build()
).build())
cardSelectionService.prepareSelection(poSelection)
//Prepare the reading order. We'll read the first record of the EF
//specified by his SFI. This reading will be done with selection.
poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1)
poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1)
//Selection and file reading will be done here
val selectionResult = cardSelectionService.processExplicitSelections(it)
runOnUiThread {
if(selectionResult.hasActiveSelection()){
val matchedSmartCard = selectionResult.activeSmartCard
val fci = matchedSmartCard.fciBytes
Toast.makeText(this, String.format(&amp;quot;Selected, Fci %s&amp;quot;,
ByteArrayUtil.toHex(fci)), Toast.LENGTH_SHORT).show()
//Hoplink is a Calypso PO, we can cast the SmartCard
//with CalypsoPo class, representing the PO content.
val calypsoPO = selectionResult.activeSmartCard as CalypsoPo
val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment)
val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage)
Toast.makeText(this, String.format(&amp;quot;Environment %s&amp;quot;,
ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show()
Toast.makeText(this, String.format(&amp;quot;Usage %s&amp;quot;,
ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show()
}else {
Toast.makeText(this, String.format(&amp;quot;Not selected&amp;quot;), Toast.LENGTH_SHORT).show()
}
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How to fix &amp;ldquo;More than one file was found with OS independent path &amp;lsquo;META-INF/NOTICE.md&amp;rsquo;.&amp;quot;&lt;/strong>&lt;/p>
&lt;p>Add lines below to your :app build.gradle file&lt;/p>
&lt;pre>&lt;code class="language-gradle">android{
packagingOptions {
exclude 'META-INF/NOTICE.md'
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Where can I see more examples&lt;/strong>&lt;/p>
&lt;p>Android native plugins are provided with example applications. Check it to see more use cases:
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example" target="_blank" rel="noopener">Examples&lt;/a>&lt;/p></description></item><item><title>Build your first C++ application</title><link>https://keyple.org/docs/build-your-first-app/cpp-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/build-your-first-app/cpp-app/</guid><description>&lt;hr>
&lt;p>This quick start describes how to create a ready-to-execute C++
command-line application that runs a simple transaction based on
a Calypso portable object (PO) involving two smart card readers.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The demonstration application created for this quick start requires a
Calypo PO (contactless smart card, mobile phone with contactless
communication) and a Calypo Secure Access Module (SAM).
&lt;/div>
&lt;/div>
&lt;p>We will use three main components of Keyple:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/core/">Keyple Core&lt;/a>
which is the base component to which all the others refer,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/plugins/pcsc/">Keyple PC/SC plugin&lt;/a>
to provide the ability to manage PC/SC readers,&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/extensions/calypso/">Keyple Calypso extension&lt;/a>
to handle the commands sent to the Calypso PO and the Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>In this guide CMake is used as build automation tool.&lt;/p>
&lt;p>The example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you
will need to download :&lt;/p>
&lt;ul>
&lt;li>CMake 2.8 or newer
&lt;a href="https://cmake.org/install/" target="_blank" rel="noopener">(download)&lt;/a>&lt;/li>
&lt;li>GCC / CLang / MSVC compiler&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="lets-code">Let&amp;rsquo;s code&lt;/h2>
&lt;p>Now let&amp;rsquo;s see step by step how to create in one single class the
elements that allow a certified reading of data through a Calypso secure
session.&lt;/p>
&lt;p>In a real ticketing application, the organization of the code would
probably be different, but the point here is to show how Keyple makes it
possible to perform very simply operations that normally require a
quantity of code and knowledge that far exceeds what is implemented
here.&lt;/p>
&lt;p>You can either progressively copy each of the small portions of code
that follow or copy the whole class at the bottom of this page.&lt;/p>
&lt;h3 id="create-the-class-skeleton">Create the class skeleton&lt;/h3>
&lt;p>Copy the source code below in a new C++ Class named
DemoPoAuthentication.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Common */
#include &amp;quot;IllegalStateException.h&amp;quot;
#include &amp;quot;LoggerFactory.h&amp;quot;
/* Core */
#include &amp;quot;ByteArrayUtil.h&amp;quot;
#include &amp;quot;SeCommonProtocols.h&amp;quot;
#include &amp;quot;SeSelector.h&amp;quot;
#include &amp;quot;SeSelection.h&amp;quot;
#include &amp;quot;SeProxyService.h&amp;quot;
/* PCSC */
#include &amp;quot;PcscPluginFactory.h&amp;quot;
#include &amp;quot;PcscProtocolSetting.h&amp;quot;
#include &amp;quot;PcscReader.h&amp;quot;
/* Calypso */
#include &amp;quot;CalypsoPo.h&amp;quot;
#include &amp;quot;CalypsoSam.h&amp;quot;
#include &amp;quot;ElementaryFile.h&amp;quot;
#include &amp;quot;PoSecuritySettings.h&amp;quot;
#include &amp;quot;PoSelectionRequest.h&amp;quot;
#include &amp;quot;PoSelector.h&amp;quot;
#include &amp;quot;PoTransaction.h&amp;quot;
#include &amp;quot;SamRevision.h&amp;quot;
#include &amp;quot;SamSelector.h&amp;quot;
#include &amp;quot;SamSelectionRequest.h&amp;quot;
using namespace keyple::calypso::command::po;
using namespace keyple::calypso::command::po::builder;
using namespace keyple::calypso::command::po::parser;
using namespace keyple::calypso::command::sam;
using namespace keyple::calypso::transaction;
using namespace keyple::common;
using namespace keyple::common::exception;
using namespace keyple::core::command::exception;
using namespace keyple::core::selection;
using namespace keyple::core::seproxy;
using namespace keyple::core::seproxy::event;
using namespace keyple::core::seproxy::exception;
using namespace keyple::core::seproxy::message;
using namespace keyple::core::seproxy::protocol;
using namespace keyple::core::util;
using namespace keyple::plugin::pcsc;
int main(int argv, char **args)
{
// ...
return 0;
}
&lt;/code>&lt;/pre>
&lt;h3 id="configure-the-pcsc-plugin-and-the-readers">Configure the PC/SC plugin and the readers&lt;/h3>
&lt;p>The first step to use Keyple is to initialize the plugin and smart card readers.&lt;/p>
&lt;p>In this snippet the PC/SC plugin is registered to the SmartCardService.&lt;/p>
&lt;p>Two readers needs to be connected to the local machine. Replace
&amp;ldquo;PO_READER_NAME&amp;rdquo; and &amp;ldquo;SAM_READER_NAME&amp;rdquo; with the name of the USB readers.&lt;/p>
&lt;p>If you don&amp;rsquo;t know the names of the readers, read how to find them in the
&lt;a href="#faq">FAQ&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* ... */
/* PO Reader name */
const std::string PO_READER_NAME = &amp;quot;XXX&amp;quot;;
/* SAM Reader name */
const std::string SAM_READER_NAME = &amp;quot;XXX&amp;quot;;
/* Get the instance of the SeProxyService (Singleton pattern) */
SeProxyService&amp;amp; seProxyService = SeProxyService::getInstance();
/* Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin */
auto pluginFactory = std::make_shared&amp;lt;PcscPluginFactory&amp;gt;();
std::shared_ptr&amp;lt;ReaderPlugin&amp;gt; readerPlugin = seProxyService.registerPlugin(pluginFactory);
/* Get the PO reader */
std::shared_ptr&amp;lt;SeReader&amp;gt; poReader = readerPlugin-&amp;gt;getReader(PO_READER_NAME);
/* Configure the PO reader parameters */
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1);
/* Get a SAM reader */
std::shared_ptr&amp;lt;SeReader&amp;gt; samReader = readerPlugin-&amp;gt;getReader(SAM_READER_NAME);
/* Configure the SAM reader parameters */
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0);
/*
* PC/SC card access mode:
*
* The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited
* time between two consecutive exchanges granted by Windows.
*
* This point will be addressed in a coming release of the Keyple PcSc reader plugin.
*
* The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the
* selection step that may result in session failures.
*
* See KEYPLE-CORE.PC.md file to learn more about this point.
*
*/
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
/* Set the PO reader protocol flag */
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO14443_4,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]);
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_B_PRIME,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]);
samReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO7816_3,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]);
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-sam">Select the Calypso SAM&lt;/h3>
&lt;p>Before executing a transaction each smart card should be selected. The
next step is the selection of the Calypso SAM resulting in a
CalypsoSam object.&lt;/p>
&lt;p>It is then combined with the SAM reader to form the SAM resource needed
later within the transaction service.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* ... */
/* Prepare the selector to ensure the correct SAM is used */
auto selector = SamSelector::builder()-&amp;gt;samRevision(SamRevision::AUTO).build();
auto samSelector = std::dynamic_pointer_cast&amp;lt;SamSelector&amp;gt;(selector);
/* Make the SAM selection */
SeSelection samSelection;
auto samSelectionRequest = std::make_shared&amp;lt;SamSelectionRequest&amp;gt;(samSelector);
auto abstractSamSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(samSelectionRequest);
samSelection.prepareSelection(abstractSamSelectionRequest);
std::shared_ptr&amp;lt;CalypsoSam&amp;gt; calypsoSam;
if (samReader-&amp;gt;isSePresent()) {
std::shared_ptr&amp;lt;SelectionsResult&amp;gt; selectionsResult = samSelection.processExplicitSelection(samReader);
if (selectionsResult-&amp;gt;hasActiveSelection()) {
calypsoSam = std::dynamic_pointer_cast&amp;lt;CalypsoSam&amp;gt;(selectionsResult-&amp;gt;getActiveMatchingSe());
} else {
throw IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
} else {
throw IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader-&amp;gt;getName());
}
/* Associate the calypsoSam and the samReader to create the samResource */
auto samResource = std::make_shared&amp;lt;SeResource&amp;lt;CalypsoSam&amp;gt;&amp;gt;(samReader, calypsoSam);
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="select-the-calypso-po">Select the Calypso PO&lt;/h3>
&lt;p>1st PO exchange:&lt;/p>
&lt;p>The Calypso PO selection is made using the portable object application&amp;rsquo;s AID
and results in a CalypsoPo object that will contain all the information extracted
from the Calypso PO all along the transaction.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Prepare a Calypso PO selection */
SeSelection seSelection;
/* Keyple test kit profile 1, Application 2 */
const std::string AID = &amp;quot;315449432E49434131&amp;quot;;
/*
* Setting of an AID based selection of a Calypso Revision 3.1 PO
*
* Select the first application matching the selection AID whatever the card communication
* protocol
* Keep the logical channel open after the selection
*
* Calypso selection: configures a PoSelectionRequest with all the desired attributes to
* make the selection and read additional information afterwards
*/
auto aidSelector = SeSelector::AidSelector::builder()-&amp;gt;aidToSelect(AID).build();
auto seSelector = PoSelector::builder()-&amp;gt;aidSelector(aidSelector) /* The application identifier
to indicate if an invalidated PO should be accepted
or not */
.invalidatedPo(PoSelector::InvalidatedPo::REJECT)
.build();
auto poSelector = std::dynamic_pointer_cast&amp;lt;PoSelector&amp;gt;(seSelector);
auto poSelectionRequest = std::make_shared&amp;lt;PoSelectionRequest&amp;gt;(poSelector);
/* Add the selection case to the current selection (we could have added other cases) */
auto abstractPoSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(poSelectionRequest);
seSelection.prepareSelection(abstractPoSelectionRequest);
if (poReader-&amp;gt;isSePresent()) {
try {
// Actual PO communication: operate through a single request the Calypso PO selection
std::shared_ptr&amp;lt;CalypsoPo&amp;gt; calypsoPo =
std::dynamic_pointer_cast&amp;lt;CalypsoPo&amp;gt;(
seSelection.processExplicitSelection(poReader)-&amp;gt;getActiveMatchingSe());
/* ... */
} catch (const Exception&amp;amp; e) {
}
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="open-the-calypso-secure-session">Open the Calypso secure session&lt;/h3>
&lt;p>2nd PO exchange :&lt;/p>
&lt;p>The secure session opening operated by the PoTransaction service is
combined with the reading of the environment file (SFI=07h).&lt;/p>
&lt;p>The mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Prepare the security settings used during the Calypso transaction */
auto poSecuritySettings = std::make_shared&amp;lt;PoSecuritySettings::PoSecuritySettingsBuilder&amp;gt;(samResource)-&amp;gt;build();
/* Create a PoTransaction object to manage the Calypso transaction */
auto poTransaction = std::make_shared&amp;lt;PoTransaction&amp;gt;(
std::make_shared&amp;lt;SeResource&amp;lt;CalypsoPo&amp;gt;&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
const uint8_t RECORD_NUMBER_1 = 1;
const uint8_t SFI_Environment = 0x07;
/* Read the Environment file at the Session Opening (we could have added other commands) */
poTransaction-&amp;gt;prepareReadRecordFile(
SFI_Environment, /* The sfi to select */
RECORD_NUMBER_1);
/* Open Session with the debit key */
poTransaction-&amp;gt;processOpening(PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT);
/* Get the Environment data */
std::shared_ptr&amp;lt;ElementaryFile&amp;gt; efEnvironment = calypsoPo-&amp;gt;getFileBySfi(SFI_Environment);
const std::string environmentLog = ByteArrayUtil::toHex(efEnvironment-&amp;gt;getData()-&amp;gt;getContent());
/* ... */
&lt;/code>&lt;/pre>
&lt;h3 id="close-the-calypso-secure-session">Close the Calypso secure session&lt;/h3>
&lt;p>3rd PO exchange:&lt;/p>
&lt;p>Simply close the Calypso secure session&lt;/p>
&lt;p>The mutual authentication is finalized, it includes the authentication
of the data in the read file.&lt;/p>
&lt;p>Note: any technical, crytographic or content-related incident in the Calypso PO
would be signalled by an exception and would interrupt the thread of
execution.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/* Schedule the closure of the channel with the PO after the closing of the secure session */
poTransaction-&amp;gt;prepareReleasePoChannel();
/* Perform the closing of the Calypso Secure Session */
poTransaction-&amp;gt;processClosing();
/* ... */
&lt;/code>&lt;/pre>
&lt;p>Find the complete code source
&lt;a href="#full-code">below&lt;/a>.&lt;/p>
&lt;hr>
&lt;h2 id="cmake-build">CMake build&lt;/h2>
&lt;p>Create a CMakeLists.txt file as follows:&lt;/p>
&lt;pre>&lt;code class="language-cpp">#
# Copyright (c) 2020 Calypso Networks Association https://www.calypsonet-asso.org/
#
# All rights reserved. This program and the accompanying materials are made available under the
# terms of the Eclipse Public License version 2.0 which accompanies this distribution, and is
# available at https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
#
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
SET(CMAKE_LEGACY_CYGWIN_WIN32 0)
SET(CMAKE_MACOSX_RPATH 1)
SET(CMAKE_CXX_STANDARD 11)
SET(CMAKE_C_COMPILER_WORKS 1)
SET(CMAKE_CXX_COMPILER_WORKS 1)
PROJECT(KeypleDemo)
SET(KEYPLE_SOURCE_DIR &amp;quot;&amp;lt;path_to_keyple_repos&amp;gt;&amp;quot;)
INCLUDE_DIRECTORIES(
${CMAKE_CURRENT_SOURCE_DIR}
# Core
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command/exception
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/selection
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/event
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/exception
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/message
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/protocol
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util
${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util/bertlv
# Plugin
${KEYPLE_SOURCE_DIR}/component/keyple-plugin/pcsc/src/main
# Common
${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main
${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main/exception
# Calypso
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/builder
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/parser
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/sam
${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/transaction
# pcsc (Linux / macOS)
/usr/include/PCSC
)
IF(WIN32)
SET(CMAKE_FIND_LIBRARY_PREFIXES &amp;quot;&amp;quot;)
SET(CMAKE_FIND_LIBRARY_SUFFIXES &amp;quot;.dll&amp;quot;)
SET(CMAKE_BUILD_DIRECTORY &amp;quot;${CMAKE_CURRENT_BINARY_DIR}&amp;quot;)
SET(WINSCARD winscard.lib)
ENDIF(WIN32)
IF(APPLE)
SET(CMAKE_FIND_LIBRARY_PREFIXES &amp;quot;lib&amp;quot;)
SET(CMAKE_FIND_LIBRARY_SUFFIXES &amp;quot;.dylib&amp;quot;)
SET(CMAKE_BUILD_DIRECTORY &amp;quot;${CMAKE_CURRENT_BINARY_DIR}&amp;quot;)
SET(WINSCARD &amp;quot;-framework PCSC&amp;quot;)
ENDIF(APPLE)
IF(UNIX)
SET(SPEC_LIBS pthread pcsclite rt)
ENDIF(UNIX)
IF(APPLE)
SET(SPEC_LIBS pthread)
ENDIF(APPLE)
ADD_EXECUTABLE(
demo_po_authentication
${CMAKE_CURRENT_SOURCE_DIR}/main.cpp
)
TARGET_LINK_DIRECTORIES(demo_po_authentication PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/build)
TARGET_LINK_LIBRARIES(demo_po_authentication keyplecommon keyplepluginpcsc keyplecore keyplecalypso ${SPEC_LIBS})
&lt;/code>&lt;/pre>
&lt;p>Now build the demo code:&lt;/p>
&lt;pre>&lt;code class="language-bash">mkdir build
cd build
cmake ..
make
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="run">Run&lt;/h2>
&lt;ol>
&lt;li>Connect two USB PC/SC Readers.&lt;/li>
&lt;li>Insert the Calypso SAM in the SAM reader.&lt;/li>
&lt;li>Insert the Calypso PO in the PO reader.&lt;/li>
&lt;li>Run the application.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>How do I find out the names of the readers?&lt;/strong>&lt;/p>
&lt;p>If you donât know the reader name, several options:&lt;/p>
&lt;ul>
&lt;li>run the application in debug mode and get the reader name in plugin variable&lt;/li>
&lt;li>run &amp;lsquo;pcsctest&amp;rsquo; (macOS)&lt;/li>
&lt;li>run &amp;lsquo;pcsc_scan&amp;rsquo; (Linux)&lt;/li>
&lt;/ul>
&lt;p>Identify which reader will be the PO (contactless) reader and the SAM
(contact) reader and replace &lt;code>PO_READER_NAME&lt;/code> and
&lt;code>SAM_READER_NAME&lt;/code> with their values.&lt;/p>
&lt;p>&lt;strong>How to activate the Keyple&amp;rsquo;s logs?&lt;/strong>&lt;/p>
&lt;p>Logs are automatically activated but log level can be dynamically changed by a simple call to the
Logger::setLevel() function. Default value is Logger::Level::logDebug.&lt;/p>
&lt;pre>&lt;code class="language-cpp">class DemoPoAuthentication final {};
const std::shared_ptr&amp;lt;Logger&amp;gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication));
logger-&amp;gt;setLoggerLevel(Logger::Level::logError);
&lt;/code>&lt;/pre>
&lt;h4 id="full-code">Full code&lt;/h4>
&lt;p>Here is the complete code of this quick start in one single block.&lt;/p>
&lt;pre>&lt;code class="language-cpp">/**************************************************************************************************
* Copyright (c) 2020 Calypso Networks Association *
* https://www.calypsonet-asso.org/ *
* *
* See the NOTICE file(s) distributed with this work for additional information regarding *
* copyright ownership. *
* *
* This program and the accompanying materials are made available under the terms of the Eclipse *
* Public License 2.0 which is available at http://www.eclipse.org/legal/epl-2.0 *
* *
* SPDX-License-Identifier: EPL-2.0 *
**************************************************************************************************/
/* Common */
#include &amp;quot;IllegalStateException.h&amp;quot;
#include &amp;quot;LoggerFactory.h&amp;quot;
/* Core */
#include &amp;quot;ByteArrayUtil.h&amp;quot;
#include &amp;quot;SeCommonProtocols.h&amp;quot;
#include &amp;quot;SeSelector.h&amp;quot;
#include &amp;quot;SeSelection.h&amp;quot;
#include &amp;quot;SeProxyService.h&amp;quot;
/* PCSC */
#include &amp;quot;PcscPluginFactory.h&amp;quot;
#include &amp;quot;PcscProtocolSetting.h&amp;quot;
#include &amp;quot;PcscReader.h&amp;quot;
/* Calypso */
#include &amp;quot;CalypsoPo.h&amp;quot;
#include &amp;quot;CalypsoSam.h&amp;quot;
#include &amp;quot;ElementaryFile.h&amp;quot;
#include &amp;quot;PoSecuritySettings.h&amp;quot;
#include &amp;quot;PoSelectionRequest.h&amp;quot;
#include &amp;quot;PoSelector.h&amp;quot;
#include &amp;quot;PoTransaction.h&amp;quot;
#include &amp;quot;SamRevision.h&amp;quot;
#include &amp;quot;SamSelector.h&amp;quot;
#include &amp;quot;SamSelectionRequest.h&amp;quot;
using namespace keyple::calypso::command::po;
using namespace keyple::calypso::command::po::builder;
using namespace keyple::calypso::command::po::parser;
using namespace keyple::calypso::command::sam;
using namespace keyple::calypso::transaction;
using namespace keyple::common;
using namespace keyple::common::exception;
using namespace keyple::core::command::exception;
using namespace keyple::core::selection;
using namespace keyple::core::seproxy;
using namespace keyple::core::seproxy::event;
using namespace keyple::core::seproxy::exception;
using namespace keyple::core::seproxy::message;
using namespace keyple::core::seproxy::protocol;
using namespace keyple::core::util;
using namespace keyple::plugin::pcsc;
class DemoPoAuthentication final {};
const std::shared_ptr&amp;lt;Logger&amp;gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication));
// PO Reader name
const std::string PO_READER_NAME = &amp;quot;XXX&amp;quot;;
// SAM Reader name
const std::string SAM_READER_NAME = &amp;quot;XXX&amp;quot;;
// Keyple test kit profile 1, Application 2
const std::string AID = &amp;quot;315449432E49434131&amp;quot;;
const uint8_t RECORD_NUMBER_1 = 1;
const uint8_t SFI_Environment = 0x07;
int main(int argv, char **args)
{
// Get the instance of the SeProxyService (Singleton pattern)
SeProxyService&amp;amp; seProxyService = SeProxyService::getInstance();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Get and Configure the PO &amp;amp; SAM Readers =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin
auto pluginFactory = std::make_shared&amp;lt;PcscPluginFactory&amp;gt;();
std::shared_ptr&amp;lt;ReaderPlugin&amp;gt; readerPlugin = seProxyService.registerPlugin(pluginFactory);
// Get the PO reader
std::shared_ptr&amp;lt;SeReader&amp;gt; poReader = readerPlugin-&amp;gt;getReader(PO_READER_NAME);
// Get a SAM reader
std::shared_ptr&amp;lt;SeReader&amp;gt; samReader = readerPlugin-&amp;gt;getReader(SAM_READER_NAME);
// Eventually, configure the SAM reader parameters
// ...
/* Set Pcsc settings per reader */
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1);
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0);
/*
* PC/SC card access mode:
*
* The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited
* time between two consecutive exchanges granted by Windows.
*
* This point will be addressed in a coming release of the Keyple PcSc reader plugin.
*
* The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the
* selection step that may result in session failures.
*
* See KEYPLE-CORE.PC.md file to learn more about this point.
*
*/
samReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
poReader-&amp;gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED);
/* Set the PO reader protocol flag */
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO14443_4,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]);
poReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_B_PRIME,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]);
samReader-&amp;gt;addSeProtocolSetting(
SeCommonProtocols::PROTOCOL_ISO7816_3,
PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Create a SAM resource after selecting the SAM =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Prepare the selector to ensure the correct SAM is used
auto selector = SamSelector::builder()-&amp;gt;samRevision(SamRevision::AUTO).build();
auto samSelector = std::dynamic_pointer_cast&amp;lt;SamSelector&amp;gt;(selector);
// Make the SAM selection
SeSelection samSelection;
auto samSelectionRequest = std::make_shared&amp;lt;SamSelectionRequest&amp;gt;(samSelector);
auto abstractSamSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(
samSelectionRequest);
samSelection.prepareSelection(abstractSamSelectionRequest);
std::shared_ptr&amp;lt;CalypsoSam&amp;gt; calypsoSam;
if (samReader-&amp;gt;isSePresent()) {
std::shared_ptr&amp;lt;SelectionsResult&amp;gt; selectionsResult =
samSelection.processExplicitSelection(samReader);
if (selectionsResult-&amp;gt;hasActiveSelection()) {
calypsoSam = std::dynamic_pointer_cast&amp;lt;CalypsoSam&amp;gt;(
selectionsResult-&amp;gt;getActiveMatchingSe());
} else {
throw IllegalStateException(&amp;quot;SAM matching failed!&amp;quot;);
}
} else {
throw IllegalStateException(&amp;quot;No SAM is present in the reader &amp;quot; + samReader-&amp;gt;getName());
}
// Associate the calypsoSam and the samReader to create the samResource
auto samResource = std::make_shared&amp;lt;SeResource&amp;lt;CalypsoSam&amp;gt;&amp;gt;(samReader, calypsoSam);
// Prepare the security settings used during the Calypso transaction
auto poSecuritySettings =
std::make_shared&amp;lt;PoSecuritySettings::PoSecuritySettingsBuilder&amp;gt;(samResource)-&amp;gt;build();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Display basic information about the readers and SAM =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= PO Reader Name = %\n&amp;quot;, poReader-&amp;gt;getName());
const std::string samSerialNumber =
ByteArrayUtil::toHex(samResource-&amp;gt;getMatchingSe()-&amp;gt;getSerialNumber());
logger-&amp;gt;info(&amp;quot;= SAM Reader Name = %, Serial Number = %\n&amp;quot;,
samResource-&amp;gt;getSeReader()-&amp;gt;getName(),
samSerialNumber);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Prepare the Calypso PO selection =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Prepare a Calypso PO selection
SeSelection seSelection;
// Setting of an AID based selection of a Calypso Revision 3.1 PO
//
// Select the first application matching the selection AID whatever the card communication
// protocol
// Keep the logical channel open after the selection
//
// Calypso selection: configures a PoSelectionRequest with all the desired attributes to
// make the selection and read additional information afterwards
auto aidSelector = SeSelector::AidSelector::builder()-&amp;gt;aidToSelect(AID).build();
auto seSelector = PoSelector::builder()-&amp;gt;aidSelector(aidSelector) // the application identifier
// to indicate if an invalidated PO should be accepted
// or not
.invalidatedPo(PoSelector::InvalidatedPo::REJECT)
.build();
auto poSelector = std::dynamic_pointer_cast&amp;lt;PoSelector&amp;gt;(seSelector);
auto poSelectionRequest = std::make_shared&amp;lt;PoSelectionRequest&amp;gt;(poSelector);
// Add the selection case to the current selection
// (we could have added other cases)
auto abstractPoSelectionRequest =
std::reinterpret_pointer_cast&amp;lt;AbstractSeSelectionRequest&amp;lt;AbstractApduCommandBuilder&amp;gt;&amp;gt;(
poSelectionRequest);
seSelection.prepareSelection(abstractPoSelectionRequest);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Check if a PO is present in the reader =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
if (poReader-&amp;gt;isSePresent()) {
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Start of the Calypso PO processing =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 1st PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= AID based selection =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
try {
// Actual PO communication: operate through a single request the Calypso PO selection
std::shared_ptr&amp;lt;CalypsoPo&amp;gt; calypsoPo =
std::dynamic_pointer_cast&amp;lt;CalypsoPo&amp;gt;(
seSelection.processExplicitSelection(poReader)-&amp;gt;getActiveMatchingSe());
logger-&amp;gt;info(&amp;quot;The selection of the PO has succeeded\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 2nd PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Open a Calypso secure session =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Reading of Environment file (SFI=07h) =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// Create a PoTransaction object to manage the Calypso transaction
auto poTransaction = std::make_shared&amp;lt;PoTransaction&amp;gt;(
std::make_shared&amp;lt;SeResource&amp;lt;CalypsoPo&amp;gt;&amp;gt;(poReader, calypsoPo),
poSecuritySettings);
// Read the Environment file at the Session Opening
// (we could have added other commands)
poTransaction-&amp;gt;prepareReadRecordFile(
SFI_Environment, // the sfi to select
RECORD_NUMBER_1);
// Open Session with the debit key
poTransaction-&amp;gt;processOpening(
PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT);
// Get the Environment data
std::shared_ptr&amp;lt;ElementaryFile&amp;gt; efEnvironment =
calypsoPo-&amp;gt;getFileBySfi(SFI_Environment);
const std::string environmentLog =
ByteArrayUtil::toHex(efEnvironment-&amp;gt;getData()-&amp;gt;getContent());
logger-&amp;gt;info(&amp;quot;File Environment log: %\n&amp;quot;, environmentLog);
if (!calypsoPo-&amp;gt;isDfRatified()) {
logger-&amp;gt;info(&amp;quot;============= Previous Calypso Secure Session was not ratified =============\n&amp;quot;);
}
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= 3th PO exchange =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= Close the Calypso secure session =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
// To close the channel with the PO after the closing
poTransaction-&amp;gt;prepareReleasePoChannel();
// Close the Calypso Secure Session
// A ratification command will be sent (CONTACTLESS_MODE)
poTransaction-&amp;gt;processClosing();
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= The Calypso secure session ended successfully =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= (Successful mutual authentication) =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;= End of the Calypso PO processing =\n&amp;quot;);
logger-&amp;gt;info(&amp;quot;============================================================================\n&amp;quot;);
} catch (const Exception&amp;amp; e) {
logger-&amp;gt;error(&amp;quot;Exception: %\n&amp;quot;, e.getMessage());
}
} else {
logger-&amp;gt;error(&amp;quot;The selection of the PO has failed\n&amp;quot;);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h4 id="sample-trace">Sample trace&lt;/h4>
&lt;pre>&lt;code class="language-bash">============================================================================
= Get and Configure the PO &amp;amp; SAM Readers =
============================================================================
initNativeReaders - getting card terminals
run - starting executor monitoring thread
[PcscReaderImpl] constructor =&amp;gt; using terminal OMNIKEY CardMan (076B:5421) 5421(1)
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME =transmission_mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = disconnect, VALUE =
run - starting executor monitoring thread
constructor =&amp;gt; using terminal OMNIKEY CardMan (076B:5421) 5421(2)
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = transmission_mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE =
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = disconnect, VALUE =
Registering a new Plugin to the platform : PcscPlugin
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE = T1
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = protocol, VALUE = T0
[OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE = shared
[OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =&amp;gt; PCSC: Set a parameter. NAME = mode, VALUE = shared
============================================================================
= Create a SAM resource after selecting the SAM =
============================================================================
protocolFlagMatches - physical channel not open, opening it
[OMNIKEY CardMan (076B:5421) 5421(1)] openAndConnect - protocol: T=0
openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(1) with protocol: T=0, connectProtocol: 1
and sharingMode: 2
openAndConnect - card state: 84
[OMNIKEY CardMan (076B:5421) 5421(1)] Opening of a physical SE channel in shared mode
[OMNIKEY CardMan (076B:5421) 5421(1)] protocolFlagMatches =&amp;gt; matching SE. PROTOCOLFLAG = SEPROTOCOL:
{NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS}
processSeRequestSet - processing requests set
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =&amp;gt; transmit SEREQUEST: {REQUESTS = ApduRequests: {},
SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS}AIDSELECTOR = null,
ATRFILTER: {REGEX = .*}}}
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 0
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =&amp;gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {},
SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b3f9600805a4880c1205017aec11a36829000, FCI = R-APDU:
{STATUS = FAILURE, BYTES (0) = }, HASMATCHED = 1}, CHANNELWASOPEN = 0}
============================================================================
= Display basic information about the readers and SAM =
============================================================================
= PO Reader Name = OMNIKEY CardMan (076B:5421) 5421(2)
= SAM Reader Name = OMNIKEY CardMan (076B:5421) 5421(1), Serial Number = AEC11A36
============================================================================
= Prepare the Calypso PO selection =
============================================================================
============================================================================
= Check if a PO is present in the reader =
============================================================================
============================================================================
= Start of the Calypso PO processing =
============================================================================
= 1st PO exchange =
= AID based selection =
============================================================================
protocolFlagMatches - physical channel not open, opening it
[OMNIKEY CardMan (076B:5421) 5421(2)] openAndConnect - protocol: T=1
openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(2) with protocol: T=1, connectProtocol: 2
and sharingMode: 2
openAndConnect - card state: 84
[OMNIKEY CardMan (076B:5421) 5421(2)] Opening of a physical SE channel in shared mode
[OMNIKEY CardMan (076B:5421) 5421(2)] protocolFlagMatches =&amp;gt; matching SE. PROTOCOLFLAG = SEPROTOCOL:
{NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS}
processSeRequestSet - processing requests set
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =&amp;gt; transmit SEREQUEST: {REQUESTS = ApduRequests:
{}, SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS}AIDSELECTOR:
{AIDTOSELECT = 315449432e49434131FILEOCCURRENCE: {ISOBITMASK = 0(0x00)}FILECONTROLINFORMATION:
{ISOBITMASK = 0(0x00)}0x0}, ATRFILTER = null}}
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 0
[OMNIKEY CardMan (076B:5421) 5421(2)] openLogicalChannel =&amp;gt; Select Application with AID = 315449432e49434131
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Internal Select Application,
RAWDATA = 00a4040009315449432e4943413100, CASE4 = 1}, elapsed 13c ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 00a4040009315449432e4943413100
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt;
6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, elapsed c ms
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =&amp;gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {},
SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b888001000000009171710098, FCI = R-APDU: {STATUS = SUCCESS,
BYTES (27) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, HASMATCHED = 1},
CHANNELWASOPEN = 0}
Application Serial Number = 00000000C17BE1F6
Discretionary Data = 0a3c2305141001
The selection of the PO has succeeded
============================================================================
= 2nd PO exchange =
= Open a Calypso secure session =
= Reading of Environment file (SFI=07h) =
============================================================================
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Select Diversifier,
RAWDATA = 801400000800000000c17be1f6, CASE4 = 0}, elapsed 208 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 801400000800000000c17be1f6
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) =
9000}, elapsed 37 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Get Challenge,
RAWDATA = 8084000004, CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 8084000004
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; ef48651d9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
ef48651d9000}, elapsed 3 ms
identification: TERMINALCHALLENGE = ef48651d
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Open Secure Session
V3.1 - KEYINDEX=3, SFI=07, REC=1, RAWDATA = 008a0b3904ef48651d00, CASE4 = 1}, elapsed c7 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 008a0b3904ef48651d00
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt;
030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000}, elapsed e ms
processAtomicOpening =&amp;gt; opening: CARDCHALLENGE = CF, POKIF = 30, POKVC = 79
initialize: POREVISION = REV3_1, SAMREVISION = C1, SESSIONENCRYPTION = 0, VERIFICATIONMODE = 0
initialize: VERIFICATIONMODE = 0, REV32MODE = 0, KEYRECNUMBER = 0(0x00)
initialize: KIF = 48(0x30), KVC = 79(0x79), DIGESTDATA =
030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000
File Environment log: 0000000000000000000000000000000000000000000000000000000000
============================================================================
= 3th PO exchange =
= Close the Calypso secure session =
============================================================================
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Init, RAWDATA = 808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000, CASE4 = 0},
elapsed 2f ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt;
808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000},
elapsed 6 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Close,
RAWDATA = 808e000004, CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 808e000004
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 819e515d9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
819e515d9000}, elapsed 9 ms
SIGNATURE = 819e515d
[OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Close Secure Session,
RAWDATA = 008e800004819e515d00, CASE4 = 1}, elapsed 31 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 008e800004819e515d00
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt; 08d222e99000
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (6) =
08d222e99000}, elapsed 34 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = , RAWDATA = 00b2000000,
CASE4 = 0}, elapsed 0 ms
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu &amp;gt;&amp;gt; 00b2000000
[OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu &amp;lt;&amp;lt; 6b00
[OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =&amp;gt; R-APDU: {STATUS = FAILURE, BYTES (2) = 6b00},
elapsed 2a ms
[OMNIKEY CardMan (076B:5421) 5421(2)] closePhysicalChannel
[OMNIKEY CardMan (076B:5421) 5421(2)] closeAndDisconnect - reset: y
[OMNIKEY CardMan (076B:5421) 5421(2)] Ignore =&amp;gt; Event SE_PROCESSED received in currentState
WAIT_FOR_START_DETECTION
[OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =&amp;gt; Logical channel open = 1
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; APDUREQUEST: {NAME = Digest Authenticate,
RAWDATA = 808200000408d222e9, CASE4 = 0}, elapsed 61 ms
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu &amp;gt;&amp;gt; 808200000408d222e9
[OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu &amp;lt;&amp;lt; 9000
[OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =&amp;gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000},
elapsed 5e ms
============================================================================
= The Calypso secure session ended successfully =
= (Successful mutual authentication) =
= End of the Calypso PO processing =
============================================================================
&lt;/code>&lt;/pre></description></item></channel></rss>