<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Keyple C++: keyple::core::util::ByteArrayUtil Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Keyple C++
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">Keyple, an Open Source SDK for Ticketing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/ddf/namespacekeyple.html">keyple</a></li><li class="navelem"><a class="el" href="../../d3/d6c/namespacekeyple_1_1core.html">core</a></li><li class="navelem"><a class="el" href="../../d4/d55/namespacekeyple_1_1core_1_1util.html">util</a></li><li class="navelem"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html">ByteArrayUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../db/d56/classkeyple_1_1core_1_1util_1_1_byte_array_util-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">keyple::core::util::ByteArrayUtil Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;ByteArrayUtil.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acc570b2a62e4fccf81f494bb54dc2da5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#acc570b2a62e4fccf81f494bb54dc2da5">fromHex</a> (const std::string &amp;hex)</td></tr>
<tr class="separator:acc570b2a62e4fccf81f494bb54dc2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bea4707f0ebdeec33c9233b612b76"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#a8d5bea4707f0ebdeec33c9233b612b76">toHex</a> (const std::vector&lt; char &gt; &amp;byteArray)</td></tr>
<tr class="separator:a8d5bea4707f0ebdeec33c9233b612b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad635a042353740e6076a8b3a5c274908"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#ad635a042353740e6076a8b3a5c274908">toHex</a> (const std::vector&lt; uint8_t &gt; &amp;byteArray)</td></tr>
<tr class="separator:ad635a042353740e6076a8b3a5c274908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97dab37ff558e3419b5ce9d24fd6568"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#ae97dab37ff558e3419b5ce9d24fd6568">twoBytesToInt</a> (const std::vector&lt; uint8_t &gt; &amp;bytes, const int offset)</td></tr>
<tr class="separator:ae97dab37ff558e3419b5ce9d24fd6568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d2f221c4380923876980b727c5b20f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#aa9d2f221c4380923876980b727c5b20f">twoBytesSignedToInt</a> (const std::vector&lt; uint8_t &gt; &amp;bytes, const int offset)</td></tr>
<tr class="separator:aa9d2f221c4380923876980b727c5b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea6c909ebe355d2179448de8166321b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#a7ea6c909ebe355d2179448de8166321b">threeBytesToInt</a> (const std::vector&lt; uint8_t &gt; &amp;bytes, const int offset)</td></tr>
<tr class="separator:a7ea6c909ebe355d2179448de8166321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae177c66bf20ddcae653d4eab3019b937"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#ae177c66bf20ddcae653d4eab3019b937">threeBytesSignedToInt</a> (const std::vector&lt; uint8_t &gt; &amp;bytes, const int offset)</td></tr>
<tr class="separator:ae177c66bf20ddcae653d4eab3019b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ffa5dbcbcf6e0f363ca62ff5daeb25"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/classkeyple_1_1core_1_1util_1_1_byte_array_util.html#a93ffa5dbcbcf6e0f363ca62ff5daeb25">fourBytesToInt</a> (const std::vector&lt; uint8_t &gt; &amp;bytes, const int offset)</td></tr>
<tr class="separator:a93ffa5dbcbcf6e0f363ca62ff5daeb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utils around byte arrays </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a93ffa5dbcbcf6e0f363ca62ff5daeb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ffa5dbcbcf6e0f363ca62ff5daeb25">&#9670;&nbsp;</a></span>fourBytesToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int keyple::core::util::ByteArrayUtil::fourBytesToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert four bytes from a byte array into an integer. </p>
<p>The four bytes are expected to be in the MSB first order (aka network order). </p>
<p>Throw an exception if the buffer is null or not long enough to contain 4 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>byte array </td></tr>
    <tr><td class="paramname">offset</td><td>offset from which the 4 bytes are </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting int </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the buffer has a bad length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc570b2a62e4fccf81f494bb54dc2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc570b2a62e4fccf81f494bb54dc2da5">&#9670;&nbsp;</a></span>fromHex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; keyple::core::util::ByteArrayUtil::fromHex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a byte array from an hexa string. This method allows spaces and "h".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hex</td><td>Hexa string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array </dd></dl>

</div>
</div>
<a id="ae177c66bf20ddcae653d4eab3019b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae177c66bf20ddcae653d4eab3019b937">&#9670;&nbsp;</a></span>threeBytesSignedToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int keyple::core::util::ByteArrayUtil::threeBytesSignedToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert three bytes (signed) from a byte array into an integer. </p>
<p>The three bytes are expected to be in the MSB first order (aka network order). </p>
<p>The number is also considered as signed. That is, if the MSB (first left bit) is 1, then the number is negative and the conversion is done accordingly with the usual binary arithmetic. </p>
<p>Throw an exception if the buffer is null or not long enough to contain all 3 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>byte array containing a 3-byte signed number </td></tr>
    <tr><td class="paramname">offset</td><td>offset from which the 3 bytes are </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting int </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the buffer has a bad length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ea6c909ebe355d2179448de8166321b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea6c909ebe355d2179448de8166321b">&#9670;&nbsp;</a></span>threeBytesToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int keyple::core::util::ByteArrayUtil::threeBytesToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert three bytes from a byte array into an integer. </p>
<p>The three bytes are expected to be in the MSB first order (aka network order). </p>
<p>Throw an exception if the buffer is null or not long enough to contain all 3 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>byte array </td></tr>
    <tr><td class="paramname">offset</td><td>offset from which the 3 bytes are </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting int </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the buffer has a bad length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5bea4707f0ebdeec33c9233b612b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bea4707f0ebdeec33c9233b612b76">&#9670;&nbsp;</a></span>toHex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string keyple::core::util::ByteArrayUtil::toHex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>byteArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Represents the byte array in a hexadecimal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteArray</td><td>byte array to represent to hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hex representation of the byte array </dd></dl>

</div>
</div>
<a id="ad635a042353740e6076a8b3a5c274908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad635a042353740e6076a8b3a5c274908">&#9670;&nbsp;</a></span>toHex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string keyple::core::util::ByteArrayUtil::toHex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>byteArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Represents the byte array in a hexadecimal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteArray</td><td>byte array to represent to hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hex representation of the byte array </dd></dl>

</div>
</div>
<a id="aa9d2f221c4380923876980b727c5b20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2f221c4380923876980b727c5b20f">&#9670;&nbsp;</a></span>twoBytesSignedToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int keyple::core::util::ByteArrayUtil::twoBytesSignedToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert two bytes (signed) from a byte array into an integer. </p>
<p>The two bytes are expected to be in the MSB first order (aka network order). </p>
<p>The number is also considered as signed. That is, if the MSB (first left bit) is 1, then the number is negative and the conversion is done accordingly with the usual binary arithmetic. </p>
<p>Throw an exception if the buffer is null or not long enough to contain 2 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>byte array </td></tr>
    <tr><td class="paramname">offset</td><td>offset from which the 2 bytes are </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting int </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the buffer has a bad length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97dab37ff558e3419b5ce9d24fd6568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97dab37ff558e3419b5ce9d24fd6568">&#9670;&nbsp;</a></span>twoBytesToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int keyple::core::util::ByteArrayUtil::twoBytesToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert two bytes (unsigned) from a byte array into an integer. </p>
<p>The two bytes are expected to be in the MSB first order (aka network order). </p>
<p>Throw an exception if the buffer is null or not long enough to contain 2 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>byte array </td></tr>
    <tr><td class="paramname">offset</td><td>offset from which the 2 bytes are </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting int </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the buffer has a bad length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>component/keyple-core/src/main/util/<a class="el" href="../../d9/d6a/_byte_array_util_8h.html">ByteArrayUtil.h</a></li>
<li>component/keyple-core/src/main/util/<a class="el" href="../../d1/d6e/_byte_array_util_8cpp.html">ByteArrayUtil.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
