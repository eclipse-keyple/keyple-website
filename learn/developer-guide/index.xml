<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer guides | Eclipse Keyple</title><link>https://keyple.org/learn/developer-guide/</link><atom:link href="https://keyple.org/learn/developer-guide/index.xml" rel="self" type="application/rss+xml"/><description>Developer guides</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://keyple.org/media/logo.svg</url><title>Developer guides</title><link>https://keyple.org/learn/developer-guide/</link></image><item><title>Reader Plugin Add-on Developer Guide</title><link>https://keyple.org/learn/developer-guide/reader-plugin-add-on/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/reader-plugin-add-on/</guid><description>&lt;br>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>This guide is intended to help developers who want to create a Keyple reader plugin add-on for a specific device.&lt;/p>
&lt;br>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;ol>
&lt;li>Learn the &lt;a href="#plugin-architecture">plugin architecture&lt;/a> concepts&lt;/li>
&lt;li>&lt;a href="#select-predefined-features">Select the predefined features&lt;/a> that meet your need&lt;/li>
&lt;li>&lt;a href="#define-specific-features">Define specific features&lt;/a> (optional)&lt;/li>
&lt;li>&lt;a href="#implement-the-solution">Implement the solution&lt;/a>&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2 id="plugin-architecture">Plugin architecture&lt;/h2>
&lt;p>A Keyple reader plugin consists of three objects, a &lt;strong>plugin factory&lt;/strong>, a &lt;strong>plugin&lt;/strong> and a &lt;strong>reader&lt;/strong>, which meet the
following interface specifications:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Common API&lt;/strong>: public contract containing only generic types common to all plugins.&lt;/li>
&lt;li>&lt;strong>Plugin API&lt;/strong>: private contract based on two types of interfaces:
&lt;ul>
&lt;li>&lt;strong>API&lt;/strong> (Application Programming Interface): interface implemented by Keyple Service and directly usable by the
plugin code.&lt;/li>
&lt;li>&lt;strong>SPI&lt;/strong> (Service Provider Interface): interface to be implemented by the plugin and directly used by Keyple Service.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Plugin Storage Card API&lt;/strong> &lt;em>(optional)&lt;/em>: private contract that may be involved when interactions with storage cards
are required, in order to rely on an APDU interpreter. It is also based on two types of interfaces:
&lt;ul>
&lt;li>&lt;strong>API&lt;/strong> (Application Programming Interface): interface implemented by the plugin and directly usable by the APDU
interpreter, allowing the interpreter to call back into the plugin to handle specific behaviors required during
storage card interactions.&lt;/li>
&lt;li>&lt;strong>SPI&lt;/strong> (Service Provider Interface): interface to be implemented by the APDU interpreter and directly usable by the plugin, allowing the plugin to invoke interpreter functions for storage card operations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The component diagram below illustrates the internal API/SPI links between the plugin and Keyple Service, as well as the
public APIs exposed to the application:&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/learn/developer-guide/component-dependencies/Component_ReaderPluginAddOn.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;br>
&lt;h2 id="select-predefined-features">Select predefined features&lt;/h2>
&lt;p>The diagram below helps you to determine exactly which interfaces to implement according to the characteristics of the reader:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/learn/developer-guide/design-guides/reader_plugin_activity_diagram.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;div class="alert alert-warning">
&lt;div>
The &lt;code>XxxPluginFactory&lt;/code>, &lt;code>XxxPlugin&lt;/code> and &lt;code>XxxReader&lt;/code> interfaces must be created.
They are specific to the plugin &lt;code>Xxx&lt;/code> to be created but can remain empty if there is no specific feature.
&lt;/div>
&lt;/div>
&lt;br>
&lt;h2 id="define-specific-features">Define specific features&lt;/h2>
&lt;p>Depending on the characteristics of the reader, it may be necessary to add in the specific APIs configuration methods appropriate to the technical context.&lt;/p>
&lt;p>These features can be exposed at three levels:&lt;/p>
&lt;ul>
&lt;li>In the &lt;strong>plugin factory&lt;/strong> (&lt;code>XxxPluginFactory&lt;/code> interface), for the initial configuration of the plugin (e.g. set custom plugin name).&lt;/li>
&lt;li>In the &lt;strong>plugin&lt;/strong> (&lt;code>XxxPlugin&lt;/code> interface), for dynamic configurations that can be applied to all the readers (e.g. put the readers in sleep mode).&lt;br>
The API will then be directly accessible from the application through the &lt;code>getExtension(...)&lt;/code> method of the plugin registered with Keyple Service.&lt;/li>
&lt;li>In the &lt;strong>reader&lt;/strong> (&lt;code>XxxReader&lt;/code> interface), for dynamic configurations specific to each reader (e.g. activate/deactivate a LED).&lt;br>
The API will then be directly accessible from the application through the &lt;code>getReaderExtension(...)&lt;/code> method of the reader provided by the plugin registered with Keyple Service.&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="implement-the-solution">Implement the solution&lt;/h2>
&lt;div class="alert alert-warning">
&lt;div>
It is recommended to hide the internal Keyple interfaces of the &lt;strong>Plugin API&lt;/strong> from the application.
&lt;/div>
&lt;/div>
&lt;p>For this purpose, it is suggested to respect the following programming pattern based on the use of:&lt;/p>
&lt;ul>
&lt;li>public interfaces,&lt;/li>
&lt;li>private interfaces adapters (package visibility) accessible from a public provider/builder.
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/learn/developer-guide/design-guides/reader_plugin_class_diagram.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-note">
&lt;div>
It is possible to use other alternatives to the factory provider depending on the need.
For example, if the plugin factory needs to expose specific configuration methods, it is recommended to use the builder pattern instead of the provider pattern in order to get a properly initialized factory.
Thus, the factory does not expose any method.
&lt;/div>
&lt;/div>
&lt;br>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.keyple.org/keyple-common-java-api" target="_blank" rel="noopener">Keyple Common API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.keyple.org/keyple-plugin-java-api" target="_blank" rel="noopener">Keyple Plugin API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.keyple.org/keyple-plugin-storagecard-java-api/" target="_blank" rel="noopener">Keyple Plugin Storage Card API&lt;/a>&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://keyple.org/components/overview/configuration-wizard/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Card Extension Add-on Developer Guide</title><link>https://keyple.org/learn/developer-guide/card-extension-add-on/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/card-extension-add-on/</guid><description>&lt;br>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>This guide is intended to help developers who want to create a Keyple card extension add-on for a specific card
technology.&lt;/p>
&lt;br>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;ol>
&lt;li>Learn the &lt;a href="#card-extension-architecture">card extension architecture&lt;/a> concepts&lt;/li>
&lt;li>Take note of the &lt;a href="#minimal-requirements">minimal requirements&lt;/a>&lt;/li>
&lt;li>&lt;a href="#define-the-card-commands">Define the card commands&lt;/a>&lt;/li>
&lt;li>&lt;a href="#implement-the-solution">Implement the solution&lt;/a>&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2 id="card-extension-architecture">Card extension architecture&lt;/h2>
&lt;p>A Keyple card extension contains a set of objects which meet the following three interface specifications:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Common API&lt;/strong>: public contract including a generic type common to all card extensions.&lt;/li>
&lt;li>&lt;strong>Keypop Reader API&lt;/strong>: public contract provided by the Eclipse Keypop project including two specific
interfaces to be implemented by the card extension and required by the card selection manager.&lt;/li>
&lt;li>&lt;strong>Keypop Card API&lt;/strong>: private contract provided by the Eclipse Keypop project based on two types of
interfaces:
&lt;ul>
&lt;li>&lt;strong>API&lt;/strong> (Application Programming Interface): interface implemented by Keyple Service and directly usable by the
card extension code.&lt;/li>
&lt;li>&lt;strong>SPI&lt;/strong> (Service Provider Interface): interface to be implemented by the card extension and directly used by
Keyple Service.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The component diagram below illustrates the internal API/SPI links between the card extension and Keyple Service, as
well as the public APIs exposed to the application:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/learn/developer-guide/component-dependencies/Component_CardExtensionAddOn.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;br>
&lt;h2 id="minimal-requirements">Minimal requirements&lt;/h2>
&lt;p>The table below lists the objects that must be created and indicates the interfaces to be implemented for each of them:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Object&lt;/th>
&lt;th style="text-align:center">Common API&lt;/th>
&lt;th style="text-align:center">Keypop Reader API&lt;/th>
&lt;th style="text-align:center">Keypop Card API&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Card extension service&lt;/td>
&lt;td style="text-align:center">&lt;code>KeypleCardExtension&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Card selection parser&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;code>CardSelectionExtension&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>CardSelectionExtensionSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Smart card object&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;code>SmartCard&lt;/code> or &lt;code>IsoSmartCard&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>SmartCardSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Card selection request DTO&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;code>CardSelectionRequestSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Card request DTO&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;code>CardRequestSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>APDU request DTO&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;code>ApduRequestSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-warning">
&lt;div>
&lt;p>In the case where the smart card object has fields of type &lt;code>interface&lt;/code>,
it will then be necessary to define for each of them and recursively a JSON deserializer and register it during the
service initialization with the method &lt;code>JsonUtil.registerTypeAdapter(...)&lt;/code> provided by the
&lt;a href="https://keyple.org/components/core/keyple-util-lib/" target="_blank" rel="noopener">Keyple Util&lt;/a> library.&lt;/p>
&lt;p>This will allow the transport of this object through the network when using the Keyple Distributed solution.&lt;/p>
&lt;/div>
&lt;/div>
&lt;br>
&lt;h2 id="define-the-card-commands">Define the card commands&lt;/h2>
&lt;p>The card extension takes part in the communication with the card in two ways:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>implicitly&lt;/strong>, when the card is being selected, which is done directly by the application via the Keyple Service
selection manager;&lt;/li>
&lt;li>&lt;strong>explicitly&lt;/strong>, when the card has been selected, on request of the application, by direct use of the APIs exposed by
the Card API.&lt;/li>
&lt;/ul>
&lt;p>For explicit communication, the card extension must require the application to provide a reference to a &lt;code>CardReader&lt;/code> of
the Reader API.
This can then be cast internally to a &lt;code>ProxyReaderApi&lt;/code> of the Card API through which it will be possible to transmit
card commands.&lt;/p>
&lt;p>Each card extension is free to define the APIs it considers relevant to perform card transactions.&lt;/p>
&lt;br>
&lt;h2 id="implement-the-solution">Implement the solution&lt;/h2>
&lt;div class="alert alert-warning">
&lt;div>
It is recommended to hide the internal interfaces of the &lt;strong>Keypop Card API&lt;/strong> from the application.
&lt;/div>
&lt;/div>
&lt;p>For this purpose, it is suggested to respect the following programming pattern based on the use of:&lt;/p>
&lt;ul>
&lt;li>public interfaces,&lt;/li>
&lt;li>private interfaces adapters (package visibility) not accessible from a public service.
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/learn/developer-guide/design-guides/card_extension_class_diagram.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.keyple.org/keyple-common-java-api" target="_blank" rel="noopener">Keyple Common API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keypop.org/apis/reader-layer/reader-api/" target="_blank" rel="noopener">Keypop Reader API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keypop.org/apis/reader-layer/card-api/" target="_blank" rel="noopener">Keypop Card API&lt;/a>&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://keyple.org/components/overview/configuration-wizard/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Coding Standards Developer Guide</title><link>https://keyple.org/learn/developer-guide/coding-standards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/coding-standards/</guid><description>&lt;br>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>This guide defines &lt;strong>mandatory logging rules&lt;/strong> for contributors working on the Keyple codebase.&lt;/p>
&lt;p>The objective is to ensure:&lt;/p>
&lt;ul>
&lt;li>predictable behavior for integrators,&lt;/li>
&lt;li>compatibility with Android ProGuard / R8 optimizations,&lt;/li>
&lt;li>consistent logging across all libraries.&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="slf4j-usage">SLF4J usage&lt;/h2>
&lt;h3 id="dependency-configuration">Dependency configuration&lt;/h3>
&lt;p>All Keyple JVM libraries using logging &lt;strong>MUST&lt;/strong> declare SLF4J using the following configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">compileOnly&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;org.slf4j:slf4j-api:1.7.36&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>Both the dependency scope (&lt;code>compileOnly&lt;/code>) and the exact version (&lt;code>1.7.36&lt;/code>) are mandatory and must not be changed locally.&lt;/p>
&lt;p>Why &lt;code>compileOnly&lt;/code> is required:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Keyple must remain logging-backend agnostic&lt;/strong>&lt;br>
Keyple is a library and must not impose any SLF4J binding or logging implementation
(Timber, Logback, Log4j, Android Log, etc.) on integrator applications.&lt;/li>
&lt;li>&lt;strong>Avoids leaking dependencies into the application classpath&lt;/strong>&lt;br>
Declaring SLF4J as &lt;code>implementation&lt;/code> would make it a transitive dependency,
potentially overriding or conflicting with the version selected by the application.&lt;/li>
&lt;li>&lt;strong>Preserves full control for integrators&lt;/strong>&lt;br>
Integrators decide:
&lt;ul>
&lt;li>which SLF4J binding to use,&lt;/li>
&lt;li>how logging is routed (Android Log, Timber, file, remote, etc.),&lt;/li>
&lt;li>which log levels are enabled per build type.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Ensures correct ProGuard / R8 behavior on Android&lt;/strong>&lt;br>
ProGuard and R8 rules that disable or optimize logging are applied at the application level.
Using &lt;code>compileOnly&lt;/code> ensures those rules apply uniformly to Keyple and to all third-party libraries.&lt;/li>
&lt;li>&lt;strong>Prevents runtime coupling to logging behavior&lt;/strong>&lt;br>
Keyple code relies strictly on SLF4J API contracts and never on runtime side effects,
guaranteeing predictable behavior across all environments.&lt;/li>
&lt;/ul>
&lt;p>Why SLF4J &lt;code>1.7.36&lt;/code> is mandatory:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Last stable release of the SLF4J 1.7.x line&lt;/strong>&lt;br>
Version &lt;code>1.7.36&lt;/code> is the final and most stable release before the major 2.x API changes.&lt;/li>
&lt;li>&lt;strong>Binary compatibility with existing bindings&lt;/strong>&lt;br>
Most Android-compatible SLF4J bridges (including &lt;code>slf4j-timber&lt;/code>) target the 1.7.x API.&lt;/li>
&lt;li>&lt;strong>Allows integrators to freely choose their SLF4J version (including 2.x)&lt;/strong>&lt;br>
Keyple is compiled against SLF4J &lt;code>1.7.36&lt;/code>, whose API remains compatible with SLF4J 2.x.&lt;br>
As a result:
&lt;ul>
&lt;li>integrator applications may safely use SLF4J 1.7.x or 2.x at runtime,&lt;/li>
&lt;li>the chosen SLF4J version and binding are fully controlled by the application,&lt;/li>
&lt;li>Keyple remains agnostic to logging backend and runtime logging behavior.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Predictable behavior with Android tooling&lt;/strong>&lt;br>
Version &lt;code>1.7.36&lt;/code> is well-tested with:
&lt;ul>
&lt;li>Android Gradle Plugin,&lt;/li>
&lt;li>D8 (DEX compiler) / R8,&lt;/li>
&lt;li>ProGuard optimizations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-warning">
&lt;div>
Do not change the SLF4J dependency scope or upgrade the version without a project-wide decision.
Any deviation may cause classpath conflicts, logging failures, or broken ProGuard / R8 optimizations
in integrator applications.
&lt;/div>
&lt;/div>
&lt;h3 id="logger-declaration">Logger declaration&lt;/h3>
&lt;p>Loggers &lt;strong>must be declared once per class&lt;/strong> as a &lt;code>static&lt;/code> field (Java) or inside a &lt;code>companion object&lt;/code> (Kotlin).&lt;/p>
&lt;p>This ensures:&lt;/p>
&lt;ul>
&lt;li>a single logger instance per class,&lt;/li>
&lt;li>consistent logger naming,&lt;/li>
&lt;li>minimal runtime overhead,&lt;/li>
&lt;li>better analysis and optimization by R8.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Java&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Logger&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">LoggerFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getLogger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>&lt;strong>Kotlin&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">logger&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">LoggerFactory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getLogger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;div class="alert alert-warning">
&lt;div>
Do not declare loggers as instance fields.
This avoids unnecessary allocations and keeps logging behavior predictable.
&lt;/div>
&lt;/div>
&lt;br>
&lt;h2 id="android-constraints-and-rationale">Android constraints and rationale&lt;/h2>
&lt;h3 id="proguard--r8-limitations">ProGuard / R8 limitations&lt;/h3>
&lt;p>On Android:&lt;/p>
&lt;ul>
&lt;li>SLF4J loggers are accessed via interfaces,&lt;/li>
&lt;li>concrete implementations are resolved dynamically at runtime,&lt;/li>
&lt;li>R8 cannot safely assume that unguarded interface calls have no side effects.&lt;/li>
&lt;/ul>
&lt;p>As a result, when logs are &lt;strong>not conditionally guarded&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>logger.debug(...)&lt;/code> calls may remain in the optimized bytecode,&lt;/li>
&lt;li>log arguments may still be evaluated,&lt;/li>
&lt;li>unnecessary allocations and computations may occur,&lt;/li>
&lt;li>performance may be impacted, even in release builds.&lt;/li>
&lt;/ul>
&lt;h3 id="what-r8-can-optimize-reliably">What R8 can optimize reliably&lt;/h3>
&lt;p>When the conditional pattern is used:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isDebugEnabled&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">debug&lt;/span>&lt;span class="p">(...);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>And with the appropriate ProGuard / R8 rules:&lt;/p>
&lt;ul>
&lt;li>&lt;code>isDebugEnabled()&lt;/code> is treated as always &lt;code>false&lt;/code>,&lt;/li>
&lt;li>the conditional branch is proven unreachable,&lt;/li>
&lt;li>the entire block is removed,&lt;/li>
&lt;li>argument evaluation is completely eliminated.&lt;/li>
&lt;/ul>
&lt;div class="alert alert-note">
&lt;div>
This pattern exists to help the compiler and optimizer, not the logger.
Without it, log removal on Android cannot be guaranteed.
&lt;/div>
&lt;/div>
&lt;br>
&lt;h2 id="logging-coding-standards">Logging coding standards&lt;/h2>
&lt;h3 id="conditional-logging-pattern-mandatory">Conditional logging pattern (mandatory)&lt;/h3>
&lt;p>All &lt;code>DEBUG&lt;/code> and &lt;code>TRACE&lt;/code> log statements &lt;strong>MUST&lt;/strong> be conditionally guarded.
This pattern is mandatory in &lt;strong>all Keyple code&lt;/strong>, without exception.&lt;/p>
&lt;p>&lt;strong>Java (required)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isDebugEnabled&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">debug&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Card detected [powerOnData={}]&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cardPowerOnData&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>&lt;strong>Kotlin (required)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isDebugEnabled&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">debug&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Card detected [powerOnData={}]&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cardPowerOnData&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;h3 id="forbidden-logging-patterns">Forbidden logging patterns&lt;/h3>
&lt;p>Unguarded logging calls are strictly forbidden, even when:&lt;/p>
&lt;ul>
&lt;li>the log level is expected to be disabled,&lt;/li>
&lt;li>arguments appear inexpensive,&lt;/li>
&lt;li>the message uses constants or string literals.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Java (forbidden)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ❌ Forbidden: unguarded debug logging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Card detected [powerOnData=&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cardPowerOnData&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;]&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// ✅ Valid&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Card detected [powerOnData={}]&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cardPowerOnData&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>&lt;strong>Kotlin (forbidden)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ❌ Forbidden: unguarded debug logging
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Card detected [powerOnData=&lt;/span>&lt;span class="si">${cardPowerOnData}&lt;/span>&lt;span class="s2">]&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ✅ Valid
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Card detected [powerOnData={}]&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cardPowerOnData&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;h3 id="logging-levels-in-keyple">Logging levels in Keyple&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Level&lt;/th>
&lt;th>Usage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ERROR&lt;/td>
&lt;td>Functional or technical failures&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WARN&lt;/td>
&lt;td>Unexpected but recoverable situations&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>INFO&lt;/td>
&lt;td>High-level lifecycle events&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DEBUG&lt;/td>
&lt;td>Detailed execution flow (guarded)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TRACE&lt;/td>
&lt;td>Low-level protocol / byte-level details (guarded)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h2 id="summary-for-contributors">Summary for contributors&lt;/h2>
&lt;ul>
&lt;li>Use SLF4J &lt;code>1.7.36&lt;/code> with &lt;code>compileOnly&lt;/code> mode only&lt;/li>
&lt;li>Always guard DEBUG and TRACE logs&lt;/li>
&lt;li>Never rely on ProGuard to remove unguarded logs&lt;/li>
&lt;li>Write logs with integrators and performance in mind&lt;/li>
&lt;/ul></description></item></channel></rss>