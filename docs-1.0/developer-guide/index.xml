<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer guides | Eclipse Keyple</title><link>https://keyple.org/docs-1.0/developer-guide/</link><atom:link href="https://keyple.org/docs-1.0/developer-guide/index.xml" rel="self" type="application/rss+xml"/><description>Developer guides</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2020-2021 The Eclipse Keyple® project. All Rights Reserved.</copyright><image><url>https://keyple.org/media/logo.svg</url><title>Developer guides</title><link>https://keyple.org/docs-1.0/developer-guide/</link></image><item><title>Common concepts</title><link>https://keyple.org/docs-1.0/developer-guide/common-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/common-concepts/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;p>This page describes the core elements of Keyple, i.e. the concepts and APIs of &lt;strong>Keyple Core&lt;/strong> that are used to build any application implementing Keyple.&lt;/p>
&lt;p>It is essential for the future user of Keyple to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;hr>
&lt;h2 id="reader">Reader&lt;/h2>
&lt;p>Keyple&amp;rsquo;s primary goal being to interact with smart cards (or smartphones) worn by individuals, it is logical to put the Reader at the top of &lt;strong>Keyple Core&lt;/strong>&amp;rsquo;s concepts.&lt;/p>
&lt;p>Indeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via &lt;strong>Keyple Core&lt;/strong> or using an extension (such as &lt;strong>Keyple Calypso&lt;/strong>).&lt;/p>
&lt;p>These interfaces provide the means to&lt;/p>
&lt;ul>
&lt;li>identify the underlying physical reader,&lt;/li>
&lt;li>manage communication protocols,&lt;/li>
&lt;li>detect the presence and communicate with smart cards.&lt;/li>
&lt;/ul>
&lt;p>The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="plugin">Plugin&lt;/h2>
&lt;p>In Keyple language a plugin is a service that allows the management of readers of a certain type.
The plugin is responsible for informing the application about the availability of readers.
The readers of the same plugin are usually hardware linked to the same physical interface.&lt;/p>
&lt;p>Depending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).&lt;/p>
&lt;p>The Plugin interface essentially allows to list and retrieve the available readers.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="smart-card-service">Smart card service&lt;/h2>
&lt;p>This is the &lt;strong>Keyple Core&lt;/strong> service that concentrates the knowledge of active plugins and readers.&lt;/p>
&lt;p>At startup, a Keyple application must register the plugins it uses. Conversely, it can also unregister them.&lt;/p>
&lt;p>The &lt;strong>SmartCardService&lt;/strong> will then make sure that the resources used are properly released.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#reader-access">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="observation">Observation&lt;/h2>
&lt;p>The observation concept applies to readers as well as to plugins; optional, it is used depending on the needs.&lt;/p>
&lt;p>It consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.&lt;/p>
&lt;p>Not all plugins and readers are observable.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#reader-notifications">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="selection">Selection&lt;/h2>
&lt;p>In Keyple the concept of selection is derived from the application selection defined by the ISO7816-4 standard.&lt;/p>
&lt;p>It supplements it by managing cards that do not have the standard command using identification mechanisms based on Answer To Reset and the communication protocol, and also by allowing the execution of commands immediately following application selection or detection.&lt;/p>
&lt;p>This principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.&lt;/p>
&lt;p>Several targets can be defined by the application according to the different customer cards expected.&lt;/p>
&lt;p>The &lt;strong>default selection&lt;/strong> principle consists in providing an observable reader with a set of selection cases corresponding to the expected cards and receiving notifications containing not only the card identification but also the result of all additional commands that the application will have attached.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#card-selection">More information&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="abstract-smart-card">Abstract smart card&lt;/h2>
&lt;p>The &lt;strong>abstract smart card&lt;/strong> concept is used by specific extensions (e.g. &lt;strong>Keyple Calypso&lt;/strong>) and by the &lt;strong>Keyple Core&lt;/strong> selection mechanism.
It corresponds to an abstract container model implemented by the extension specific to a card type and returned by the selection process.&lt;/p>
&lt;p>This container will be able to carry all the useful information known about the card.&lt;/p>
&lt;p>Note: this concept, mentioned here for understanding, should not appear to the application developer if he uses a card extension.&lt;/p>
&lt;p>&lt;a href="../../docs-1.0/architecture/keyple-core/#card-selection">More information&lt;/a>&lt;/p></description></item><item><title>Standalone application</title><link>https://keyple.org/docs-1.0/developer-guide/standalone-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/standalone-application/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A standalone application is an application that runs in a device in contact
with the end user.&lt;/p>
&lt;p>It has at least one local smart card reader and manages itself the
interaction with the user.&lt;/p>
&lt;p>In the ticketing industry, it is typically the software that runs a
validator, a vending machine or a control terminal.&lt;/p>
&lt;p>The diagram below illustrates the organization of the local standalone
components:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="archive-1.0/standalone-application/component/Local_Application_Components_Overview.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;hr>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read the &lt;a href="../../docs-1.0/developer-guide/common-concepts/">common concepts&lt;/a> page and become familiar with the basic
concepts on which Keyple is based.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the
implementation of &lt;strong>Keyple Core&lt;/strong>, please study the
&lt;a href="#workflow">workflow&lt;/a> proposed in the following chapter.&lt;/li>
&lt;li>Explore the &lt;a href="#keyplecoreapi">Keyple Core API&lt;/a> to discover all the
possibilities offered by &lt;strong>Keyple Core&lt;/strong>.&lt;/li>
&lt;li>Take inspiration from the &lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the &lt;a href="https://keyple.org/docs-1.0/build-your-first-app/">Build your first app&lt;/a> section to configure your
environment.&lt;/li>
&lt;li>Using the &lt;a href="https://keyple.org/components-java-1.0/">Java components&lt;/a> or &lt;a href="https://keyple.org/components-cpp-0.9/">C++ components&lt;/a> pages, import
&lt;strong>Keyple Core&lt;/strong> into your project and start playing with Keyple.&lt;/li>
&lt;li>Don&amp;rsquo;t forget to explore the potential of Keyple card-specific
extensions such as &lt;strong>Keyple Calypso&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="workflow">Workflow&lt;/h2>
&lt;p>&lt;strong>Keyple Core&lt;/strong> is built around the concepts described &lt;a href="../../docs-1.0/developer-guide/common-concepts/">here&lt;/a> and sometimes proposes several ways to perform
an action or to achieve a result depending on the needs of the
application.&lt;/p>
&lt;p>The purpose of this section is to guide you in its use.&lt;/p>
&lt;h3 id="creation-of-the-smart-card-service">Creation of the Smart Card Service&lt;/h3>
&lt;p>This is the very first step in the realization of a Keyple application:&lt;/p>
&lt;pre>&lt;code class="language-java">/* Get the instance of the SmartCardService */
SmartCardService smartCardService = SmartCardService.getInstance();
&lt;/code>&lt;/pre>
&lt;p>The Smart Card Service is based on the SmartCardService object, which is
a singleton that must be held by the application all along its
execution.&lt;/p>
&lt;p>Its main role is to centralize Keyple resources and manage their
lifecycle.&lt;/p>
&lt;h3 id="choose-the-plugin">Choose the plugin&lt;/h3>
&lt;p>The Keyple application developer will choose the plugins he needs
according to the equipment on which his Keyple application will run.&lt;/p>
&lt;p>For example, if the environment is PC based, one will probably, but
without obligation, go for the PC/SC plugin.&lt;/p>
&lt;p>For an Andoid terminal environment, the plugin could be the standard
Android NFC plugin or one of the plugins available from the industrial
partners of the project. For a complete list of available plugins,
please see the &lt;a href="https://keyple.org/components-java-1.0/">Java&lt;/a> or &lt;a href="https://keyple.org/components-cpp-0.9/">C++&lt;/a> pages.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A new plugin can also be &lt;a href="../../docs-1.0/developer-guide/create-plugin/">created&lt;/a> if the envisaged hardware does not yet have its
plugin.
&lt;/div>
&lt;/div>
&lt;h3 id="register-the-plugin">Register the plugin&lt;/h3>
&lt;p>All Keyple plugins implement the &lt;code>Plugin&lt;/code> interface.&lt;/p>
&lt;p>The plugin registration consists in submitting its factory to the Smart
Card Service.&lt;/p>
&lt;pre>&lt;code class="language-java">/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, readerExceptionHandlerImpl));
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
&lt;p>The plugin factories all implement the interface expected by
SmartCardService.&lt;/p>
&lt;p>Depending on the case, the constructor of the factory provided by the
plugin can take parameters as argument.&lt;/p>
&lt;p>For example, in the code above, the PC/SC plugin expects exception
handlers, but in other cases it could be other parameters.&lt;/p>
&lt;/div>
&lt;/div>
&lt;h3 id="observation-of-the-plugin">Observation of the plugin&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The notion of plugin observation applies only to
hardware environments in which the readers are removable.
&lt;/div>
&lt;/div>
&lt;p>The observation of reader connections and disconnections is achieved
through a background task managed by &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;p>It is therefore imperative to provide an exception handler to allow
&lt;strong>Keyple Core&lt;/strong> to warn the application in case of an execution error
during monitoring or event notification.&lt;/p>
&lt;p>Here is an example of exception handler implementation in a PC/SC plugin
context:&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class PluginExceptionHandlerImpl implements PluginObservationExceptionHandler {
@Override
public void onPluginObservationError(String pluginName, Throwable throwable) {
logger.error(&amp;quot;An unexpected plugin error occurred: {}&amp;quot;, pluginName, throwable);
}
}
}
/* Create an exception handler for plugin observation */
PluginExceptionHandlerImpl pluginExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, null));
...
&lt;/code>&lt;/pre>
&lt;p>For the observation of the plugin itself, the application must provide
an object implementing the &lt;code>PluginObserver&lt;/code> interface to the plugin
after having cast it in &lt;code>ObservablePlugin&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservablePlugin) plugin).addObserver(new PluginObserver());
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PluginObserver&lt;/code> interface requires the implementation of the
&lt;code>update&lt;/code> method that will be called by Keyple Core when notifying
plugin events.&lt;/p>
&lt;pre>&lt;code class="language-java">class PluginObserver implements ObservablePlugin.PluginObserver {
@Override
public void update(PluginEvent event) {
switch (event.getEventType()) {
case READER_CONNECTED:
// here the processing to be done when a reader is connected
...
break;
case READER_DISCONNECTED:
// here the processing to be done when a reader is disconnected
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-the-reader">Retrieve the reader&lt;/h3>
&lt;p>Readers are objects implementing the &lt;code>Reader&lt;/code> interface and are
returned by the plugin&amp;rsquo;s &lt;code>getReader&lt;/code> method taking the name of the
reader as argument.&lt;/p>
&lt;p>The names of the readers available from the plugin are returned as a
list of strings by the &lt;code>getReaderNames&lt;/code> method.&lt;/p>
&lt;p>The &lt;code>getReaders&lt;/code> method also allows to retrieve all readers in a Map
whose key is the name of the reader and the value the &lt;code>Reader&lt;/code>
object.&lt;/p>
&lt;p>Here is an example to get the 1st PC/SC reader:&lt;/p>
&lt;pre>&lt;code class="language-java">String readerName = plugin.getReaderNames().get(0);
Reader reader = plugin.getReader(readerName);
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Depending on the type of plugin, the reader names are
more or less dynamic (e.g. a PC/SC based system vs. an embedded
terminal), it is sometimes necessary to implement an identification
mechanism in order to assign the right reader to the right place in the
system (for example by using regular expressions).
&lt;/div>
&lt;/div>
&lt;h3 id="customize-the-reader-settings">Customize the reader settings&lt;/h3>
&lt;p>Take a close look at the parameters proposed by the plugin and its
readers.&lt;/p>
&lt;p>In particular, it is necessary to configure the expected communication
protocols, but it is also possible that other settings exist depending
on the hardware context.&lt;/p>
&lt;h3 id="observation-of-the-reader">Observation of the reader&lt;/h3>
&lt;p>The observation of inserting and removing cards from readers is similar
to the observation of plugins in that it requires the same operations,
i.e. the use of an exception handler and an object implementing a
dedicated interface.&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class ReaderExceptionHandlerImpl implements ReaderObservationExceptionHandler {
@Override
public void onReaderObservationError(String pluginName, String readerName, Throwable throwable) {
logger.error(&amp;quot;An unexpected reader error occurred: {}:{}&amp;quot;, pluginName, readerName, throwable);
}
}
}
/* Create an exception handler for reader observation */
ReaderExceptionHandlerImpl readerExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, readerExceptionHandlerImpl));
...
&lt;/code>&lt;/pre>
&lt;p>The observation of the events of the reader is done in a similar way to
that of the plugin, by adding an observer:&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservableReader) reader).addObserver(new ReaderObserver());
&lt;/code>&lt;/pre>
&lt;p>and implementing the ReaderObserver interface:&lt;/p>
&lt;pre>&lt;code class="language-java">class ReaderObserver implements ObservableReader.ReaderObserver {
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_INSERTED:
// here the processing to be done when a card is inserted
...
break;
case CARD_MATCHED:
// here the processing to be done when a card matched the selection
...
break;
case CARD_REMOVED:
// here the processing to be done when a card is removed
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Observation of the readers is optional in Keyple. It
facilitates an event-driven programming mode, but an application
developer can choose not to observe a reader, either because this reader
is not designed to manage card insertions/withdrawals (for example an
Android OMAPI reader or a SAM reader), or because the application is
designed to directly manage the presence of a card (refer to the
&lt;code>Reader&lt;/code> interface).
&lt;/div>
&lt;/div>
&lt;h3 id="card-selection">Card selection&lt;/h3>
&lt;p>The card selection service offered by &lt;strong>Keyple Core&lt;/strong> gives multiple
possibilities to choose the processing according to the type of card
presented to the reader.&lt;/p>
&lt;p>It is based on a filtering process according to three possible criteria,
each of which is optional:&lt;/p>
&lt;ul>
&lt;li>the communication protocol of the card (usually also identifying a
card technology)&lt;/li>
&lt;li>the answer to reset of the card (ATR)&lt;/li>
&lt;li>the ISO standardized application identifier (AID)&lt;/li>
&lt;/ul>
&lt;p>Each of these criteria can be defined in a &lt;code>CardSelector&lt;/code> object.&lt;/p>
&lt;p>When a card is inserted, it is evaluated according to these criteria and
will be given the status &amp;ldquo;selected&amp;rdquo; or not.&lt;/p>
&lt;p>When a card is not selected, no other operation will be possible with
it. Depending on the chosen setting, the result of the selection will or
will not be made available to the application. It is thus possible to
directly ignore cards that do not correspond to the defined selection
criteria.&lt;/p>
&lt;p>When a card is selected, the result is an object that extends the
AbstractSmartCard and contains all the information known about the card
at that stage.&lt;/p>
&lt;p>In the case of a ISO standardized card, the application is selected with
the provided AID (additional settings are available to specify the
desired navigation within the card applications list).&lt;/p>
&lt;p>In addition to the selection process itself, specific APDU commands can
be sent to the card if the selection is successful. The output data of
these commands are available in the instance of the object
&lt;code>AbstractSmarCard&lt;/code>.&lt;/p>
&lt;p>The &lt;code>CardSelector&lt;/code> and the additional APDU commands are grouped in a
&lt;code>CardSelectionRequest&lt;/code> object.&lt;/p>
&lt;p>One or more &lt;code>CardSelectionRequest&lt;/code> can be set up to perform as many
selection cases, each targeting a particular card or application.&lt;/p>
&lt;p>The final selection process takes as input a list of
&lt;code>CardSelectionRequest&lt;/code> and gets in return a list of
&lt;code>CardSelectionResponse&lt;/code>.&lt;/p>
&lt;h4 id="card-selection-steps">Card selection steps&lt;/h4>
&lt;p>In this guide we will not show the addition of supplementary APDU
commands. Please refer to the Calypso guide for an implementation
example.&lt;/p>
&lt;h5 id="create-the-card-selection-service">Create the card selection service&lt;/h5>
&lt;p>The card selection service will be used all along the card search
process.&lt;/p>
&lt;pre>&lt;code class="language-java"> cardSelectionService = new CardSelectionsService();
&lt;/code>&lt;/pre>
&lt;h5 id="create-the-selection-cases">Create the selection cases&lt;/h5>
&lt;p>The application can create as many selection cases as the type of cards
expected. The order in which the selection cases are prepared is
important because it will favor the latency delay for the processing of
the cards corresponding to the first case. It is therefore recommended
to place the most common card profile in the application context first.&lt;/p>
&lt;pre>&lt;code class="language-java">/** Create a new class extending AbstractCardSelection */
public final class GenericCardSelection extends AbstractCardSelection {
public GenericCardSelection(CardSelector cardSelector) {
super(cardSelector);
}
@Override
protected AbstractSmartCard parse(CardSelectionResponse cardSelectionResponse) {
class GenericSmartCard extends AbstractSmartCard {
public GenericSmartCard(CardSelectionResponse cardSelectionResponse) {
super(cardSelectionResponse);
}
public String toJson() {
return &amp;quot;{}&amp;quot;;
}
}
return new GenericSmartCard(cardSelectionResponse);
}
}
final String aid1 = &amp;quot;AABBCCDDEE&amp;quot;;
final String aid2 = &amp;quot;EEDDCCBBAA&amp;quot;;
// first selection case targeting cards with AID1
GenericCardSelection cardSelector1 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid1).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector1);
// first selection case targeting cards with AID1
GenericCardSelection cardSelector2 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid2).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector2);
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-a-non-observable-reader">Proceed to the selection with a non-observable reader&lt;/h5>
&lt;p>The &lt;code>processExplicitSelections&lt;/code> method of &lt;code>CardSelectionService&lt;/code>
performs the actual communication with the card.&lt;/p>
&lt;pre>&lt;code class="language-java">...
// Check if a card is present in the reader
if (!reader.isCardPresent()) {
logger.error(&amp;quot;No Po Card is present in the reader.&amp;quot;);
return;
}
// Actual card communication: operate through a single request the card selection
CardSelectionsResult cardSelectionsResult =
cardSelectionsService.processExplicitSelections(reader);
...
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-an-observable-reader">Proceed to the selection with an observable reader&lt;/h5>
&lt;p>In the case of an observable reader, the selection request is provided
to the reader (it is then named Default Selection) and will be processed
automatically as soon as a card is presented. The application is then
notified of the event with the data resulting from the selection.
Depending on the selection settings, the application will be notified of
all card presentations (&lt;code>CARD_INSERTED&lt;/code> event) or only those
presentations that led to a successful selection (&lt;code>CARD_MATCHED&lt;/code>
event).&lt;/p>
&lt;h6 id="add-a-default-selection">Add a default selection&lt;/h6>
&lt;pre>&lt;code class="language-java">// Provide the Reader with the selection operation to be processed when a card is inserted.
((ObservableReader) reader)
.setDefaultSelectionRequest(
cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(),
ObservableReader.NotificationMode.MATCHED_ONLY,
ObservableReader.PollingMode.REPEATING);
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>NotificationMode&lt;/code> allows you to specify whether all card
insertions should be reported to the application or only those that led
to a successful selection.&lt;/p>
&lt;p>&lt;code>PollingMode&lt;/code> indicates whether to go back to waiting for the card
after processing (&lt;code>REPEATING&lt;/code>) or let the application decide when to
restart the search (&lt;code>SINGLESHOT&lt;/code>) with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;p>Note: when the default selection is set with the &lt;code>PollingMode&lt;/code>
parameter, the card detection is started automatically. However, it is
possible to set a default selection without automatic start and by
starting the detection independently with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;h6 id="receive-the-result-as-an-event">Receive the result as an event&lt;/h6>
&lt;pre>&lt;code class="language-java">...
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_MATCHED:
AbstractSmartCard selectedCard = null;
try {
selectedCard =
getDefaultSelection()
.processDefaultSelectionsResponse(event.getDefaultSelectionsResponse())
.getActiveSmartCard();
} catch (KeypleException e) {
logger.error(&amp;quot;Exception: {}&amp;quot;, e.getMessage());
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
if (selectedCard != null) {
logger.info(&amp;quot;Observer notification: the selection of the card has succeeded.&amp;quot;);
// insert the processing of the card here
...
logger.info(&amp;quot;= #### End of the card processing.&amp;quot;);
} else {
logger.error(
&amp;quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
}
break;
case CARD_INSERTED:
logger.error(
&amp;quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
break;
case CARD_REMOVED:
logger.trace(&amp;quot;There is no PO inserted anymore. Return to the waiting state...&amp;quot;);
break;
default:
break;
}
if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED
|| event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) {
// Informs the underlying layer of the end of the card processing, in order to manage the
// removal sequence.
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
}
...
&lt;/code>&lt;/pre>
&lt;h5 id="get-the-selection-result">Get the selection result&lt;/h5>
&lt;p>The result of the selection is available in the &lt;code>AbstractSmartCard&lt;/code>
object.&lt;/p>
&lt;pre>&lt;code class="language-java">...
if (!cardSelectionsResult.hasActiveSelection()) {
logger.warn(&amp;quot;The selection of the application &amp;quot; + cardAid + &amp;quot; failed.&amp;quot;);
}
AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard();
logger.info(&amp;quot;The selection of the card has succeeded.&amp;quot;);
if (smartCard.hasFci()) {
String fci = ByteArrayUtil.toHex(smartCard.getFciBytes());
logger.info(&amp;quot;Application FCI = {}&amp;quot;, fci);
}
if (smartCard.hasAtr()) {
String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes());
logger.info(&amp;quot;Card ATR = {}&amp;quot;, atr);
}
...
&lt;/code>&lt;/pre>
&lt;h3 id="implementation-of-the-application-service">Implementation of the application service&lt;/h3>
&lt;p>The applicative processing of the card that follows the selection of the
card is to be inserted in the processing of the &lt;code>CARD_INSERTED&lt;/code> or
&lt;code>CARD_MATCHED&lt;/code> event.&lt;/p>
&lt;p>It can be processed in the thread provided by the monitoring task or
detached in a separate thread. The application developer must pay
attention to the handling of exceptions in this part of the application.
Indeed, in case of a runtime exception, the information will be given to
the application via the exception handler configured beforehand.&lt;/p>
&lt;h3 id="stopping-the-application">Stopping the application&lt;/h3>
&lt;p>The clean shutdown of a Keyple application requires the release of
resources and in particular the shutdown of the observation threads.&lt;/p>
&lt;p>This is done by unregistering the plugins in the following way:&lt;/p>
&lt;pre>&lt;code class="language-java">smartCardService.unregisterPlugin(plugin.getName());
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="keyple-core-api">Keyple Core API&lt;/h2>
&lt;p>To learn all the details of the &lt;strong>Keyple Core&lt;/strong> API, please consult the
&lt;a href="https://keyple.org/docs-1.0/api-reference/">Javadoc documentation&lt;/a>.&lt;/p>
&lt;p>However, here are two diagrams showing the main features of Keyple Core:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the
&lt;strong>Smart Card Service&lt;/strong> with in particular the observation mechanisms.
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="archive-1.0/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The diagram below represents the main classes used for selection
operations.
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="archive-1.0/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>To help in the implementation of the different facilities offered by
Keyple to process smart cards, a set of examples is present in the
project repository
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone" target="_blank" rel="noopener">
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i> examples&lt;/a>&lt;/p>
&lt;p>Nevertheless, you will find below a brief description of them:&lt;/p>
&lt;h3 id="explicit-selection">Explicit Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection without observing the
reader, based on testing the presence of the card by the application.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase1_ExplicitSelectionAid" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="default-selection">Default Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection with observation of the
reader. A default selection is prepared, the presentation of a card
triggers the notification of a reader event to the application.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase2_DefaultSelectionNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="sequential-multiple-selection">Sequential Multiple Selection&lt;/h3>
&lt;p>Executes successively several independent selection operations with the
use of the ISO &amp;lsquo;NEXT&amp;rsquo; navigation flag.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase3_SequentialMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;p>Illustrates the case of a card exploration with maintenance of the physical channel open.&lt;/p>
&lt;h3 id="grouped-multiple-selection">Grouped Multiple Selection&lt;/h3>
&lt;p>Executes a multiple selection with logical channel closure between each
selection.&lt;/p>
&lt;p>Allows the exploration of the applications of a card in a single
operation but without selection at the end.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase4_GroupedMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-card-protocol-detection">Demo Card Protocol Detection&lt;/h3>
&lt;p>Demonstrates the use of Keyple in a context where several card
technologies are likely to be processed by the application.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_CardProtocolDetection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-observable-reader-notification">Demo Observable Reader Notification&lt;/h3>
&lt;p>Demonstrates the use of Keyple to implement the observation of a plugin
and its readers. Readers are dynamically created and an observer is
assigned to them.&lt;/p>
&lt;p>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_ObservableReaderNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>The artifact &lt;strong>Keyple Core&lt;/strong> and how to integrate it into your
application is available here:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://keyple.org/components-java-1.0/core/">Keyple Core Java component&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://keyple.org/components-cpp-0.9/core/">Keyple Core C++ component&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Distributed application</title><link>https://keyple.org/docs-1.0/developer-guide/distributed-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/distributed-application/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Keyple provides the &amp;ldquo;Keyple Distributed&amp;rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal&lt;/strong>.&lt;/p>
&lt;p>In this way, you can manage transactions within a distributed architecture.&lt;/p>
&lt;p>The diagram below shows the role of the &lt;strong>Keyple Distributed&lt;/strong> components in the software layers used in a distributed architecture :&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/component/Distributed_Component_Overview.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;hr>
&lt;h2 id="how-to-use-it-">How to use it ?&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read page &lt;a href="../../docs-1.0/developer-guide/standalone-application/">Standalone application&lt;/a> to understand the main concepts of Keyple in a standalone application.&lt;/li>
&lt;li>Read chapter &lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/li>
&lt;li>Read the introduction of chapter &lt;a href="#configuration-modes">Configuration modes&lt;/a> to be informed about the different features and APIs proposed by the solution.&lt;/li>
&lt;li>Using chapter &lt;a href="#use-cases">Use cases&lt;/a>, find your use case. This will help you to determine exactly which library and API to use.&lt;/li>
&lt;li>Using chapter &lt;a href="#download">Download&lt;/a>, import into your project the libraries specified by your use case.&lt;/li>
&lt;li>Using chapter &lt;a href="#network-configuration">Network configuration&lt;/a>, implement the transport layer adapted to your network configuration.&lt;/li>
&lt;li>Implement your ticketing services as specified in the associated use case.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this user guide :&lt;/p>
&lt;div id="concepts-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Concept&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Remote Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-remote&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-local&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-network&lt;/code>.&lt;br>This library is &lt;strong>implicitly&lt;/strong> imported by &lt;strong>Remote Lib&lt;/strong> and &lt;strong>Local Lib&lt;/strong> because it contains common network elements.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple plugin which provides only &lt;strong>Remote Readers&lt;/strong> to the application. It manages data exchanges with the &lt;strong>Local Service&lt;/strong>. This plugin must be registered to the smart card service like any Keyple plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Reader&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Plugin&lt;/strong>, this is a Keyple reader which has some specificities :&lt;br>- each remote reader is connected to a local reader ;&lt;br>- any command sent by the application to a remote reader will be forwarded to the associated local reader ;&lt;br>- any event occurs on a local reader or plugin will be forwarded to the associated remote reader or plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Local Lib&lt;/strong>, this service ensures data exchange between the &lt;strong>Remote Plugin&lt;/strong> and local plugins and readers. It must be initialized and started by the host application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific factory class to initialize them.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific utility class to access them everywhere in the code.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each are bind to a specific internal node which is responsible for the interfacing with the &lt;strong>Network Endpoint&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Endpoint&lt;/strong>&lt;/td>
&lt;td>At the user&amp;rsquo;s charge, this component ensures the network exchanges between the &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> nodes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#concepts-table-1 table th:first-of-type {
width: 130px;
}
&lt;/style>
&lt;p>The diagram below illustrates the main functional concepts through a standard use case :&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/component/Distributed_Component_Concepts_1.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.&lt;/p>
&lt;p>These could be for example a ticketing reloading service, where the business logic would be on the terminal with remote readers, with thin clients on A &amp;amp; B terminals communicating locally with the cards.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for card communication.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/component/Distributed_Component_Concepts_2.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>Here is another example, but this time it illustrates several &lt;strong>Remote Plugin&lt;/strong> components connected to the same &lt;strong>Local Service&lt;/strong>.&lt;/p>
&lt;p>These could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for SAM communication.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/component/Distributed_Component_Concepts_3.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;hr>
&lt;h2 id="configuration-modes">Configuration modes&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution provides &lt;strong>3&lt;/strong> different configuration modes, each one having a specific &lt;a href="#apis">API&lt;/a> designed on a &lt;strong>Client-Server&lt;/strong> model :&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Configuration mode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="#reader-client-side">Reader Client Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="#reader-server-side">Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 190px;
}
&lt;/style>
&lt;p>Each mode provides a different &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components and their associated factories and utility classes.&lt;/p>
&lt;p>Each &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> has a default name, but it&amp;rsquo;s possible to specify a custom name during the initialization phase.&lt;/p>
&lt;p>In an application, it is thus possible to use simultaneously several configuration modes and as many instances of a configuration mode as you want, as long as the components are initialized with different names.&lt;/p>
&lt;h3 id="reader-client-side">Reader Client Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClient&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory by providing the network and plugin observer implementation. Please note that &lt;strong>this plugin is observable only to trigger ticketing services&lt;/strong> on the server side, but does not allow observation on the local plugin (reader insertion, etc&amp;hellip;),&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>await for events of type &lt;code>PluginEvent.READER_CONNECTED&lt;/code>,&lt;/li>
&lt;li>when an event occurs, get the specified remote reader from the &lt;strong>Remote Plugin&lt;/strong>,&lt;/li>
&lt;li>use information inside the remote reader to identify the ticketing service to execute,&lt;/li>
&lt;li>execute the specified ticketing service using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service and get the local reader to connect to the server,&lt;/li>
&lt;li>execute the remote service using the &lt;strong>Local Service&lt;/strong> API by indicating the ticketing service id to execute and transmitting to the server if needed personal information or smart card content previously read.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="illustration">ILLUSTRATION&lt;/h4>
&lt;p>The following sequence diagram shows the capabilities of the plugin through an arbitrary example that illustrates :&lt;/p>
&lt;ul>
&lt;li>the initialization phase of the local and remote components ;&lt;/li>
&lt;li>the registration of the local plugin and observable reader ;&lt;/li>
&lt;li>the selection phase of an observable reader carried out directly by the client ;&lt;/li>
&lt;li>the sending of the selection result and additional information to the server to remotely perform a specific ticketing service (materialization, validation, etc&amp;hellip;) ;&lt;/li>
&lt;li>the reception by the server of the transmitted data ;&lt;/li>
&lt;li>the execution of the remote ticketing service ;&lt;/li>
&lt;li>the server subscription to observable reader events ;&lt;/li>
&lt;li>the sending of information to the client at the end of processing.&lt;/li>
&lt;/ul>
&lt;p>Note that the network layer is deliberately hide in this diagram. Its implementation is described in the &lt;a href="#network-configuration">Network configuration&lt;/a> chapter.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/sequence/Distributed_Sequence_ReaderClientSide_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h3 id="reader-server-side">Reader Server Side&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
This configuration mode will only be available from version &lt;strong>1.1&lt;/strong> onwards.
&lt;/div>
&lt;/div>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/p>
&lt;p>It also allows to observe the plugin events (such as reader connection, etc&amp;hellip;) if desired.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code> or&lt;br>&lt;code>ObservableRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-1">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local plugin (or observable plugin) with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="pool-reader-server-side">Pool Reader Server Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-2">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local pool plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local pool plugin with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="use-cases">Use cases&lt;/h2>
&lt;p>Here is a summary table of all proposed use cases. Search for the one that corresponds to your need and then look at the associated description :&lt;/p>
&lt;div id="use-cases-table-2">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Use Case&lt;/th>
&lt;th style="text-align:center">Reader type&lt;/th>
&lt;th style="text-align:center">Reader endpoint&lt;/th>
&lt;th style="text-align:center">Reader observation&lt;/th>
&lt;th style="text-align:center">Plugin observation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-1">UC 1&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-2">UC 2&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-3">UC 3&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-4">UC 4&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-5">UC 5&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-6">UC 6&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="#uc-7">UC 7&lt;/a>&lt;/td>
&lt;td style="text-align:center">Pool&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#use-cases-table-2 table th:nth-of-type(6) {
width: 240px;
}
&lt;/style>
&lt;h4 id="uc-1">UC 1&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the client side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>RemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-2">UC 2&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withReaderObservation(...)&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableRemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>To observe &amp;ldquo;remotely&amp;rdquo; the reader events, you must :&lt;/p>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>register at least one observer to the remote reader created during the first client call and await for reader events,&lt;/li>
&lt;li>retrieve the remote reader from the &lt;strong>Remote Plugin&lt;/strong> &lt;strong>imperatively&lt;/strong> using the reader name contained in the received event,&lt;/li>
&lt;li>execute the ticketing service associated to the event using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service associated to the event using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>execute a remote service first in order to connect a remote reader to the local reader and to allow the remote application to subscribe to the events of the remote reader.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="uc-3">UC 3&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-4">UC 4&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-5">UC 5&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-6">UC 6&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-7">UC 7&lt;/h4>
&lt;p>This use case requires to use the &lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a> configuration mode.&lt;/p>
&lt;p>This unique mode proposed for this plugin does not allow to observe the local reader.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="network-configuration">Network configuration&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution &lt;strong>does not provide&lt;/strong> the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components.&lt;/p>
&lt;h3 id="synchronous">Synchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Client-Server &lt;strong>Synchronous&lt;/strong> communication protocol, such as standard HTTP for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>SyncEndpointClient&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>SyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>SyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withSyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>getSyncNode()&lt;/code> or&lt;br> &lt;code>getSyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement in a context with a &lt;strong>single server instance&lt;/strong> :&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/sequence/Distributed_Sequence_SyncNode_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a &lt;code>serverNodeId&lt;/code> are routed to the server associated with a &lt;code>SyncNodeServer&lt;/code> node having the &lt;code>serverNodeId&lt;/code>.&lt;/p>
&lt;h3 id="asynchronous">Asynchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Full-Duplex &lt;strong>Asynchronous&lt;/strong> communication protocol, such as Web Sockets for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>AsyncEndpointClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncEndpointServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>AsyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement :&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/sequence/Distributed_Sequence_AsyncNode_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h3 id="exchanged-data">Exchanged data&lt;/h3>
&lt;p>The data exchanged between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components are contained in the DTO (Data Transfer Object) &lt;code>MessageDto&lt;/code>. It is built and processed by the plugin and &lt;strong>you don&amp;rsquo;t need to modify it&lt;/strong>.&lt;/p>
&lt;p>However, it is necessary in some contexts to access certain information such as the &lt;code>sessionId&lt;/code> in the case of asynchronous communication or the &lt;code>serverNodeId&lt;/code> in the case of synchronous communication with several server instances.&lt;/p>
&lt;hr>
&lt;h2 id="apis">APIs&lt;/h2>
&lt;p>The class diagrams below shows the different APIs exposed and SPIs required by the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/p>
&lt;p>An &lt;strong>SPI&lt;/strong> (Service Provider Interface) is an interface that must be implemented by the user.&lt;/p>
&lt;p>Here are the available APIs depending on the library imported by your project :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th style="text-align:center">Remote Lib&lt;/th>
&lt;th style="text-align:center">Local Lib&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="#network-api">Network API&lt;/a>&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="#remote-api">Remote API&lt;/a>&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="#local-api">Local API&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">✔️&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The associated &lt;strong>API&lt;/strong> documentations are accessible from the page &lt;a href="https://keyple.org/docs-1.0/api-reference/">API Reference&lt;/a>.&lt;/p>
&lt;h3 id="network-api">Network API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-network/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/class/Distributed_Class_Network_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h3 id="remote-api">Remote API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-remote/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/class/Distributed_Class_Remote_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h3 id="local-api">Local API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-local/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/distributed-application/class/Distributed_Class_Local_API.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/distributed" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://keyple.org/components-java-1.0/distributed-systems/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso application</title><link>https://keyple.org/docs-1.0/developer-guide/calypso-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/calypso-application/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>Keyple API was designed to support an extension system. On top of &lt;strong>Keyple Core&lt;/strong>, APIs can be developed to extend
Keyple features. For example, Calypso Network Association provides &lt;strong>Keyple Calypso Extension&lt;/strong>.&lt;/p>
&lt;p>The use of &lt;strong>Keyple Calypso Extension&lt;/strong> open the ability to operate commands with a Calypso Portable Object and to manage a
secure Calypso transaction seamlessly. It completely hides the details of the APDU commands that are sent to POs and SAMs, which are usually tedious operations.&lt;/p>
&lt;p>The diagram below shows the role of the &lt;strong>Keyple Calypso Extension&lt;/strong> components in the software layers for a standalone application :&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../media/archive-1.0/calypso-app-development/component/Local_Component_Overview.svg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, have knowledge of the standard Calypso.&lt;/li>
&lt;li>Read the &lt;a href="../../docs-1.0/developer-guide/common-concepts/">common concepts&lt;/a> page and become familiar with the basic concepts on which Keyple is based.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the implementation of &lt;strong>Keyple Core&lt;/strong>, please study the &lt;a href="../../docs-1.0/developer-guide/standalone-application/">workflow&lt;/a> proposed in Standalone application guide.&lt;/li>
&lt;li>Read chapter &lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Calypso Extension&lt;/strong> API.&lt;/li>
&lt;li>Explore the &lt;a href="#keyplecalypsoapi">Keyple Calypso API&lt;/a> to discover all the possibilities offered by &lt;strong>Keyple Calypso Extension&lt;/strong>.&lt;/li>
&lt;li>Take inspiration from the &lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the &lt;a href="https://keyple.org/docs-1.0/build-your-first-app/">Build your first app&lt;/a> section to configure your environment.&lt;/li>
&lt;li>Using the &lt;a href="https://keyple.org/components-java-1.0/core/">Java components&lt;/a> or &lt;a href="https://keyple.org/components-cpp-0.9/core/">C++ components&lt;/a> pages, import &lt;strong>Keyple Core&lt;/strong> into your project.&lt;/li>
&lt;li>Using the &lt;a href="https://keyple.org/components-java-1.0/extensions/calypso/">Java components&lt;/a> or &lt;a href="https://keyple.org/components-cpp-0.9/extensions/calypso/">C++ components&lt;/a> pages, import &lt;strong>Keyple Calypso Extension&lt;/strong> into your project.&lt;/li>
&lt;li>Start playing with Keyple.&lt;/li>
&lt;/ol>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this user guide :&lt;/p>
&lt;h3 id="calypso-po">Calypso PO&lt;/h3>
&lt;p>Concentrates all known information about the Personal Object being processed. Accessible information are&lt;/p>
&lt;ul>
&lt;li>The application identification fields (revision/version, class, DF name, serial number, ATR, issuer)&lt;/li>
&lt;li>The indication of the presence of optional features (Stored Value, PIN, Rev3.2 mode, ratification management)&lt;/li>
&lt;li>The management information of the session modifications buffer&lt;/li>
&lt;li>The invalidation status&lt;/li>
&lt;li>The files, counters, SV data read or modified during the execution of the processes defined by PoTransaction&lt;/li>
&lt;/ul>
&lt;p>The Calypso PO fields are first populated from the CardSelectionResponse obtained through the PO selection process then each time a PoTransaction &amp;ldquo;process&amp;rdquo; method is invoked.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
//Retrieve PO's informations
String atr = calypsoPo.getAtr()
byte[] applicationSerial+Number = calypsoPo.getApplicationSerialNumber()
//SFI_EventLog = 0x08
ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog);
//SFI_EnvironmentAndHolder = 0x07
ElementaryFile efEnvironmentAndHolder =calypsoPo.getFileBySfi(SFI_EnvironmentAndHolder);
...
&lt;/code>&lt;/pre>
&lt;h3 id="elementaryfile">ElementaryFile&lt;/h3>
&lt;p>Object containing the description of a Calypso Elementary File. Can be retrieved from Calypso PO using its SFI.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog);
//Read data content of sevent log elemenatary file
String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent());
...
&lt;/code>&lt;/pre>
&lt;h3 id="calypso-sam">Calypso SAM&lt;/h3>
&lt;p>Concentrates all the informations we know about the SAM currently selected. Accessible informations are:&lt;/p>
&lt;ul>
&lt;li>The Sam Revision&lt;/li>
&lt;li>The Serial number&lt;/li>
&lt;li>The Platform identifier&lt;/li>
&lt;li>The Application Type&lt;/li>
&lt;li>The Application SubType&lt;/li>
&lt;li>The Software Issuer identifier&lt;/li>
&lt;li>The Software Version number&lt;/li>
&lt;li>The Software Revision number&lt;/li>
&lt;/ul>
&lt;p>Calypso SAM fields are populated by analysis of the ATR within a CardSelectionResponse obtained through the SAM selection process.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
byte[] serialNumber = calypsoSam.getSerialNumber()
...
&lt;/code>&lt;/pre>
&lt;h3 id="posecuritysettings">PoSecuritySettings&lt;/h3>
&lt;p>Concentrate the security settings involved in Calypso Secure Sessions:&lt;/p>
&lt;ul>
&lt;li>A reference to the SAM resource&lt;/li>
&lt;li>The default KIF&lt;/li>
&lt;li>The default KVC&lt;/li>
&lt;li>The default Key Record Number&lt;/li>
&lt;li>The modification mode&lt;/li>
&lt;li>The ratification mode&lt;/li>
&lt;li>The pin transmission mode&lt;/li>
&lt;li>The default Pin Ciphering Key&lt;/li>
&lt;li>The SV Get Log Read mode&lt;/li>
&lt;li>The SV Negative balance mode&lt;/li>
&lt;/ul>
&lt;p>The fields are populated with default values when the object is instantiated but can be customized to adjust the settings
to the application needs.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
poSecuritySettings.getSessionModificationMode()
...
&lt;/code>&lt;/pre>
&lt;p>Secure session settings can be finely tuned with PoSecuritySettings and a set of enums provided by Keyple:&lt;/p>
&lt;h4 id="modification-mode">Modification mode&lt;/h4>
&lt;p>Indicates whether the secure session can be closed and reopened to manage the limitation of the PO buffer memory (session modifications buffer).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ModificationMode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>ATOMIC&lt;/code>&lt;/strong>&lt;/td>
&lt;td>The secure session is atomic.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>MULTIPLE&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Several secure sessions will be chained (to manage the writing of large amounts of data).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre>&lt;code class="language-java"> ...
PoSecuritySettings poSecuritySettings =
new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.svGetLogReadMode(SvSettings.LogRead.ALL)
.build();
...
&lt;/code>&lt;/pre>
&lt;h4 id="ratification-mode">Ratification mode&lt;/h4>
&lt;p>The ratification mode defines the behavior of processClosing regarding the ratification process.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>RatificationMode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>CLOSE_RATIFIED&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Close session with ratification.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>CLOSE_NOT_RATIFIED&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Close session without ratification&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre>&lt;code class="language-java"> ...
PoSecuritySettings poSecuritySettings =
new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.ratificationMode(RatificationMode.CLOSE_RATIFIED)
.build();
...
&lt;/code>&lt;/pre>
&lt;h4 id="pin-transmission-mode">Pin Transmission Mode&lt;/h4>
&lt;p>Defines the PIN transmission modes: plain or encrypted.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>PinTransmissionMode&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>PLAIN&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>ENCRYPTED&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="sv-log-read-mode">SV Log Read mode&lt;/h4>
&lt;p>Specifies whether only one or both SV logs (debit and load) should be read.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>LogRead&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>SINGLE&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>ALL&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="sv-negative-balance-mode">SV Negative balance mode&lt;/h4>
&lt;p>Specifies whether POs with a negative SV balance should be accepted.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>NegativeBalance&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>FORBIDDEN&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>AUTHORIZED&lt;/code>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="basic-operations">Basic Operations&lt;/h2>
&lt;h3 id="poselection">PoSelection&lt;/h3>
&lt;p>This service provides the means to define a selection case targeting a particular PO (in the ISO 7816-4 sense) with the possibility to collect additional information about the PO before a transaction.&lt;/p>
&lt;p>It integrates with the &lt;strong>Keyple Core Card Selection&lt;/strong> service to manage the specific features of Calypso POs:&lt;/p>
&lt;ul>
&lt;li>Sends optional &lt;em>read&lt;/em> and/or &lt;em>select&lt;/em> commands to the POs right after the initial card selection.&lt;/li>
&lt;li>Produces a CalypsoPO object from the CardSelectionResponse. The object is filled with the PO identification data from the FCI and the
possible responses to additional APDU commands executed after the selection.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java"> ...
// Prepare a Calypso PO selection
CardSelectionsService cardSelectionsService = new CardSelectionsService();
// Setting of an AID based selection of a Calypso REV3 PO
// Select the first application matching the selection AID whatever the card communication
// protocol keep the logical channel open after the selection
// Calypso selection: configures a PoSelection with all the desired attributes to
// make the selection and read additional information afterwards
PoSelection poSelection =
new PoSelection(
PoSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(
CardSelector.AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build())
.invalidatedPo(PoSelector.InvalidatedPo.REJECT)
.build());
// Prepare the reading order.
poSelection.prepareReadRecordFile(
CalypsoClassicInfo.SFI_EnvironmentAndHolder, CalypsoClassicInfo.RECORD_NUMBER_1);
// Add the selection case to the current selection (we could have added other cases
// here)
cardSelectionsService.prepareSelection(poSelection);
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionsService.processExplicitSelections(poReader).getActiveSmartCard();
...
&lt;/code>&lt;/pre>
&lt;h2 id="samselection">SamSelection&lt;/h2>
&lt;p>This service provides the means to define a selection case targeting a Calypso SAM.&lt;/p>
&lt;p>It integrates with the &lt;strong>Keyple Core Card Selection&lt;/strong> service to manage the specific features of Calypso SAMs:&lt;/p>
&lt;ul>
&lt;li>optionally executes an unlock command during the selection process.&lt;/li>
&lt;li>provides an instance of Calypso SAM.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java"> ...
CardSelectionsService samSelection = new CardSelectionsService();
//Sam selection parameters
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.C1).serialNumber(&amp;quot;.*&amp;quot;).build();
samSelection.prepareSelection(new SamSelection(samSelector));
//Sam reader retrieved from registered plugin
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;Unable to open a logical channel for SAM!&amp;quot;);
}
//Cast selected card to CalypsoSam
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
...
&lt;/code>&lt;/pre>
&lt;h3 id="potransaction">PoTransaction&lt;/h3>
&lt;p>Service providing high-level API to manage transactions with a Calypso PO. The tied CalypsoPO Object is kept and updated at
each step of using this service.&lt;/p>
&lt;p>This service workflow is composed of two steps:&lt;/p>
&lt;ul>
&lt;li>Prepares the commands to be sent to the PO; several command preparations can be stacked (no communication neither with the PO nor with the SAM).&lt;/li>
&lt;li>Process the prepared commands. Performs all necessary communications with the PO and/or the SAM to carry out the previously prepared operations. CalypsoPo is updated accordingly.&lt;/li>
&lt;/ul>
&lt;p>Note:&lt;/p>
&lt;ul>
&lt;li>Regarding of commands, the presence of SAM is mandatory or not (mandatory when a &lt;em>Calypso Secure Session&lt;/em> is open).&lt;/li>
&lt;li>Pay attention to the number of commands affecting the session modifications buffer, see the &lt;em>ModificationMode&lt;/em> setting.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java"> ...
// CardResource allow management of specific card.
// In this example a SAM is available
CardResource&amp;lt;CalypsoPo&amp;gt; poResource = new CardResource&amp;lt;CalypsoPo&amp;gt;(poReader, calypsoPo);
CardResource&amp;lt;CalypsoSam&amp;gt; samResource = new CardResource&amp;lt;CalypsoPo&amp;gt;(samReader, calypsoSam);
// Configure Security settings
// Both Reload and Debit SV logs are requested
PoSecuritySettings poSecuritySettings =
new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.svGetLogReadMode(SvSettings.LogRead.ALL)
.build();
PoTransaction poTransaction = new PoTransaction(poResource, poSecuritySettings);
// Read the EventLog file at record 1 within the Session Opening
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_EventLog, CalypsoClassicInfo.RECORD_NUMBER_1);
// Open a secure session (DEBIT level) and execute the prepared command
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the EventLog data
ElementaryFile efEventLog = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_EventLog);
// Example of data parsing
String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent());
// Prepare a SV Debit (this command could also have been placed before processOpening
// since it is not followed by any other command)
poTransaction.prepareSvGet(SvSettings.Operation.DEBIT, SvSettings.Action.DO);
// Execute the prepared command
poTransaction.processPoCommands();
//Get updated sv balance
int svBalance = calypsoPo.getSvBalance()
//Get the updated SV last transaction number
int svLastTNum = calypsoPo.getSvLastTNum()
...
&lt;/code>&lt;/pre>
&lt;h4 id="secure-session-access-level">Secure Session Access level&lt;/h4>
&lt;p>PoTransaction.processOpening() allows to open a Calypso Secure Session. If commands have been prepared previously, they will be executed.&lt;/p>
&lt;p>Keyple provides an enums to easily configure the Secure Session AccessLevel:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>AccessLevel&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>SESSION_LVL_PERSO&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Session Access Level used for personalization purposes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>SESSION_LVL_LOAD&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Session Access Level used for reloading purposes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>SESSION_LVL_DEBIT&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Session Access Level used for validating and debiting purposes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="transaction-flow-and-calypso-secure-session-management">Transaction flow and Calypso Secure Session management&lt;/h4>
&lt;p>PoTransaction allows you to process a Calypso Secure session in different ways. These are difficult to describe
all in detail but here is an example from which other variants can be obtained.&lt;/p>
&lt;p>A typical Calypso PO transaction flow, for example for ticket validation, could be :&lt;/p>
&lt;ul>
&lt;li>Execute the selection of a Calypso PO and retrieves the contents of the environment file at the same time.&lt;/li>
&lt;li>Open a secure session and get the contract list&lt;/li>
&lt;li>Get the contract and associated counter&lt;/li>
&lt;li>Decrease the counter, append a new event log&lt;/li>
&lt;li>Close the secure session&lt;/li>
&lt;/ul>
&lt;p>Translated into Keyple Calypso operations, the entire transaction would include the following steps (simplified syntax):&lt;/p>
&lt;ul>
&lt;li>&lt;code>poSelection = new PoSelection(CARD_IAD)&lt;/code>&lt;/li>
&lt;li>&lt;code>poSelection.prepareReadRecordFile(ENVIRONMENT_SFI)&lt;/code>&lt;/li>
&lt;li>process the poSelection (either explicitly or by default, see the &lt;a href="../../docs-1.0/developer-guide/standalone-application/">standalone application&lt;/a>) guide&lt;/li>
&lt;li>retrieve CalypsoPo, check its content (environment data)&lt;/li>
&lt;li>&lt;code>poTransaction = new PoTransaction(calypsoPo)&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.prepareReadRecordFile(CONTRACT_LIST_SFI)&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.processOpening(DEBIT)&lt;/code>&lt;/li>
&lt;li>check CalypsoPo content (contract list), decide which contract/counter to read&lt;/li>
&lt;li>&lt;code>poTransaction.prepareReadRecordFile(CONTRACT_n)&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.prepareReadRecordFile(COUNTER_n)&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.processPoCommands()&lt;/code>&lt;/li>
&lt;li>check CalypsoPo content (contract/counter), decide action (decrease counter, append event log)&lt;/li>
&lt;li>&lt;code>poTransaction.prepareDecrease(COUNTER_n, X)&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.prepareAppendRecord(EVENT, event_data&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.prepareReleaseChannel()&lt;/code>&lt;/li>
&lt;li>&lt;code>poTransaction.processClosing()&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>Detailed use case examples can be seen here:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/src/main/java/org/eclipse/keyple/example/calypso" target="_blank" rel="noopener">PC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/android" target="_blank" rel="noopener">Android&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Create a plugin</title><link>https://keyple.org/docs-1.0/developer-guide/create-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/create-plugin/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Create an extension</title><link>https://keyple.org/docs-1.0/developer-guide/create-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/create-extension/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Upgrade from an earlier version of Keyple</title><link>https://keyple.org/docs-1.0/developer-guide/upgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs-1.0/developer-guide/upgrade/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;p>This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.&lt;/p>
&lt;p>Upgrade from:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#upgrade-from-090-to-100">0.9.0 to 1.0.0&lt;/a>&lt;/li>
&lt;li>&lt;a href="#upgrade-from-081-to-090">0.8.1 to 0.9.0&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Note: here we describe the evolutions in broad outline, for the details of the APIs, the reader is invited to consult
the &lt;a href="https://keyple.org/docs-1.0/api-reference/">API reference&lt;/a> section.&lt;/p>
&lt;hr>
&lt;h2 id="upgrade-from-090-to-100">Upgrade from 0.9.0 to 1.0.0&lt;/h2>
&lt;h3 id="whats-changed">What&amp;rsquo;s changed?&lt;/h3>
&lt;p>Compared to version 0.9, the goal of Keyple 1.0 is mainly to fix bugs,
add features to make Keyple more robust and rename/reorganize classes to make it easier to learn.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#class-renaming">Renamings&lt;/a>&lt;/li>
&lt;li>&lt;a href="#internal-exception-handling">Internal exception handling&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pcsc-plugin">PC/SC plugin&lt;/a>&lt;/li>
&lt;li>&lt;a href="#keyple-distributed">Keyple Distributed&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="class-renaming">Class renaming&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Module&lt;/th>
&lt;th>Old name (0.9.0)&lt;/th>
&lt;th>New name (1.0.0)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeProxyService&lt;/td>
&lt;td>SmartCardService&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>ReaderPlugin&lt;/td>
&lt;td>Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeReader&lt;/td>
&lt;td>Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>ReaderPoolPlugin&lt;/td>
&lt;td>PoolPlugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeSelection&lt;/td>
&lt;td>CardSelectionService&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>SeSelector&lt;/td>
&lt;td>CardSelector&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Core&lt;/td>
&lt;td>AbstractMatchingSe&lt;/td>
&lt;td>AbstractSmartCard&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Calypso&lt;/td>
&lt;td>PoSelectionRequest&lt;/td>
&lt;td>PoSelection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Keyple Calypso&lt;/td>
&lt;td>SamSelectionRequest&lt;/td>
&lt;td>SamSelection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="internal-exception-handling">Internal exception handling&lt;/h4>
&lt;p>New possibilities have been added in the management of observable objects (&lt;em>Plugin&lt;/em> and &lt;em>Reader&lt;/em>).&lt;/p>
&lt;p>If the Plugin or Reader is observable, it is now necessary to define exception handlers that will be called by the internal layers of Keyple in the case of an exception raised by an observation process.&lt;/p>
&lt;p>Two new interfaces have been added to the &lt;em>event&lt;/em> package to allow applications via the factories of the concerned plugins to define the method that will be called when needed:&lt;/p>
&lt;ul>
&lt;li>&lt;code>PluginObservationExceptionHandler&lt;/code>&lt;/li>
&lt;li>&lt;code>ReaderObservationExceptionHandler&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These handlers are usually provided by the application via the constructor of the plugin&amp;rsquo;s factory.&lt;/p>
&lt;h4 id="pcsc-plugin">PC/SC plugin&lt;/h4>
&lt;p>The generic parameterization interface for plugins and readers has been removed in favor of methods specific to each plugin.&lt;/p>
&lt;p>In the case of the PC/SC plugin, the following methods have appeared:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>PcscPlugin&lt;/td>
&lt;td>&lt;code>setReaderNameFilter&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscPlugin&lt;/td>
&lt;td>&lt;code>setProtocolIdentificationRule&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setSharingMode&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setContactless&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setIsoProtocol&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PcscReader&lt;/td>
&lt;td>&lt;code>setDisconnectionMode&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="keyple-distributed">Keyple Distributed&lt;/h4>
&lt;p>The use of Keyple in a remote context has been extensively reviewed and its description is beyond the scope of this guide. Please refer to the &lt;a href="../../docs-1.0/developer-guide/distributed-application/">distributed application&lt;/a> section.&lt;/p>
&lt;hr>
&lt;h2 id="upgrade-from-081-to-090">Upgrade from 0.8.1 to 0.9.0&lt;/h2>
&lt;h3 id="whats-changed-1">What&amp;rsquo;s changed?&lt;/h3>
&lt;p>From a user API point of view, the changes relate to the following topics:
From a user API point of view, the changes relate to the following topics:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#plugin-registration-in-the-seproxyservice">plugin registration in the SeProxyService&lt;/a>&lt;/li>
&lt;li>&lt;a href="#preparation-of-selection-cases">preparation of selection cases&lt;/a>&lt;/li>
&lt;li>&lt;a href="#retrieving-selection-results">retrieving selection results&lt;/a>&lt;/li>
&lt;li>&lt;a href="#definition-of-the-security-settings-of-the-transaction">definition of the security settings of the transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="#creation-of-the-potransaction-object">creation of the PoTransaction object&lt;/a>&lt;/li>
&lt;li>&lt;a href="#transaction-commands-preparation">transaction commands preparation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#transaction-commands-processing">transaction commands processing&lt;/a>&lt;/li>
&lt;li>&lt;a href="#retrieving-data-read-from-pos">retrieving data read from POs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#error-handling">error handling&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="plugin-registration-in-the-seproxyservice">Plugin registration in the SeProxyService&lt;/h3>
&lt;p>The &lt;code>registerPlugin&lt;/code> method of the &lt;code>SeProxyService&lt;/code> class now returns the reference of the registered plugin.&lt;/p>
&lt;p>This makes it possible, for example, to perform a reader setup in an application such as this one:&lt;/p>
&lt;pre>&lt;code class="language-java"> // Create a PcscPlugin and register it into the SeProxyService
ReaderPlugin pcscPlugin = seProxyService.registerPlugin(new PcscPluginFactory());`
// Get the PO reader from the plugin
SeReader poReader = pcscPlugin.getReader(&amp;quot;ASK LoGO 0&amp;quot;);
&lt;/code>&lt;/pre>
&lt;h3 id="preparation-of-selection-cases">Preparation of selection cases&lt;/h3>
&lt;p>The &lt;code>AidSelector&lt;/code>, &lt;code>Selector&lt;/code> and &lt;code>PoSelector&lt;/code> classes now follow the Fluent Builder pattern for better handling of optional parameters.&lt;/p>
&lt;p>The construction of an &lt;code>AidSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector appAidSelector = AidSelector.builder()
.aidToSelect(AID)
.fileControlInformation(AidSelector.FileControlInformation.FCI)
.fileOccurrence(AidSelector.FileOccurrence.FIRST)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>fileControlInformation&lt;/code> and &lt;code>fileOccurrence&lt;/code> fields are optional (shown here with their default values), so a simple version can be :&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector aidSelector = AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build();
&lt;/code>&lt;/pre>
&lt;p>The construction of a &lt;code>SeSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PoSelector&lt;/code> adds the possibility to specify that an invalidated PO should be processed&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.invalidatedPo(InvalidatedPo.ACCEPT)
.build();
&lt;/code>&lt;/pre>
&lt;p>The management of PO commands to be performed after the selection step (when it has been successful) is handled by the methods of the &lt;code>PoSelectionRequest&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>preparing to read files has been simplified and is done using the unique following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareReadRecordFile(byte sfi, int recordNumber)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>preparing to select files is done using the following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareSelectFile(byte[] lid)
public void prepareSelectFile(short lid)
&lt;/code>&lt;/pre>
&lt;p>Note that from now the &amp;ldquo;prepare&amp;rdquo; methods no longer return indexes, the data will be placed in the CalypsoPo object.&lt;/p>
&lt;h3 id="retrieving-selection-results">Retrieving selection results&lt;/h3>
&lt;p>The &lt;code>MatchingSelection&lt;/code> class no longer exists.
In the class &lt;code>SelectionsResult&lt;/code> (see &lt;code>processDefaultSelection/processExplicitSelection&lt;/code>):&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>getActiveSelection&lt;/code> is replaced by &lt;code>getActiveMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelection&lt;/code> is replaced by &lt;code>getMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (may be null if the index provided does not correspond to a successful selection case)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelections&lt;/code> now returns a Map containing a list of associated &lt;code>AbstractMatchingSe&lt;/code> with the selection index that produced it (&lt;code>Map&amp;lt;Integer, AbstractMatchingSe&amp;gt;&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>hasSelectionMatched&lt;/code> method indicates whether the selection index provided corresponds to a successful selection case&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>getActiveSelectionIndex&lt;/code> method returns the index of the active selection (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="definition-of-the-security-settings-of-the-transaction">Definition of the security settings of the transaction&lt;/h3>
&lt;p>These parameters are defined via the &lt;code>PoSecuritySettings&lt;/code> class, whose construction now follows the Fluent Builder pattern.&lt;/p>
&lt;p>All parameters are optional except the &lt;code>SamResource&lt;/code>.&lt;/p>
&lt;p>Here is an example of a complete &lt;code>PoSecuritySettings&lt;/code> build:&lt;/p>
&lt;pre>&lt;code class="language-java">poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.sessionDefaultKif(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KIF_PERSO)
.sessionDefaultKif(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KIF_LOAD)
.sessionDefaultKif(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KIF_DEBIT)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KEY_RECORD_NUMBER_PERSO)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KEY_RECORD_NUMBER_LOAD)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KEY_RECORD_NUMBER_DEBIT)
.sessionModificationMode(ModificationMode.ATOMIC)
.ratificationMode(RatificationMode.CLOSE_RATIFIED)
.sessionAuthorizedKvcList(authKvcs)
.build();
&lt;/code>&lt;/pre>
&lt;h3 id="creation-of-the-potransaction-object">Creation of the PoTransaction object&lt;/h3>
&lt;p>Since PoSecuritySettings now integrates SamResource, the construction of PoTransaction has evolved slightly.&lt;/p>
&lt;p>Here is an example:&lt;/p>
&lt;pre>&lt;code class="language-java">PoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo), poSecuritySettings);
&lt;/code>&lt;/pre>
&lt;h3 id="transaction-commands-preparation">Transaction commands preparation&lt;/h3>
&lt;p>Just as with the &amp;ldquo;prepare&amp;rdquo; commands used for selection, the &amp;ldquo;prepare&amp;rdquo; commands used for transactions no longer return indexes.&lt;/p>
&lt;p>The available commands in version 0.9 are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final void prepareSelectFile(SelectFileControl control)
public final void prepareSelectFile(short lid)
public final void prepareSelectFile(byte[] lid)
public final void prepareReadRecordFile(byte sfi, int recordNumber)
public final void prepareReadRecordFile(byte sfi, int firstRecordNumber, int numberOfRecords, int recordSize))
public final void prepareReadCounterFile(byte sfi, int countersNumber)
public final void prepareUpdateRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareWriteRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareAppendRecord(byte sfi, byte[] recordData)
public final void prepareIncreaseCounter(byte sfi, int counterNumber, int incValue)
public final void prepareDecreaseCounter(byte sfi, int counterNumber, int decValue)
&lt;/code>&lt;/pre>
&lt;h3 id="transaction-commands-processing">Transaction commands processing&lt;/h3>
&lt;p>The &amp;ldquo;process&amp;rdquo; commands have also been revised and simplified.&lt;/p>
&lt;p>They all return &lt;code>void&lt;/code>.&lt;/p>
&lt;p>In case of failure a exception is raised (see below).&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processOpening(PoTransaction.SessionSetting.AccessLevel accessLevel)
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>ModificationMode&lt;/code> is no longer required since it is integrated in the &lt;code>PoSecuritySettings&lt;/code>.&lt;/p>
&lt;p>Parameters previously used to specify that a file is read at login are removed.&lt;/p>
&lt;p>Instead, the first prepareReadFile command will be automatically taken into account.&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processPoCommands()
public final void processPoCommandsInSession()
public final void processCancel(ChannelControl channelControl)
public final void processClosing(ChannelControl channelControl)
&lt;/code>&lt;/pre>
&lt;h3 id="retrieving-data-read-from-pos">Retrieving data read from POs&lt;/h3>
&lt;p>This is a major evolution of the Keyple API. Previously, data read from Calyspo POs were retrieved by applications using &amp;ldquo;parser&amp;rdquo; methods.&lt;/p>
&lt;p>With Keyple API 0.9, Calypso PO data is made available in the CalypsoPo object obtained during selection and enriched all along the operations performed with PoTransaction.&lt;/p>
&lt;p>The public getter methods of CalypsoPo are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final String getDfName()
public final byte[] getDfNameBytes()
public final String getApplicationSerialNumber()
public final byte[] getApplicationSerialNumberBytes()
public final String getAtr()
public final String getStartupInfo()
public final PoRevision getRevision()
public final byte getSessionModification()
public final byte getApplicationType()
public final byte getApplicationSubtype()
public final byte getPlatform()
public final byte getSoftwareIssuer()
public final byte getSoftwareVersion()
public final byte getSoftwareRevision()
public final boolean isDeselectRatificationSupported()
public final boolean isConfidentialSessionModeSupported()
public final boolean isPublicAuthenticationSupported()
public final boolean isPinFeatureAvailable()
public final boolean isSvFeatureAvailable()
public final boolean isDfInvalidated()
public final boolean isDfRatified()
public final DirectoryHeader getDirectoryHeader()
public final ElementaryFile getFileBySfi(byte sfi)
public final ElementaryFile getFileByLid(short lid)
public final Map&amp;lt;Byte, ElementaryFile&amp;gt; getAllFiles()
&lt;/code>&lt;/pre>
&lt;p>Four new classes &lt;code>DirectoryHeader&lt;/code>, &lt;code>ElementaryFile&lt;/code>, &lt;code>FileHeader&lt;/code> and &lt;code>FileData&lt;/code> have been added.&lt;/p>
&lt;h5 id="directoryheader">DirectoryHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public byte getDfStatus()
public byte getKif(AccessLevel level)
public byte getKvc(AccessLevel level)
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="elementaryfile">ElementaryFile&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte getSfi()
public FileHeader getHeader()
public FileData getData()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="fileheader">FileHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public int getRecordsNumber()
public int getRecordSize()
public FileType getType()
public byte getDfStatus()
public boolean isShared()
public Short getSharedReference()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="filedata">FileData&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte[] getContent()
public byte[] getContent(int numRecord)
public byte[] getContent(int numRecord, int dataOffset, int dataLength)
public SortedMap&amp;lt;Integer, byte[]&amp;gt; getAllRecordsContent()
public int getContentAsCounterValue(int numCounter)
public SortedMap&amp;lt;Integer, Integer&amp;gt; getAllCountersValue()
public String toString()
&lt;/code>&lt;/pre>
&lt;p>So, for example to extract the contents of contract files present in the PO, the code might look like this:&lt;/p>
&lt;pre>&lt;code class="language-java">[...]
/* Read all 4 contracts command, record size set to 29 */
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Contracts,
CalypsoClassicInfo.RECORD_NUMBER_1, 4, 29);
/* proceed with the sending of commands, don't close the channel */
poTransaction.processPoCommandsInSession();
ElementaryFile efContracts = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_Contracts);
SortedMap&amp;lt;Integer, byte[]&amp;gt; records = efContracts.getData().getAllRecordsContent();
for (Map.Entry&amp;lt;Integer, byte[]&amp;gt; entry : records.entrySet()) {
logger.info(&amp;quot;Contract #{}: {}&amp;quot;, entry.getKey(),
ByteArrayUtil.toHex(entry.getValue()));
}
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="error-handling">Error handling&lt;/h2>
&lt;p>Since version 0.9, all Keyple exceptions are of the RuntimeException type.&lt;/p>
&lt;p>Catching exceptions is therefore now optional.&lt;/p>
&lt;p>However, it is possible to selectively catch certain exceptions in order to deal with particular cases.&lt;/p>
&lt;p>The new hierarchy of Keyple exceptions is shown &lt;a href="https://keyple.atlassian.net/projects/KEYP/issues/KEYP-154?filter=allissues&amp;amp;orderby=priority%20DESC&amp;amp;keyword=exceptions" target="_blank" rel="noopener">here&lt;/a>&lt;/p></description></item></channel></rss>