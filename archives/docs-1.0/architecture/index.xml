<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture | Eclipse Keyple</title><link>https://keyple.org/archives/docs-1.0/architecture/</link><atom:link href="https://keyple.org/archives/docs-1.0/architecture/index.xml" rel="self" type="application/rss+xml"/><description>Architecture</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2020-2023 The Eclipse Keyple® project. All Rights Reserved.</copyright><image><url>https://keyple.org/media/logo.svg</url><title>Architecture</title><link>https://keyple.org/archives/docs-1.0/architecture/</link></image><item><title>Global Solution</title><link>https://keyple.org/archives/docs-1.0/architecture/keyple-global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/archives/docs-1.0/architecture/keyple-global/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The Keyple solution provides currently 2 modules:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>Keyple Core&lt;/strong>, a universal smart card reader interface to manage the setting of smart card reader, the detection and the communication with smart card, and the selection of card application.&lt;/li>
&lt;li>the &lt;strong>Keyple Calypso&lt;/strong>, a first smart card solution extension built on the Keyple Core, dedicated to manage Calypso processing, Calypso card identification, card command generation, card data recovery, authentication with the secure session.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-architecture-global">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Global.svg" alt="Keyple Architecture Global" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Global
&lt;/figcaption>&lt;/figure>
&lt;p>The Keyple Core provides 3 interfaces:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>Service API&lt;/strong>, to allow terminal application to handle reader &amp;amp; select card&lt;/li>
&lt;li>the &lt;strong>Card API&lt;/strong>, for APDU command transmission, card data parsing&lt;/li>
&lt;li>the &lt;strong>Plugin API&lt;/strong>, to integrate specific smart card reader solutions.&lt;/li>
&lt;/ul>
&lt;p>The Keyple Calypso extension provides the Calypso API: a high-level interface to manage Calypso card processing.&lt;/p>
&lt;br>
&lt;h2 id="application-integration">Application integration&lt;/h2>
&lt;p>The Card API is a low-level interface to manage the transmission of APDU commands with a smart card.
A terminal application operating processing with a specific smart card solution could be implemented directly on top the Card API.&lt;/p>
&lt;figure id="figure-keyple-architecture-application-integration">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Application_Integration.svg" alt="Keyple Architecture Application Integration" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Application Integration
&lt;/figcaption>&lt;/figure>
&lt;p>Another way offering a better abstraction on smart card technical settings could be to implement on the Card API a smart card solution library extension providing a high-level interface: a specific Solution API.
This is how the Keyple Calypso extension has be defined, the Calypso API is a high-level functional interface, which hides the low-level APDU operations.&lt;/p>
&lt;br>
&lt;h2 id="reader-integration">Reader integration&lt;/h2>
&lt;h3 id="native-integration">native integration&lt;/h3>
&lt;p>The smart card readers could be directly integrated with the Keyple Core. By interfacing through the Plugin API, a specific plugin dedicated to a smart card reader solution, the Keyple Core could have the capability to fully manage the smart card readers corresponding to this native plugin.&lt;/p>
&lt;figure id="figure-keyple-architecture-reader-integration-native">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Reader_Integration_native.svg" alt="Keyple Architecture Reader Integration Native" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Reader Integration Native
&lt;/figcaption>&lt;/figure>
&lt;p>The Eclipse Keyple® project provides the plugin for the main standard smart card reader solutions.&lt;/p>
&lt;figure id="figure-keyple-architecture-native-plugins">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Native_Plugins.svg" alt="Keyple Architecture Native Plugins" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Native Plugins
&lt;/figcaption>&lt;/figure>
&lt;ul>
&lt;li>The PC/SC plugin is available for both the Java and the C++ implementation of Keyple, it allows to interface PC/SC reader on Windows, Linux and Mac OS.&lt;/li>
&lt;li>For Android devices the NFC plugin allows to operate the standard NFC interface to handle external contactless smart card. And the OMAPI plugin provides the integration of internal eSE (embedded Secure Element) or UICC (SIM card). Both plugins support Keyple Java.&lt;/li>
&lt;li>The Remote plugin (part of the Core distributed extension) allows to operate remote smart card readers.&lt;/li>
&lt;/ul>
&lt;h3 id="hybrid-integration">hybrid integration&lt;/h3>
&lt;p>It&amp;rsquo;s also possible to integrate Keyple in a terminal solution already embedding not Keyple based terminal applications operating smart card solutions. In those kinds of terminal, a Reader Manager has already the direct control on a smart card reader and manage the smart card detection: depending on the type of smart card identified on the reader, a specific terminal application is requested to operated the processing of the smart card.&lt;/p>
&lt;figure id="figure-keyple-architecture-hybrid-plugins">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Reader_Integration_hybrid.svg" alt="Keyple Architecture Hybrid Plugins" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Hybrid Plugins
&lt;/figcaption>&lt;/figure>
&lt;p>In this case a reader manager plugin, also based on the Plugin API, could allow the Keyple Core to operate the processing of a specific smart card, when requested by the Reader Manager.&lt;/p>
&lt;p>For example, an EMV certified reader manager could call a Keyple application in case of PPSE selection failure.&lt;/p>
&lt;br>
&lt;h2 id="smart-card-processing">Smart card processing&lt;/h2>
&lt;h3 id="stand-alone">stand-alone&lt;/h3>
&lt;p>By default, a terminal application manages the processing of a specific smart card in stand-alone with its local readers.&lt;/p>
&lt;figure id="figure-keyple-architecture-local-plugin">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Local_Plugin.svg" alt="Keyple Architecture Local Plugin" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Local Plugin
&lt;/figcaption>&lt;/figure>
&lt;h3 id="distributed">distributed&lt;/h3>
&lt;p>The &lt;strong>Distributed&lt;/strong> extension of the Keyple Core provides a solution allowing a master terminal application to manage the processing of a smart card localized in a remote driven terminal.
&lt;figure id="figure-keyple-architecture-remote-plugin">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_Architecture_Remote_Plugin.svg" alt="Keyple Architecture Remote Plugin" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Keyple Architecture Remote Plugin
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;br>
&lt;h2 id="smart-card-transaction">Smart card transaction&lt;/h2>
&lt;p>There are two ways for a terminal application to manage a transaction with a smart card.&lt;/p>
&lt;ul>
&lt;li>Either the smart card processing could be directly started by the terminal application.&lt;/li>
&lt;li>Otherwise, the smart card processing could be launched when a smart card is inserted in a reader of the terminal.&lt;/li>
&lt;/ul>
&lt;h3 id="explicit-selection">explicit selection&lt;/h3>
&lt;p>For a classic transaction,&lt;/p>
&lt;ul>
&lt;li>the presence of a card is firtsly checked on a reader,&lt;/li>
&lt;li>then the car is selected and identified,&lt;/li>
&lt;li>finally, a transaction is processed with the card application.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-transaction-explicit-selection">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_CardTransaction_ActivityDiag_ExplicitSelection.svg" alt="[Keyple Transaction Explicit Selection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
[Keyple Transaction Explicit Selection
&lt;/figcaption>&lt;/figure>
&lt;h3 id="default-selection">default selection&lt;/h3>
&lt;ul>
&lt;li>For automatons (e.g. a ticketing validator), the ticketing transaction is often driven by the insertion of a card.&lt;/li>
&lt;li>Keyple Core allows to define a default selection on Observable Reader, and in return to be notified of successful selections.&lt;/li>
&lt;/ul>
&lt;figure id="figure-keyple-transaction-default-selection">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/Keyple_CardTransaction_ActivityDiag_DefaultSelection.svg" alt="[Keyple Transaction Default Selection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
[Keyple Transaction Default Selection
&lt;/figcaption>&lt;/figure></description></item><item><title>Keyple Core</title><link>https://keyple.org/archives/docs-1.0/architecture/keyple-core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/archives/docs-1.0/architecture/keyple-core/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="features--packages-and-corresponding-usages">Features / packages and corresponding usages&lt;/h2>
&lt;p>The Keyple Core is a tool to handle smart card reader and to operate generic processing with smart cards.&lt;/p>
&lt;p>The Core is divided in 3 sub-modules:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Service API&lt;/strong> : provides the interfaces to access to the smart card readers and to select a smart card.&lt;/li>
&lt;li>&lt;strong>Card API&lt;/strong> : for the transmission of APDU commands with a smart card.&lt;/li>
&lt;li>&lt;strong>Plugin API&lt;/strong> : includes the factorized processing for the implementation of plugin.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Module&lt;/th>
&lt;th>Package&lt;/th>
&lt;th>Feature&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td rowspan="4" width="13%">Service&lt;/td>
&lt;td width="38%">org.eclipse.keyple.core.&lt;b>service&lt;/b>&lt;/td>
&lt;td>Management of the smart card readers&lt;br/>
&lt;ul>&lt;li>Registration of plugins to the smart card Service&lt;br/>&lt;/li>
&lt;li>Access to the readers through plugins&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.service.&lt;b>event&lt;/b>&lt;/td>
&lt;td>Notifications of reader plug/unplug, of smart card insertion/removed&lt;br/>
&lt;ul>&lt;li>Define observers of plugins or readers&lt;br/>&lt;/li>
&lt;li>Interface to be implemented by observers to be notified on plugin event or reader event&lt;br/>&lt;/li>
&lt;li>For observable reader, setting of default selections, to automatically operate in case of smart card insertion&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.service.&lt;b>util&lt;/b>&lt;/td>
&lt;td>Communication protocols setting for contactless/contacts Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.card.&lt;b>selection&lt;/b>&lt;/td>
&lt;td>Generic selection of a smart card&lt;br/>
&lt;ul>&lt;li>preparation of smart card selection requests&lt;br>&lt;/li>
&lt;li>matching selection results as smart card images&lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td rowspan="2">Smart card&lt;/td>
&lt;td>org.eclipse.keyple.card.&lt;b>message&lt;/b>&lt;/td>
&lt;td>Transmission of grouped APDU commands to a Reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.core.card.&lt;b>command&lt;/b>&lt;/td>
&lt;td>Generic API to develop a smart card specific library&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Plugin&lt;/td>
&lt;td>org.eclipse.keyple.core.&lt;b>plugin&lt;/b>&lt;br/>
&lt;td>Reader plugins implementation&lt;br/>
&lt;ul>&lt;li>Utility classes providing generic processing for Readers &lt;/li>&lt;/ul>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>According to the developer’s objective different packages must be imported:&lt;/p>
&lt;ul>
&lt;li>for the implementation of a smart card terminal application: the packages &lt;strong>service&lt;/strong>, &lt;strong>event&lt;/strong> and &lt;strong>selection&lt;/strong>.&lt;/li>
&lt;li>to develop a dedicated library supporting the command sets and transaction features of a specific smart card solution: the packages &lt;strong>message&lt;/strong>, &lt;strong>command&lt;/strong>, and &lt;strong>selection&lt;/strong>.&lt;/li>
&lt;li>to implement a plugin: the packages &lt;strong>plugin&lt;/strong>, &lt;strong>service&lt;/strong>, &lt;strong>event&lt;/strong>, and &lt;strong>message&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;figure id="figure-core-packages">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Packages.svg" alt="Core packages" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Core packages
&lt;/figcaption>&lt;/figure>
&lt;br>
&lt;h2 id="service-interface---reader-access">Service Interface - Reader Access&lt;/h2>
&lt;p>for the development of ticketing terminal application&lt;/p>
&lt;h3 id="types-of-plugin--reader">Types of plugin &amp;amp; reader&lt;/h3>
&lt;p>On Keyple, the smart card readers are managed through plugins in order to integrate specific reader solutions.
The &lt;strong>SmartCard Service&lt;/strong> singleton provides the unique name list of registered plugins. There can be three kinds of plugin:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Plugin&lt;/strong> is the generic interface to list the readers of a plugin, or to access to a specific reader with its name.&lt;/li>
&lt;li>The &lt;strong>Observable Plugin&lt;/strong> interface extends Plugins which have the capability to be observed: in order to notify registered Plugin Observers about the plug or unplug of readers. Plugin Observers could be added or removed to the Observable Plugin. Useful for systems allowing the hot plug / unplug of Readers.&lt;/li>
&lt;li>A &lt;strong>Pool Plugin&lt;/strong> is a plugin for which a Reader is available only after an explicit allocation. When not more necessary, a Reader must be released. Useful for server solutions managing farms of Readers or interfaced with HSM: unallocated Readers or HSM instances could be shared between several smartcard terminal solutions.&lt;/li>
&lt;/ul>
&lt;p>A smartcard Reader is identified through its unique name in a Plugin. There are two kinds of Reader:&lt;/p>
&lt;ul>
&lt;li>The &lt;strong>Reader&lt;/strong> is the generic interface to handle a smartcard reader. The presence of card in a Reader could be checked.&lt;/li>
&lt;li>The &lt;strong>Observable Reader&lt;/strong> interface extends Readers which have the capability to notify registered Reader Observers about the insertion or remove of a Card in the Reader. Reader Observers could be added or removed to the Observable Reader. Useful for systems automatically starting the processing of a Card at its insertion: like a ticketing validator.
&lt;figure id="figure-reader-access-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="[Reader Access v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
[Reader Access v1.0.0
&lt;/figcaption>&lt;/figure>&lt;/li>
&lt;/ul>
&lt;p>(The APDU transmission with a Card is managed at a lower layer, through a Card Solution API.)&lt;/p>
&lt;h3 id="specific-plugin-integration">Specific Plugin integration&lt;/h3>
&lt;p>The Plugins are registered to the SmartCard Service through related specific Plugin Factory.
&lt;figure id="figure-specific-plugin-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Reader_ClassDiag_SpecificPluginFactoryAndProtocol_1_0_0.svg" alt="Specific Plugin v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Specific Plugin v1.0.0
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h3 id="reader-notifications">Reader Notifications&lt;/h3>
&lt;p>To be notified about &lt;strong>Plugin Event&lt;/strong> or &lt;strong>Reader Event&lt;/strong>, a terminal application must implement the dedicated &lt;strong>Plugin Observer&lt;/strong> or &lt;strong>Reader Observer&lt;/strong> interfaces.&lt;/p>
&lt;figure id="figure-reader-notifications-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Reader_ClassDiag_ObservablePluginAndReaderEvents_1_0_0.svg" alt="Reader Notifications v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Reader Notifications v1.0.0
&lt;/figcaption>&lt;/figure>
&lt;h3 id="plugin-event">Plugin Event&lt;/h3>
&lt;p>Several &lt;strong>Plugin Observers&lt;/strong> could be registered to an Observable Plugin.
In case of reader connection / disconnection, the Observable Plugin notifies sequentially the registered Plugin Observers with the corresponding Plugin Event.
The Observable Plugin is a blocking API, the thread managing the issuance of the Plugin Event waits the acknowledge of the Plugin Observer currently notified.&lt;/p>
&lt;h3 id="reader-event">Reader Event&lt;/h3>
&lt;p>Several &lt;strong>Reader Observers&lt;/strong> could be registered to an Observable Reader.
In case of Card insertion / removal or selection match, the Observable Reader notifies sequentially the registered Reader Observers with the corresponding Reader Event. The Observable Reader could be a blocking API, the thread managing the issuance of the Plugin Event could wait the acknowledge of the notified Reader Observers.&lt;/p>
&lt;p>An Observable Reader has the capability to be set with a &lt;strong>Default Selections Request&lt;/strong>: in this case when a Card is inserted in the Reader, the Reader will try to operate the configured default selections. If a selection successfully matches with the Card, instead to simply notify about the insertion of a Card, the Observable Reader will notify about a successful selection with a Card application.&lt;/p>
&lt;ul>
&lt;li>If the notification mode is defined as &lt;strong>always&lt;/strong>, then in case of Card insertion, the Observable Reader will notify a matched card Reader Event in case of successful selection, or a simple card insertion Reader Event if not.&lt;/li>
&lt;li>If the notification mode is defined as &lt;strong>matched only&lt;/strong>, then in case of Card insertion, simple card insertion Reader Events are not notified.&lt;/li>
&lt;/ul>
&lt;p>When the processing of an inserted or matched Card is finished, a Reader Observer must release the logical channel with the Card, in order to prepare the Observable Reader to detect the removal of the Card.&lt;/p>
&lt;h3 id="observable-reader-states">Observable Reader states&lt;/h3>
&lt;p>An Observable Reader is active only when at least one Reader Observer is registered, and if the start of the detection has been requested.
When active, an Observable Reader could switch between three internal states: &lt;strong>Wait for Card Insertion&lt;/strong>, &lt;strong>Wait for Card Processing&lt;/strong>, &amp;amp; &lt;strong>Wait for Card Removal&lt;/strong>.&lt;/p>
&lt;p>In the nominal case, a Reader Observer indicates to the Observable Reader that the processing of the SE is finished by releasing the Card Channel.
To manage a failure of the Reader Observer process, the Observable Reader interface provides also a method to finalize the Card processing.&lt;/p>
&lt;figure id="figure-observable-reader-states">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Reader_StateDiag_ObservableReaderStates_1_0_0.svg" alt="Observable Reader States" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Observable Reader States
&lt;/figcaption>&lt;/figure>
&lt;p>The states could be switched:&lt;/p>
&lt;ul>
&lt;li>due to an explicit API request (blue arrows):
&lt;ul>
&lt;li>the release of the Card Channel,&lt;/li>
&lt;li>the call of an Observable Reader method:
&lt;ul>
&lt;li>the addition or the remove of an Observable Reader,&lt;/li>
&lt;li>a request to start or stop the detection, to finalize the Card processing.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Or because of an external event (red arrows), the insertion or the remove of a Card.
&lt;ul>
&lt;li>the insertion a Card causing the Observable Reader to notify a &lt;strong>Card matched&lt;/strong> Reader Event (in case of successful default selection) or a &lt;strong>Card inserted&lt;/strong> Reader Event (Notification Mode defined as always).&lt;/li>
&lt;li>the removal of a Card causing the Observable Reader to notify a &lt;strong>Card removed&lt;/strong> Reader Event.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>If a Card detection is started with the &lt;strong>repeating&lt;/strong> polling mode, then later when the Card is removed, the Reader starts again the detection of a new Card.&lt;/p>
&lt;p>Whatever the Plugin of Observable Reader, when waiting for the Card removal, any Observable Reader shall have the capability to notify the remove of the Card.
Some Plugin solutions could have the capability to notify a Card removal also during the processing of the Card.&lt;/p>
&lt;br>
&lt;h2 id="service-interface---card-selection">Service Interface - Card Selection&lt;/h2>
&lt;p>for the development of ticketing terminal application&lt;/p>
&lt;h3 id="selection-scenarios">Selection scenarios&lt;/h3>
&lt;p>Depending on the Card transaction use case, or on the Reader capability, there are two ways to manage the Selection of a Card:&lt;/p>
&lt;ul>
&lt;li>Either on a simple Reader, a Selection could be operated directly by transmitting the Selection Request. In this case the same entity manages both the Card Selection and the Card processing.&lt;/li>
&lt;li>Otherwise, on an Observable Reader, a Default Selection could be defined. In this case the Selection is operated automatically at the insertion of the Card. In this case, the Card Selection is next managed by the Observable Reader, but the Card processing is managed by a Reader Observer.&lt;/li>
&lt;/ul>
&lt;figure id="figure-selection-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_CardSelection_ActivityDiag_Scenarii.svg" alt="Selection v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Selection v1.0.0
&lt;/figcaption>&lt;/figure>
&lt;h3 id="selection-setting-and-processing">Selection setting and processing&lt;/h3>
&lt;p>A Card Selection request is defined with a Card Selector. A Card Selector could be defined with tree optional levels of selection filter.&lt;/p>
&lt;ul>
&lt;li>The selection could be limited to match a specific card communication protocol.&lt;/li>
&lt;li>The Card ATR could be filtered to match a regular expression.&lt;/li>
&lt;li>If an AID is defined, the local reader transmits a Select Application APDU command to the card.
If a SE Selector is defined without any filter, the selection is always successful if a card is present in the reader.&lt;/li>
&lt;/ul>
&lt;p>Depending on the Keyple Card Solution extension library, a card request could be completed with specific card commands to operate at the selection (for example, a Select File for a specific DF LID, the read of a specific file).&lt;/p>
&lt;p>For terminal managing several kinds of card applications, a Card Selection could be prepared with several card selection request to operate sequentially with the card.&lt;/p>
&lt;p>According to the defined &lt;strong>multi selection processing&lt;/strong> mode, the card selection could stop at the first selection request matching card application, otherwise all the prepared card selection request could be operated.&lt;/p>
&lt;ul>
&lt;li>Before the new processing of card selection request, the logical channel previously opened is closed.&lt;/li>
&lt;li>The &lt;strong>channel control&lt;/strong> defines if the logical channel should be kept open or close after the last processed card selection request.&lt;/li>
&lt;/ul>
&lt;figure id="figure-card-selection-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="Card Selection v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Card Selection v1.0.0
&lt;/figcaption>&lt;/figure>
&lt;p>The result of a card request selection is a card image of a matching card. For a card selection with multiple requests, several matching card could be provided.&lt;/p>
&lt;br>
&lt;h2 id="card-interface">Card Interface&lt;/h2>
&lt;p>for the development of smartcard solution library&lt;/p>
&lt;p>The Keyple Calypso extension uses the card interface to exchange APDU commands with Calypso cards and SAM.&lt;/p>
&lt;h3 id="apdu-transmission">APDU Transmission&lt;/h3>
&lt;figure id="figure-apdu-transmission-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Card_ClassDiag_CardMessage_1_0_0.svg" alt="APDU Transmission v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
APDU Transmission v1.0.0
&lt;/figcaption>&lt;/figure>
&lt;br>
&lt;h2 id="plugin-api">Plugin API&lt;/h2>
&lt;p>for the implementation of smartcard reader plugins&lt;/p>
&lt;h3 id="plugin-factorized-processing">Plugin Factorized Processing&lt;/h3>
&lt;p>The implementation of Plugins requires to extend the classes AbstractPlugin and AbstractLocalReader.&lt;/p>
&lt;ul>
&lt;li>If the reader solution allows the hot plug/unplug of readers then AbstractThreadedObservablePlugin should be extended.&lt;/li>
&lt;li>In case the local reader has the capability to detect the insertion or the removal or a card, then AbstractObservableLocalReader should be extended.&lt;/li>
&lt;/ul>
&lt;p>For reader solutions managing themselves the allocation of logical channel for communicatio with smart cards, the interface SmartSelectionReader should be implemented (e.g. it is the case for the OMAPI plugin).&lt;/p>
&lt;p>Only the abstract methods highlighted &lt;strong>in blue&lt;/strong> have to be implemented have to be implemented by the specific plugins.&lt;/p>
&lt;p>For plugins with ObservableReader: depending on the capability of the reader solution different interfaces could be implemented:&lt;/p>
&lt;ul>
&lt;li>WaitForCardInsertionAutonomous&lt;/li>
&lt;li>WaitForCardRemovalAutonomous&lt;/li>
&lt;li>WaitForCardRemovalDuringProcessing or DontWaitForCardRemovalDuringProcessing&lt;/li>
&lt;li>WaitForCardInsertionBlocking or WaitForCardInsertionNonBlocking&lt;/li>
&lt;li>WaitForCardRemovalBlocking or WaitForCardRemovalNonBlocking&lt;/li>
&lt;li>AbstractObservableLocalAutonomousReader&lt;/li>
&lt;/ul>
&lt;figure id="figure-plugin-factorized-processing-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCore_Plugin_ClassDiag_PluginImplementaion_1_0_0.svg" alt="Plugin Factorized Processing v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Plugin Factorized Processing v1.0.0
&lt;/figcaption>&lt;/figure></description></item><item><title>Keyple Calypso</title><link>https://keyple.org/archives/docs-1.0/architecture/keyple-calypso/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/archives/docs-1.0/architecture/keyple-calypso/</guid><description>&lt;div class="alert alert-warning">
&lt;div>
Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.
&lt;/div>
&lt;/div>
&lt;h2 id="features--packages-and-corresponding-usages">Features / packages and corresponding usages&lt;/h2>
&lt;p>The Calypso transaction API provides a high-level of abstraction to define functional commands to manage a secure session with a Calypso Portable Object, to update or authenticate its data.&lt;/p>
&lt;p>The transaction API is defined on a low-level Calypso commands API which contains the builders of PO and SAM APDU commands, and the corresponding parsers of APDU responses. This internal library is deprecated, and will be refactorized for the version 2.0.0 of Keyple Calypso.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Package&lt;/th>
&lt;th>API&lt;br/>level&lt;/th>
&lt;th>Feature&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td width="50%">org.eclipse.keyple.calypso.&lt;b>transaction&lt;/b>&lt;/td>
&lt;td width="8%">high&lt;/td>
&lt;td>Calypso Portable Object commands and secure transaction management&lt;br/>
&lt;ul>&lt;li>CalypsoAPI, command’s settings are limited to functional parameters&lt;br/>&lt;/li>
&lt;li>Calypso SAM (Secure Module) operations automatically processed&lt;br/>&lt;/li>&lt;/ul>
(only functional parameters)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>org.eclipse.keyple.calypso.&lt;b>command&lt;/b>&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.builder&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.parser&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.po.parser.session&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.builder&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.parser&lt;br/>
org.eclipse.keyple.calypso.&lt;b>command&lt;/b>.sam.parser.session&lt;/td>
&lt;td>low&lt;/td>
&lt;td>Calypso PO &amp;amp; SAM APDU commands' sets&lt;br/>
&lt;ul>&lt;li>APDU command builders&lt;br/>&lt;/li>
&lt;li>APDU response parsers&lt;br/>&lt;/li>&lt;/ul>
(technical parameter settings specific to the PO &amp;amp; SAM revisions)&lt;br>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Ticketing terminal applications must import only the high-level Calypso transaction package.&lt;/p>
&lt;figure id="figure-calypso-packages">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Packages.svg" alt="Calypso packages" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso packages
&lt;/figcaption>&lt;/figure>
&lt;!-- The only exception is the implementation a Calypso PO/SAM test tool, the setting of low-level APDU commands with wrong settings could require the usage of the Calypso command packages. -->
&lt;br>
&lt;h2 id="calypso-portable-object-selection">Calypso Portable Object Selection&lt;/h2>
&lt;p>Compared to the generic Card Selection API (cf. &lt;a href="https://keyple.org/learn/architecture/keyple-core/#card-selection%29," target="_blank" rel="noopener">https://keyple.org/learn/architecture/keyple-core/#card-selection),&lt;/a> a PO Selector could be defined to accept only non-invalidated Portable Object (in this cas an invalidated PO isn&amp;rsquo;t selected).&lt;/p>
&lt;p>In addition, a PO Selection Request provides methods:&lt;/p>
&lt;ul>
&lt;li>to prepare Select File command (useful in particular to manage REV1 Calypso PO for which the select of the targeted DF is required).&lt;/li>
&lt;li>and to prepare simple read record command (useful to optimize the read of a file present on all targeted PO).&lt;/li>
&lt;/ul>
&lt;p>The matching SmartCard resulting from a PO Selection Request is a Calypso PO. In case file records have been read during the selection: the corresponding data could be recovered in the Calypso PO card image.&lt;/p>
&lt;figure id="figure-calypso-selection-v100">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_ClassDiag_PO_Selection_1_0_0.svg" alt="Calypso Selection v1.0.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso Selection v1.0.0
&lt;/figcaption>&lt;/figure>
&lt;br>
&lt;h2 id="calypso-portable-object-transaction">Calypso Portable Object Transaction&lt;/h2>
&lt;p>A Card Resource is a set of a Reader and a &lt;strong>selected&lt;/strong> Card application.&lt;/p>
&lt;ul>
&lt;li>A Calypso Portable Object is the image of a selected Calypso PO.&lt;/li>
&lt;li>A Calypso SAM is the image of a selected Calypso SAM.&lt;/li>
&lt;/ul>
&lt;p>To operate a Calypso transaction:&lt;/p>
&lt;ul>
&lt;li>At least a Calypso Resource (CardResource&amp;lt;CalypsoPo&amp;gt;) is required.&lt;/li>
&lt;li>A SAM Resource ((CardResource&amp;lt;CalypsoSam&amp;gt;) is required too if security features are involved (Calypso secure session, Stored value transaction, PIN encryption, etc…).&lt;/li>
&lt;/ul>
&lt;p>A Calypso PO image provides public &lt;strong>getters&lt;/strong> in order to &lt;strong>recover&lt;/strong> the information of the selected PO (startup data, file data, … etc).&lt;/p>
&lt;p>A transaction with a Calypso PO is fully managed through the PoTransaction object:&lt;/p>
&lt;ul>
&lt;li>First a set of PO commands could be defined through &lt;strong>prepare&lt;/strong> commands.&lt;/li>
&lt;li>Next the prepared PO commands transmitted when operating a &lt;strong>process&lt;/strong> command.&lt;/li>
&lt;li>The responses of the PO are then recovered through the Calypso PO image.&lt;/li>
&lt;/ul>
&lt;figure id="figure-calypso-api-global-architecture">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_ClassDiag_Overview.svg" alt="Calypso API Global Architecture" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso API Global Architecture
&lt;/figcaption>&lt;/figure>
&lt;h3 id="calypso-card-image">Calypso card image&lt;/h3>
&lt;p>When read commands have been exchanged with a Calypso PO, the corresponding data could be recovered by parsing the file structure of the PO card image.&lt;/p>
&lt;figure id="figure-calypso-po-card-image">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_ClassDiag_CalypsoPo_1_0_0.svg" alt="Calypso PO card image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso PO card image
&lt;/figcaption>&lt;/figure>
&lt;h3 id="calypso-transaction">Calypso transaction&lt;/h3>
&lt;p>Only the &lt;strong>process&lt;/strong> methods generate communication with the Calypso PO and SAM.&lt;/p>
&lt;ul>
&lt;li>processPoCommands is used to transmit a set of prepared PO commands (outside or inside a secure session).&lt;/li>
&lt;li>processOpening issues an Open Secure Session followed by the prepared PO commands.&lt;/li>
&lt;li>processClosing issues the last prepared PO commands and transmits a Close Secure Session.&lt;/li>
&lt;/ul>
&lt;!---
- prepareManageSession allows to change authenticate or change the encryption mode.
-->
&lt;p>The prepareReleaseChannel method allows to the logical channel with the Calypso PO at the end of the processing of the next process method.&lt;/p>
&lt;figure id="figure-calypso-transaction">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_ClassDiag_PoTransaction_1_0_0.svg" alt="Calypso transaction" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso transaction
&lt;/figcaption>&lt;/figure>
&lt;br>
&lt;h2 id="data-model-extension">Data model extension&lt;/h2>
&lt;figure id="figure-calypso-data-model">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_ClassDiag_SpecificPoTransaction_1_0_0.svg" alt="Calypso Data Model" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso Data Model
&lt;/figcaption>&lt;/figure>
&lt;br>
&lt;h2 id="secure-session-sequence">Secure session sequence&lt;/h2>
&lt;figure id="figure-calypso-session">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../../../media/archive-1.0/architecture/KeypleCalypso_Transaction_SequenceDiag_SecureSessionProcessing_1_0_0.svg" alt="Calypso session" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Calypso session
&lt;/figcaption>&lt;/figure></description></item></channel></rss>