[{"authors":null,"categories":null,"content":" Types of contributions Thanks for your interest in the Eclipse Keyple® project.\nThere are several ways to contribute to the project:\n Propose a fix for a problem that is already known or that you have identified. In this case you will have to notify the issue in the repository where the problem appeared and reference the issue in all the other repositories affected by the fix. Propose the creation of a new component. In this case you will first have to create an issue in the repository https://github.com/eclipse/keyple to justify the need and request the creation of a new repository, wait for the issue to be resolved by the decision of the committers, and then create an issue in the new repository signifying the start of development of the new component.   Eclipse Contributor Agreement Before your contribution can be accepted by the project team contributors must electronically sign the Eclipse Contributor Agreement (ECA).\n http://www.eclipse.org/legal/ECA.php  Commits that are provided by non-committers must have a Signed-off-by field in the footer indicating that the author is aware of the terms by which the contribution has been provided to the project. The non-committer must additionally have an Eclipse Foundation account and must have a signed Eclipse Contributor Agreement (ECA) on file.\nFor more information, please see the Eclipse Committer Handbook: https://www.eclipse.org/projects/handbook/#contributing\n Contributing via fork  Check if there is already a GitHub issue for what you want to work on or create one. Announce in the comments section that you want to work on the issue. Also describe the solution you want to implement. To improve the chances for your contribution to be accepted, you\u0026rsquo;ll want to wait for the feedback of the committers. Fork the repository. Create a new branch from main for your changes. Name it after the issue number, e.g. #XXX_[description_of_changes]. Implement your changes. Rebase on main. Run ./gradlew spotlessApply to format the code and add licence headers to the files. Run ./gradlew build (to check code formatting and run tests) Commit your changes using the -s flag in order to add a Signed-off-by footer as mentioned above and use the same email address you are using for your GitHub account.\nUse commits messages that respect the commits message conventions. Push your changes to your forked repository. Submit a pull request referencing the related issue(s). After submitting, do not use your branch for any other development, otherwise further changes that you make will be visible in the PR.   Contributing as a project committer  Check if there is already a GitHub issue for what you want to work on or create one. Assign the issue to yourself. Create a new branch from main for your changes. Name it after the issue number, e.g. #XXX_[description_of_changes]. Implement your changes. Rebase on main. Run ./gradlew spotlessApply to format the code and add licence headers to the files. Run ./gradlew build (to check code formatting and run tests) Commit your changes. Use commits messages that respect the commits message conventions. Push the branch into the repository. Submit a pull request and ask somebody who is familiar with the code you modified to review it. If the reviewer approves and all checks are OK, merge using squash \u0026amp; commit method.   Commits message conventions In order to ensure good readability of the commit history, it is necessary to have consistency in the structure of the commit messages.\nTherefore, all contributors to the project are asked to respect the structure of the commits messages as described in the guide Conventional Commits 1.0.0:\n\u0026lt;type\u0026gt;[optional scope]: \u0026lt;description\u0026gt; [optional body] \u0026lt;footer(s)\u0026gt;  Furthermore, it is requested to indicate in the footer section the associated issue(s) that will be closed (Closes #xxx, closes #yyy, etc...). This will automatically close the associated issue(s) when the pull request is validated (see GitHub Docs for more details).\nIt is also required to indicate possible references to other associated issues (Refs: #aaa, #bbbb, repository_owner/other_repository_name#ccc, etc...).\nHere is fictive example:\nfeat(observation): allow asynchronous notification of reader events Add a public method in the observable reader to enable asynchronous notifications. Closes #34, closes #38 Refs: #12, eclipse/keyple#54  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1633942038,"objectID":"03b6ed671df847a7fe95d07d922cdb1a","permalink":"https://keyple.org/community/contributing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/contributing/","section":"community","summary":"Find out how to contribute to the Keyple project and how it can benefit your organization.","tags":null,"title":"How to contribute to Eclipse Keyple® project","type":"book"},{"authors":null,"categories":null,"content":" To reference your add-on please create an issue on GitHub and/or directly contribute to this website using the contribution guide.    Terminal plugins by CNA Plugins to integrate ticketing terminals from \u0026lsquo;Coppernic\u0026rsquo;, \u0026lsquo;Famoco\u0026rsquo;, \u0026lsquo;Flowbird\u0026rsquo;, \u0026lsquo;Bluebird\u0026rsquo;, and to interface the \u0026lsquo;Calypso HSM\u0026rsquo;\n  Ticketing demos by CNA Ticketing applications to emulate an autonomous validator, a hand-held inspection terminal, a distributed solution for remote ticket sales and loading\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1638268405,"objectID":"39be93bdb53a1bdc438766a5d3da7da6","permalink":"https://keyple.org/external-resources/external-add-ons/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/external-add-ons/","section":"external-resources","summary":"Find here a list of add-ons compliant with Keyple.","tags":null,"title":"External Keyple add-ons","type":"book"},{"authors":null,"categories":null,"content":"  Coming soon    ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"cc121870e1a1aeab93149f969f86855d","permalink":"https://keyple.org/components-cpp/overview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp/overview/","section":"components-cpp","summary":"  Coming soon    ","tags":null,"title":"C++ - Components overview","type":"book"},{"authors":null,"categories":null,"content":"  Components map General presentation of the dependencies between the different Keyple components.\n  Configuration wizard Online tool to generate the dependencies section of Gradle or Maven configuration files.\n  Dependency check Online tool to check the compatibility of Keyple components according to their internal API versions.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632232396,"objectID":"9bd1e4e571b4c2aaea7d62976d53e7bd","permalink":"https://keyple.org/components-java/overview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/overview/","section":"components-java","summary":"Components map General presentation of the dependencies between the different Keyple components.\n  Configuration wizard Online tool to generate the dependencies section of Gradle or Maven configuration files.","tags":null,"title":"Java - Components overview","type":"book"},{"authors":null,"categories":null,"content":" The documentation of the version 1.0 of Keyple (deprecated) is accessible here.   About this documentation This documentation is constantly evolving according to the feedback from its readers. Do not hesitate to open a ticket or to join our mailing list with questions and/or any topic you think deserves clarification or seems confusing.\n  Key concepts Understand the concepts behind Keyple.\n  Architecture Overall presentation of the Keyple architecture.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"eb30d82554c77b0237e41395248a1dd2","permalink":"https://keyple.org/learn/overview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/overview/","section":"learn","summary":"The documentation of the version 1.0 of Keyple (deprecated) is accessible here.   About this documentation This documentation is constantly evolving according to the feedback from its readers. Do not hesitate to open a ticket or to join our mailing list with questions and/or any topic you think deserves clarification or seems confusing.","tags":null,"title":"Overview","type":"book"},{"authors":null,"categories":null,"content":"  Java This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.\n  Android This guide describes how to start a ticketing application using Keyple and Android NFC plugin to read the content of a Calypso card.\n  C\u0026#43;\u0026#43; This quick start describes how to create a ready-to-execute C++ command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1634113525,"objectID":"b9987730d48c11973f6b3d2d4115f434","permalink":"https://keyple.org/learn/build-your-first-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/build-your-first-app/","section":"learn","summary":"Java This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first app","type":"book"},{"authors":null,"categories":null,"content":" To reference your terminal please create an issue on GitHub and/or directly contribute to this website using the contribution guide.   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1638268405,"objectID":"0dcc5b952f08fd234ca274c776c08357","permalink":"https://keyple.org/external-resources/compliant-terminals/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/compliant-terminals/","section":"external-resources","summary":"Find here a list of terminals compliant with Keyple.","tags":null,"title":"Keyple compliant terminals","type":"book"},{"authors":null,"categories":null,"content":" Current work  The porting of Keyple 2.0.0 in C++ is in progress. New enhancements are planned for the Calypso library  pre-personalization transaction (Change Key) signature of data fields (SAM PSO commands) confidential secure session (REV3.2 AES mode) asymmetric authentication (REV3.3 PKI mode) REV1/REV2 product specific supports SAM Transaction API (for SAM management)   Looking to provide a NFC reader plugin for iOS sytems.  Future developments A Hoplink extension will be proposed (based on a high-level API on top of the Calypso API).\nVersion history    Release Java C++ Description     2.0.0 2021/10 planned for 2021/12 Calypso terminal compliance The Keyple Service component implements the Reader API 1.0 and Card API 1.0 standardized for the reader layer of Calypso terminals. The implementation is compliant with the reader layer requirements for Calypso terminals The Calypso card extension library in version 2.0.0 follows also the Calypso layer requirements defined for Calypso terminals, it implements the Calypso API 1.0. Removal of dependencies between Keyple components (Core, Calypso extension, and specific plugins): all components are released with their own version number and could evolve separately. Until the version 1.0.0, the source code of all the Keyple Java components was hosted in a single repository: https://github.com/eclipse/keyple-java. It was the same for Keyple C++ components hosted in https://github.com/eclipse/keyple-cpp. For the version 1.0.0 and below, there were strong dependencies between the Keyple components which had all to be released in the same version number. To facilitate the evolution and the maintenance, the version 2.0.0 proposes a full reorganization of the code. All the components are split in different repositories in order to allow them to evolve independently. The public interfaces are also separated to the specific implementations: the repositories are dedicated to host API or library implementation. The Keyple Java components are managed through 16 repositories.  The API for plugin implementation and for distributed architecture configuration have been simplified   1.0.0 2020/12 not planned Core - simplifications of the low-level Plugin API dedicated for plugin developers.Remote Plugin - new stable \u0026amp; simpler versionMain unsolved issue: the versioning of the different components (Core, Calypso extension, and specific plugins) is still linked: to manage transitive importation the artifact are built with the same version reference.   0.9.0 2020/09 2021/01 Android plugins - NFC \u0026amp; OMAPI plugins optimized for all Android versionsCalypsosimplified high-level API to parse the Portable Object APDU responses, \u0026amp; recover the data through a card image.addition of the support of the PO PIN feature, PO Stored Value transaction, \u0026amp; the SAM lock   0.8.1 2020/01 2020/05 Core - Observable Reader interface evolution to improve the support of smart card reader solutions.Calypso - simplified high-level API to build the Portable Object APDU commands (PO data still recovered through a lower API managing APDI response parser)   0.7.0 2019/07 - initial public java implementationCalypso - low-level API to manage the common Calypso features (secure session for authentication, read and write commands of EF records)    ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1636966171,"objectID":"98d6f058a353aa178a1b39cefa20d88f","permalink":"https://keyple.org/community/roadmap/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/roadmap/","section":"community","summary":"Overview of past and future Keyple Releases.","tags":null,"title":"Eclipse Keyple® project roadmap","type":"book"},{"authors":null,"categories":null,"content":" To add your company please create an issue on GitHub and/or directly contribute to this website using the contribution guide.    Calypso Networks Association Find out what support offers the Calypso Networks Association team.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1638268405,"objectID":"6aa6f5da670e664f676c0025b082b56d","permalink":"https://keyple.org/external-resources/support-and-training-companies/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/support-and-training-companies/","section":"external-resources","summary":"Find here the list of companies offering Keyple support and training.","tags":null,"title":"Support \u0026 training companies","type":"book"},{"authors":null,"categories":null,"content":"  Standalone application How to develop an end-user standalone application.\n  Distributed application How to develop an end-user application using network communications.\n  Calypso application How to develop an end-user application using the Calypso card extension add-on.\n  Card resource service How to develop an end-user application using the Card Resource Service.\n  Upgrade Keyple How to upgrade an existing Keyple application using an earlier version.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1634113525,"objectID":"e7d87905ab55747c5273b4de23662147","permalink":"https://keyple.org/learn/user-guide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/","section":"learn","summary":"Standalone application How to develop an end-user standalone application.\n  Distributed application How to develop an end-user application using network communications.\n  Calypso application How to develop an end-user application using the Calypso card extension add-on.","tags":null,"title":"User guides","type":"book"},{"authors":null,"categories":null,"content":"  Reader plugin add-on How to develop an add-on to handle a specific hardware device.\n  Card extension add-on How to develop an add-on to manage a specific type of card.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1634113525,"objectID":"02ddd4e5ae16d28c8c0832714a09c315","permalink":"https://keyple.org/learn/developer-guide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/developer-guide/","section":"learn","summary":"Reader plugin add-on How to develop an add-on to handle a specific hardware device.\n  Card extension add-on How to develop an add-on to manage a specific type of card.","tags":null,"title":"Developer guides","type":"book"},{"authors":null,"categories":null,"content":" This section contains information for those who wish to understand the internal mechanics of Keyple components.\n  Core services In-depth technical information about Keyple core services.\n  Calypso card extension In-depth technical information about Keyple Calypso card extension add-on.\n  Build and CI Learn how the Keyple components are built, tested and published.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1634113525,"objectID":"2f079642f9e7c75852287e7d9a819f25","permalink":"https://keyple.org/learn/keyple-in-depth/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/keyple-in-depth/","section":"learn","summary":"This section contains information for those who wish to understand the internal mechanics of Keyple components.\n  Core services In-depth technical information about Keyple core services.\n  Calypso card extension In-depth technical information about Keyple Calypso card extension add-on.","tags":null,"title":"Keyple in depth","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core C++ component contains all the fundamental requires components of the Keyple solution.\nIt is compatible with PC and MAC platforms.\nDocumentation  Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"6e3bb227d4ebe3c9129910287d83e7a5","permalink":"https://keyple.org/components-cpp-0.9/core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/core/","section":"components-cpp-0.9","summary":"Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    0.","tags":null,"title":"Keyple Core","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core Java component contains all the fundamental requires components of the Keyple solution.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-core:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"a401b7c1ffd27d0053221f1743543bfa","permalink":"https://keyple.org/components-java-1.0/core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/core/","section":"components-java-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.","tags":null,"title":"Keyple Core","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension or a plugin made a Pull request contributions on GitHub.    Core Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. 1.\n  Distributed systems Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. Local Part of the Keyple Distributed solution which contains all the local services.\n  Extensions Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. To add an extension made a Pull request contributions on GitHub.\n  Reader plugins Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. To add a plugin made a Pull request contributions on GitHub.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"478e6066537a717d2a6137d341b6612e","permalink":"https://keyple.org/components-java-1.0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/","section":"components-java-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension or a plugin made a Pull request contributions on GitHub.","tags":null,"title":"Java 1.x modules","type":"book"},{"authors":null,"categories":null,"content":"  Calypsonet Terminal APIs Keyple is compliant with the terminal APIs provided by Calypsonet that standardize how to manage cards, readers, reader events and card selection.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632232396,"objectID":"622327e196a955398f15b79af596a29d","permalink":"https://keyple.org/components-java/standards-compliance/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standards-compliance/","section":"components-java","summary":"  Calypsonet Terminal APIs Keyple is compliant with the terminal APIs provided by Calypsonet that standardize how to manage cards, readers, reader events and card selection.\n  ","tags":null,"title":"Java - Standards compliance","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension or a plugin made a Pull request contributions on GitHub.    Core Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. 0.\n  Extensions Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. To add an extension made a Pull request contributions on GitHub.\n  Reader plugins Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. To add a plugin made a Pull request contributions on GitHub.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"5cc8a369661989e5fd90a0b81bc209d5","permalink":"https://keyple.org/components-cpp-0.9/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/","section":"components-cpp-0.9","summary":"Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension or a plugin made a Pull request contributions on GitHub.","tags":null,"title":"C++ 0.x modules","type":"book"},{"authors":null,"categories":null,"content":"  Common API Public API which defines the elements shared between all Keyple libraries.\n  Distributed Local API Internal API dedicated to the development of custom local services components of the Keyple distributed solution.\n  Distributed Remote API Internal API dedicated to the development of custom remote plugins components of the Keyple distributed solution.\n  Plugin API Internal API dedicated to the development of custom reader plugins components.\n  Service Main library containing the implementation of the core Keyple components and services.\n  Service Resource Add-on library providing profile-based card resource allocation mechanism.\n  Util Utility classes for Keyple components.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632232396,"objectID":"d23fddcfea7cc187bdc78810a4b4527e","permalink":"https://keyple.org/components-java/core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/","section":"components-java","summary":"Common API Public API which defines the elements shared between all Keyple libraries.\n  Distributed Local API Internal API dedicated to the development of custom local services components of the Keyple distributed solution.","tags":null,"title":"Java - Core components","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Local Part of the Keyple Distributed solution which contains all the local services.\n  Network Part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.\n  Remote Part of the Keyple Distributed solution which contains all the remote plugins.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"b0c0c9ce9fb171e9374addc66f738e63","permalink":"https://keyple.org/components-java-1.0/distributed-systems/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/distributed-systems/","section":"components-java-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Local Part of the Keyple Distributed solution which contains all the local services.","tags":null,"title":"Distributed systems","type":"book"},{"authors":null,"categories":null,"content":"  Local Part of the Keyple Distributed solution which contains all the local services.\n  Network Part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.\n  Remote Part of the Keyple Distributed solution which contains all the remote plugins.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632232396,"objectID":"03f2ec02ba4945df581b46ca70af09cc","permalink":"https://keyple.org/components-java/distributed/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/distributed/","section":"components-java","summary":"Local Part of the Keyple Distributed solution which contains all the local services.\n  Network Part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.","tags":null,"title":"Java - Distributed systems components","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension made a Pull request contributions on GitHub.    Calypso Keyple C++ reader extension for Calypso® technology.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"da8c70303a4f1c101c60ef8714f70b14","permalink":"https://keyple.org/components-cpp-0.9/extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/extensions/","section":"components-cpp-0.9","summary":"Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension made a Pull request contributions on GitHub.","tags":null,"title":"Extensions","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension made a Pull request contributions on GitHub.    Calypso Keyple Java reader extension for Calypso® technology.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"8a71aedde14f8adeaa985da024d1dead","permalink":"https://keyple.org/components-java-1.0/extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/extensions/","section":"components-java-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add an extension made a Pull request contributions on GitHub.","tags":null,"title":"Extensions","type":"book"},{"authors":null,"categories":null,"content":" You can create a new card extension add-on for a not yet supported card technology by following the dedicated developer guide.    Calypso Add-on to manage Calypso® cards.\n  Generic Add-on to manage cards with low-level API.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"f69a79609ed41157c66603cc3e6d6abf","permalink":"https://keyple.org/components-java/card-extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/card-extensions/","section":"components-java","summary":"You can create a new card extension add-on for a not yet supported card technology by following the dedicated developer guide.    Calypso Add-on to manage Calypso® cards.","tags":null,"title":"Java - Card extensions components","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add a plugin made a Pull request contributions on GitHub.    PC/SC Keyple C++ plugin for PC/SC smart card readers.\n  Stub Keyple C++ plugin used to stub smart card readers.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"3f9ae40fce2a47556a47af3245ac9b34","permalink":"https://keyple.org/components-cpp-0.9/plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/plugins/","section":"components-cpp-0.9","summary":"Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add a plugin made a Pull request contributions on GitHub.","tags":null,"title":"Reader plugins","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add a plugin made a Pull request contributions on GitHub.    NFC Keyple Java plugin for Android devices having NFC capabilities.\n  OMAPI Keyple Java plugin for Android devices using OMAPI technology.\n  PC/SC Keyple Java plugin for PC/SC smart card readers.\n  Stub Keyple Java plugin used to stub smart card readers.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"cadd48881e655a2c5a061d24ca48e03c","permalink":"https://keyple.org/components-java-1.0/plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/plugins/","section":"components-java-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    To add a plugin made a Pull request contributions on GitHub.","tags":null,"title":"Reader plugins","type":"book"},{"authors":null,"categories":null,"content":" Standard reader plugins are based on universally recognized technologies such as PC/SC or Android NFC. They are not specifically tied to any particular brand of device.\nYou can create a new reader plugin add-on for a not yet supported hardware by following the dedicated developer guide.\n   Android NFC Add-on to manage Android NFC readers.\n  Android OMAPI Add-on to manage Android OMAPI readers.\n  PC/SC Add-on to manage PC/SC readers.\n  Stub Add-on to manage virtual readers and cards.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"0efe50906e9431864df64840a3565d3f","permalink":"https://keyple.org/components-java/standard-reader-plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standard-reader-plugins/","section":"components-java","summary":"Standard reader plugins are based on universally recognized technologies such as PC/SC or Android NFC. They are not specifically tied to any particular brand of device.\nYou can create a new reader plugin add-on for a not yet supported hardware by following the dedicated developer guide.","tags":null,"title":"Java - Standard reader plugins components","type":"book"},{"authors":null,"categories":null,"content":" Specific reader plugins are dedicated to specific hardware platforms.\nYou can create a new reader plugin add-on for a not yet supported hardware by following the dedicated developer guide.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"d91f20314725ff0493c43dd6e246bb72","permalink":"https://keyple.org/components-java/specific-reader-plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/specific-reader-plugins/","section":"components-java","summary":"Specific reader plugins are dedicated to specific hardware platforms.\nYou can create a new reader plugin add-on for a not yet supported hardware by following the dedicated developer guide.","tags":null,"title":"Java - Specific reader plugins components","type":"book"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632232396,"objectID":"c92fea6497d0ce287423f258060e124b","permalink":"https://keyple.org/learn/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/","section":"learn","summary":"","tags":null,"title":"","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   About this documentation This documentation is constantly evolving according to the feedback from its readers. Do not hesitate to open a ticket or to join our mailing list with questions and/or any topic you think deserves clarification or seems confusing.\nGlobal Architecture   Global Architecture of Keyple  Keyple is currently divided in two major layers:\n The ‘Keyple Core' : a smart card API which allows managing smart card readers in a generic way, whaterver the reader driver or environment, and for standalone or distributed solution. A ‘Calypso Keyple extension' : a high-level Calypso Processing API allowing to operate commands with a Calypso Portable Object, and to manage a secure Calypso transaction.  Dedicated reader’s plugins have to be implemented in order to interface the Plugin API with the specific reader’s drivers.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635429016,"objectID":"30ec4babc62cb60bfcb2804f8b5ce65d","permalink":"https://keyple.org/docs-1.0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   About this documentation This documentation is constantly evolving according to the feedback from its readers.","tags":null,"title":"Overview","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Java This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.\n  Android This guide describes how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso Portable Object.\n  C\u0026#43;\u0026#43; This quick start describes how to create a ready-to-execute C++ command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"5169dad11634b40295cf6ecc35f30139","permalink":"https://keyple.org/docs-1.0/build-your-first-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/build-your-first-app/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Java This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first app","type":"book"},{"authors":null,"categories":null,"content":"`\n Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Common concepts Glossary of the key terms of the Keyple solution.\n  Standalone application How to develop an end-user standalone application.\n  Distributed application How to develop an end-user application using network communications.\n  Calypso application Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. Overview Keyple API was designed to support an extension system.\n  Create a plugin How to develop a specific hardware device Keyple plugin.\n  Create an extension How to develop a card specific Keyple extension.\n  Upgrade Keyple Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version. This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"e588cc7ce2e858b90c691d03627f1207","permalink":"https://keyple.org/docs-1.0/developer-guide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/","section":"docs-1.0","summary":"`\n Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Common concepts Glossary of the key terms of the Keyple solution.","tags":null,"title":"Developer guides","type":"book"},{"authors":null,"categories":null,"content":"  Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Java The JavaDoc for the Keyple project is available online.\n  C\u0026#43;\u0026#43; The C++ documentation for the Keyple project will be available online.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"bfff6e21a220deded4cfa5ca53644fa1","permalink":"https://keyple.org/docs-1.0/api-reference/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/api-reference/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Java The JavaDoc for the Keyple project is available online.","tags":null,"title":"API reference","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"4e1ce7c8008b324ca8c30fd25dbeac71","permalink":"https://keyple.org/docs-1.0/architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/architecture/","section":"docs-1.0","summary":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    ","tags":null,"title":"Architecture","type":"book"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632994774,"objectID":"fc93d494081657ac1320f420d4975bef","permalink":"https://keyple.org/external-resources/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/","section":"external-resources","summary":"","tags":null,"title":"","type":"book"},{"authors":null,"categories":null,"content":"  Contributing Find out how to contribute to the Keyple project and how it can benefit your organization.\n  Roadmap Overview of past and future Keyple Releases.\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1632994774,"objectID":"460964d71a5606848132aa51ae04f454","permalink":"https://keyple.org/community/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/community/","section":"community","summary":"  Contributing Find out how to contribute to the Keyple project and how it can benefit your organization.\n  Roadmap Overview of past and future Keyple Releases.\n  ","tags":null,"title":"Community","type":"book"},{"authors":null,"categories":null,"content":" This section lists the components that can be used to develop C++ applications.\n Coming soon   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1635264586,"objectID":"26e8dc5af429b27b1f4459d727d9ce75","permalink":"https://keyple.org/components-cpp/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp/","section":"components-cpp","summary":" This section lists the components that can be used to develop C++ applications.\n Coming soon   ","tags":null,"title":"C++ components","type":"book"},{"authors":null,"categories":null,"content":" This section lists the components that can be used to develop Java and Android applications.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1634808609,"objectID":"996124160146a6acb63a01dafdf69e19","permalink":"https://keyple.org/components-java/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/","section":"components-java","summary":"This section lists the components that can be used to develop Java and Android applications.","tags":null,"title":"Java components","type":"book"},{"authors":null,"categories":null,"content":"   Discover more about CNA here\n  Get in touch with the CNA team for more information\n Calypso Networks Association (CNA) is a non-profit organization dedicated to improve contactless electronic ticketing for transportation and access control standards since 2003. For many years, our mission has been to create innovative solutions that are fully interoperable, reliable, secure, and open. We collaborate with a dynamic network of city leaders and transport authorities that are keen to work with system integrators with Calypso® standard expertise.\nDiscover more about CNA here : http://calypsonet.org\nCalypso Networks Association offers comprehensive technical support and documentation to ensure all users can get the most out of Calypso® technology and Eclipse Keyple®.\nCalypso Networks Association provides a Calypso Test Kit. The Calypso Test Kit aims at helping ticketing system developers to fully experience Eclipse Keyple® with a set of Calypso® SAM and Calypso® certified portable objects from several manufacturers in various configurations.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"57ee7dc42f898caebc983f6d474fc28b","permalink":"https://keyple.org/external-resources/support-and-training-companies/calypso-networks-association/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/support-and-training-companies/calypso-networks-association/","section":"external-resources","summary":"Find out what support offers the Calypso Networks Association team.","tags":null,"title":"Calypso Networks Association","type":"book"},{"authors":null,"categories":null,"content":" Overview This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso Card involving two smart card readers.\n The demonstration application created for this quick start requires:\n a Calypso Card (contactless smart card, NFC mobile phone with a Calypso applet or application), a Calypso SAM (Secure Access Module).    We will use three main components of Keyple:\n Keyple Service Java Library which is the base component to which all the others refer, Keyple Card Calypso add-on to handle the commands sent to the Calypso card and the Calypso SAM, Keyple Plugin PC/SC add-on to provide the ability to manage PC/SC readers.  In this guide Gradle is used as build automation tool, but it is easy to transpose these explanations to another tool such as Maven for example.\nSee here for the configuration of the dependencies.\nThe example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you will need to download :\n Java 1.6+ Gradle  We recommend that you use a Java IDE like Eclipse or Intellij IDEA to create your new Gradle project.\n Create a Gradle-based empty project Create a new Java project and add the following statements to your build.gradle file to import the Keyple components into your project:\nCopy plugins { id \u0026#39;java\u0026#39; } repositories { mavenCentral() } dependencies { // Import CNA APIs implementation \u0026#39;org.calypsonet.terminal:calypsonet-terminal-reader-java-api:1.0.\u0026#43;\u0026#39; implementation \u0026#39;org.calypsonet.terminal:calypsonet-terminal-calypso-java-api:1.0.\u0026#43;\u0026#39; // Import Keyple components implementation \u0026#39;org.eclipse.keyple:keyple-common-java-api:2.0.\u0026#43;\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-util-java-lib:2.\u0026#43;\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-service-java-lib:2.0.1\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-card-calypso-java-lib:2.0.1\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.0.0\u0026#39; } If necessary, also create the usual tree in which the Java code of this guide will be placed, namely the folders: \\src\\main\\java\n Let\u0026rsquo;s code Now let\u0026rsquo;s see step by step how to create in one single class the elements that allow a certified reading of data through a Calypso secure session.\nIn a real ticketing application, the organization of the code would probably be different, but the point here is to show how Keyple makes it possible to perform very simply operations that normally require a quantity of code and knowledge that far exceeds what is implemented here.\nYou can either progressively copy each of the small portions of code that follow or copy the whole class at the bottom of this page.\nCreate the class skeleton Copy the source code below in a new Java Class named DemoCardAuthentication.\nCopy import org.calypsonet.terminal.calypso.WriteAccessLevel; import org.calypsonet.terminal.calypso.card.CalypsoCard; import org.calypsonet.terminal.calypso.sam.CalypsoSam; import org.calypsonet.terminal.calypso.transaction.CardSecuritySetting; import org.calypsonet.terminal.calypso.transaction.CardTransactionManager; import org.calypsonet.terminal.reader.selection.CardSelectionManager; import org.calypsonet.terminal.reader.selection.CardSelectionResult; import org.eclipse.keyple.card.calypso.CalypsoExtensionService; import org.eclipse.keyple.core.service.Plugin; import org.eclipse.keyple.core.service.Reader; import org.eclipse.keyple.core.service.SmartCardService; import org.eclipse.keyple.core.service.SmartCardServiceProvider; import org.eclipse.keyple.plugin.pcsc.PcscPluginFactoryBuilder; import org.eclipse.keyple.plugin.pcsc.PcscReader; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class DemoCardAuthentication { public static void main(String[] args) { // ... } } Set up the PC/SC plugin The first step to use Keyple is to initialize the plugin and smart card readers.\nIn this snippet the PC/SC plugin is registered to the SmartCardService.\nTwo readers needs to be connected to the local machine. Change \u0026ldquo;CARD_READER_NAME\u0026rdquo; and \u0026ldquo;SAM_READER_NAME\u0026rdquo; with the name of your USB readers.\nIf you don\u0026rsquo;t know the names of the readers, read how to find them in the FAQ.\nCopy // Get the instance of the SmartCardService (singleton pattern) SmartCardService smartCardService = SmartCardServiceProvider.getService(); // Register the PcscPlugin with the SmartCardService, get a generic plugin instance in return. Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build()); // The names of the drives must be adapted to the actual configuration. String CARD_READER_NAME = \u0026#34;ASK LoGO 0\u0026#34;; String SAM_READER_NAME = \u0026#34;Identive CLOUD 2700 R Smart Card Reader 0\u0026#34;; // Get and set up the card reader Reader cardReader = plugin.getReader(CARD_READER_NAME); if (cardReader == null) { throw new IllegalStateException(\u0026#34;Card reader \u0026#34; \u0026#43; CARD_READER_NAME \u0026#43; \u0026#34; not found.\u0026#34;); } // Get and set up the SAM reader Reader samReader = plugin.getReader(SAM_READER_NAME); if (samReader == null) { throw new IllegalStateException(\u0026#34;SAM reader \u0026#34; \u0026#43; SAM_READER_NAME \u0026#43; \u0026#34; not found.\u0026#34;); } // Provide the card reader type (for ratification management purpose) cardReader.getExtension(PcscReader.class).setContactless(true); Set up the Calypso card extension The Calypso card extension service will provide means to handle cards, SAMs and to manage card transactions. Copy // Get the Calypso card extension service CalypsoExtensionService calypsoExtensionService = CalypsoExtensionService.getInstance(); // Verify that the extension\u0026#39;s API level is consistent with the current service. smartCardService.checkCardExtension(calypsoExtensionService);\nSelect the Calypso SAM Before executing a transaction each smart card should be selected. The next step is the selection of the Calypso SAM resulting in a CalypsoSam object.\nIt is then combined with the SAM reader to form the SAM resource needed later within the transaction service.\nCopy // Check the SAM presence if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026#34;No SAM is present in the reader \u0026#34; \u0026#43; samReader.getName()); } // Create a SAM selection manager. CardSelectionManager samSelectionManager = smartCardService.createCardSelectionManager(); // Create a SAM selection using the Calypso card extension. samSelectionManager.prepareSelection( calypsoExtensionService.createSamSelection()); // Actual card communication: process the SAM selection. CardSelectionResult samSelectionResult = samSelectionManager.processCardSelectionScenario(samReader); // Check the selection result. if (samSelectionResult.getActiveSmartCard() == null) { throw new IllegalStateException( \u0026#34;The SAM selection failed.\u0026#34;); } // Get the SmartCard resulting of the selection. CalypsoSam calypsoSam = (CalypsoSam) samSelectionResult.getActiveSmartCard(); Select the Calypso card 1st card exchange:\nThe Calypso card selection is made using the card application\u0026rsquo;s AID and results in a CalypsoCard object that will contain all the information extracted from the Calypso card all along the transaction.\nCopy // Check the card presence if (!cardReader.isCardPresent()) { throw new IllegalStateException(\u0026#34;No card is present in the reader \u0026#34; \u0026#43; cardReader.getName()); } // Prepare a Calypso card selection final String AID = \u0026#34;315449432E49434131\u0026#34;; /* AID: Keyple test kit profile 1, Application 2 */ // Create a card selection manager. CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager(); // Create a card selection using the Calypso card extension. cardSelectionManager.prepareSelection( calypsoExtensionService .createCardSelection() .filterByDfName(AID)); // Actual card communication: process the card selection. CardSelectionResult cardSelectionResult = cardSelectionManager.processCardSelectionScenario(cardReader); // Check the selection result. if (cardSelectionResult.getActiveSmartCard() == null) { throw new IllegalStateException( \u0026#34;The card selection failed.\u0026#34;); } // Get the SmartCard resulting of the selection. CalypsoCard calypsoCard = (CalypsoCard) cardSelectionResult.getActiveSmartCard(); Open the Calypso secure session 2nd card exchange :\nThe secure session opening operated by the CardTransaction service is combined with the reading of the environment file (SFI=07h).\nThe mutual authentication process between Calypso card and Calypso SAM is initiated transparently.\nCopy // Prepare the security settings used during the Calypso transaction CardSecuritySetting cardSecuritySetting = calypsoExtensionService .createCardSecuritySetting() .setSamResource(samReader, calypsoSam); final byte RECORD_NUMBER_1 = 1; final byte SFI_ENVIRONMENT_AND_HOLDER = (byte) 0x07; // Performs file reads using the card transaction manager in a secure session. CardTransactionManager cardTransactionManager = calypsoExtensionService .createCardTransaction(cardReader, calypsoCard, cardSecuritySetting) .prepareReadRecordFile( SFI_ENVIRONMENT_AND_HOLDER, RECORD_NUMBER_1) .processOpening(WriteAccessLevel.DEBIT); Close the Calypso secure session 3rd card exchange:\nSimply close the Calypso secure session\nThe mutual authentication is finalized, it includes the authentication of the data in the read file.\nNote: any technical, cryptographic or content-related incident in the Calypso card would be signalled by an exception and would interrupt the thread of execution.\nCopy // Close the secure session, free the communication channel at the same time cardTransactionManager.prepareReleaseCardChannel() .processClosing(); System.out.println( \u0026#34;= #### The Secure Session ended successfully, the card is authenticated and the data read are certified.\u0026#34;); System.out.println(\u0026#34;= #### FILE CONTENT = \u0026#34; \u0026#43; calypsoCard.getFileBySfi(SFI_ENVIRONMENT_AND_HOLDER).toString()); System.out.println(\u0026#34;= #### End of the Calypso card processing.\u0026#34;); Unregister the plugin Finally unregister the plugin before shutting down the application\nCopy // Unregister the plugin before leaving the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0); Find the complete code source below.\n Run  Connect two USB PC/SC Readers. Insert the Calypso SAM in the SAM reader. Insert the Calypso card in the card reader. Run the application.   All project dependencies, including Keyple components, are downloaded during the first run, which can take some time.    FAQ How do I find out the names of the readers? To find out the names of the readers connected to your computer, we will use Keyple with the following class which prints in the console the number and names of the readers present:\nCopy import org.eclipse.keyple.core.service.Plugin; import org.eclipse.keyple.core.service.SmartCardService; import org.eclipse.keyple.plugin.pcsc.PcscPluginFactoryBuilder; import java.util.Set; public class ReaderDiscovery { public static void main(String[] args) { SmartCardService smartCardService = SmartCardServiceProvider.getService(); Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build()); Set\u0026lt;String\u0026gt; names = plugin.getReaderNames(); System.out.println(names.size() \u0026#43; \u0026#34; readers found.\u0026#34;); for (String name : names) { System.out.println(\u0026#39;\u0026#34;\u0026#39; \u0026#43; name \u0026#43; \u0026#39;\u0026#34;\u0026#39;); } } }  The console output should look something like:\n2 readers found. \u0026quot;ASK LoGO 0\u0026quot; \u0026quot;Identive CLOUD 2700 R Smart Card Reader 0\u0026quot;  Identify which reader will be the card (contactless) reader and the SAM (contact) reader and replace CARD_READER_NAME and SAM_READER_NAME with their values.\nHow to activate the Keyple\u0026rsquo;s logs? As soon as the slf4j library is imported into the project, Keyple modules are able to produce logs. Copy // Import logger libs implementation \u0026#39;org.slf4j:slf4j-api:1.7.32\u0026#39; implementation \u0026#39;org.slf4j:slf4j-simple:1.7.32\u0026#39;\nHowever, to take full advantage of the possibilities of this library, it is necessary to create a simplelogger.properties file in the /src/main/resources folder of the project.\nThe self-documented content of this file may be:\nCopy # SLF4J\u0026#39;s SimpleLogger configuration file # Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err. # Default logging detail level for all instances of SimpleLogger. # Must be one of (\u0026#34;trace\u0026#34;, \u0026#34;debug\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, or \u0026#34;error\u0026#34;). # If not specified, defaults to \u0026#34;info\u0026#34;. org.slf4j.simpleLogger.defaultLogLevel=debug # Logging detail level for a SimpleLogger instance named \u0026#34;xxxxx\u0026#34;. # Must be one of (\u0026#34;trace\u0026#34;, \u0026#34;debug\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, or \u0026#34;error\u0026#34;). # If not specified, the default logging detail level is used. #org.slf4j.simpleLogger.log.xxxxx= # Set to true if you want the current date and time to be included in output messages. # Default is false, and will output the number of milliseconds elapsed since startup. org.slf4j.simpleLogger.showDateTime=true # The date and time format to be used in the output messages. # The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat. # If the format is not specified or is invalid, the default format is used. # The default format is yyyy-MM-dd HH:mm:ss:SSS Z. org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS] # Set to true if you want to output the current thread name. # Defaults to true. org.slf4j.simpleLogger.showThreadName=true # Set to true if you want the Logger instance name to be included in output messages. # Defaults to true. org.slf4j.simpleLogger.showLogName=false # Set to true if you want the last component of the name to be included in output messages. # Defaults to false. org.slf4j.simpleLogger.showShortLogName=true org.slf4j.simpleLogger.levelInBrackets=true Why do I see a warning in the console about illegal reflexive access when running the application?\nA known problem on Windows 8/10 platforms causes the smartcard service to stop when the last reader is removed. This problem prevents a \u0026ldquo;classic\u0026rdquo; monitoring of connections and disconnections of readers with the smartcard.io library (Java PC/SC). So for the moment we are using a workaround based on reflexivity to overcome this problem and allow a correct monitoring of the readers in the PC/SC plugin. This has the disadvantage of generating a warning message with recent versions of the JVM. However, we have not found any problems with this implementation of the PC/SC plugin so far.\nFull code Here is the complete code of this quick start in one single block.\nCopy import org.calypsonet.terminal.calypso.WriteAccessLevel; import org.calypsonet.terminal.calypso.card.CalypsoCard; import org.calypsonet.terminal.calypso.sam.CalypsoSam; import org.calypsonet.terminal.calypso.transaction.CardSecuritySetting; import org.calypsonet.terminal.calypso.transaction.CardTransactionManager; import org.calypsonet.terminal.reader.selection.CardSelectionManager; import org.calypsonet.terminal.reader.selection.CardSelectionResult; import org.eclipse.keyple.card.calypso.CalypsoExtensionService; import org.eclipse.keyple.core.service.Plugin; import org.eclipse.keyple.core.service.Reader; import org.eclipse.keyple.core.service.SmartCardService; import org.eclipse.keyple.core.service.SmartCardServiceProvider; import org.eclipse.keyple.plugin.pcsc.PcscPluginFactoryBuilder; import org.eclipse.keyple.plugin.pcsc.PcscReader; public class DemoCardAuthentication { public static void main(String[] args) { // Get the instance of the SmartCardService (singleton pattern) SmartCardService smartCardService = SmartCardServiceProvider.getService(); // Register the PcscPlugin with the SmartCardService, get a generic plugin instance in return. Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build()); // The names of the drives must be adapted to the actual configuration. String CARD_READER_NAME = \u0026#34;ASK LoGO 0\u0026#34;; String SAM_READER_NAME = \u0026#34;Identive CLOUD 2700 R Smart Card Reader 0\u0026#34;; // Get and set up the card reader Reader cardReader = plugin.getReader(CARD_READER_NAME); if (cardReader == null) { throw new IllegalStateException(\u0026#34;Card reader \u0026#34; \u0026#43; CARD_READER_NAME \u0026#43; \u0026#34; not found.\u0026#34;); } // Get and set up the SAM reader Reader samReader = plugin.getReader(SAM_READER_NAME); if (samReader == null) { throw new IllegalStateException(\u0026#34;SAM reader \u0026#34; \u0026#43; SAM_READER_NAME \u0026#43; \u0026#34; not found.\u0026#34;); } // Check the SAM presence if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026#34;No SAM is present in the reader \u0026#34; \u0026#43; samReader.getName()); } // Provide the card reader type (for ratification management purpose) cardReader.getExtension(PcscReader.class).setContactless(true); // Get the Calypso card extension service CalypsoExtensionService calypsoExtensionService = CalypsoExtensionService.getInstance(); // Verify that the extension\u0026#39;s API level is consistent with the current service. smartCardService.checkCardExtension(calypsoExtensionService); // Create a SAM selection manager. CardSelectionManager samSelectionManager = smartCardService.createCardSelectionManager(); // Create a SAM selection using the Calypso card extension. samSelectionManager.prepareSelection( calypsoExtensionService.createSamSelection()); // Actual card communication: process the SAM selection. CardSelectionResult samSelectionResult = samSelectionManager.processCardSelectionScenario(samReader); // Check the selection result. if (samSelectionResult.getActiveSmartCard() == null) { throw new IllegalStateException( \u0026#34;The SAM selection failed.\u0026#34;); } // Get the SmartCard resulting of the selection. CalypsoSam calypsoSam = (CalypsoSam) samSelectionResult.getActiveSmartCard(); // Check the card presence if (!cardReader.isCardPresent()) { throw new IllegalStateException(\u0026#34;No card is present in the reader \u0026#34; \u0026#43; cardReader.getName()); } // Prepare a Calypso card selection final String AID = \u0026#34;315449432E49434131\u0026#34;; /* AID: Keyple test kit profile 1, Application 2 */ // Create a card selection manager. CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager(); // Create a card selection using the Calypso card extension. cardSelectionManager.prepareSelection( calypsoExtensionService .createCardSelection() .filterByDfName(AID)); // Actual card communication: process the card selection. CardSelectionResult cardSelectionResult = cardSelectionManager.processCardSelectionScenario(cardReader); // Check the selection result. if (cardSelectionResult.getActiveSmartCard() == null) { throw new IllegalStateException( \u0026#34;The card selection failed.\u0026#34;); } // Get the SmartCard resulting of the selection. CalypsoCard calypsoCard = (CalypsoCard) cardSelectionResult.getActiveSmartCard(); // Prepare the security settings used during the Calypso transaction CardSecuritySetting cardSecuritySetting = calypsoExtensionService .createCardSecuritySetting() .setSamResource(samReader, calypsoSam); final byte RECORD_NUMBER_1 = 1; final byte SFI_ENVIRONMENT_AND_HOLDER = (byte) 0x07; // Performs file reads using the card transaction manager in a secure session. CardTransactionManager cardTransactionManager = calypsoExtensionService .createCardTransaction(cardReader, calypsoCard, cardSecuritySetting) .prepareReadRecordFile( SFI_ENVIRONMENT_AND_HOLDER, RECORD_NUMBER_1) .processOpening(WriteAccessLevel.DEBIT); // Close the secure session, free the communication channel at the same time cardTransactionManager.prepareReleaseCardChannel() .processClosing(); System.out.println( \u0026#34;= #### The Secure Session ended successfully, the card is authenticated and the data read are certified.\u0026#34;); System.out.println(\u0026#34;= #### FILE CONTENT = \u0026#34; \u0026#43; calypsoCard.getFileBySfi(SFI_ENVIRONMENT_AND_HOLDER).toString()); System.out.println(\u0026#34;= #### End of the Calypso card processing.\u0026#34;); // Unregister the plugin before leaving the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0); } } ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1638977335,"objectID":"c1ed76ce001dc59ac73c503c92f61022","permalink":"https://keyple.org/learn/build-your-first-app/java-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/build-your-first-app/java-app/","section":"learn","summary":"This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first Java application","type":"book"},{"authors":null,"categories":null,"content":" Overview This page describes the core elements of Keyple, i.e. the concepts and APIs that are used to build any application implementing Keyple.\nIt is essential for the future user of Keyple to be familiar with what is said in this chapter.\n Reader Keyple\u0026rsquo;s primary goal being to interact with smart cards (or smartphones) held by individuals, it is logical to put the Reader at the top of Keyple\u0026rsquo;s concepts.\nIndeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via the Keyple Service or using a card extension (such as Keyple Calypso card extension add-on for example).\nThese interfaces provide the means to\n identify the underlying physical reader, manage communication protocols, detect the presence and communicate with smart cards.  The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.\nTo define the interface between an application and a reader, Keyple relies on the standard Terminal Reader API proposed by Calypso Networks Association and thus inherits an existing modeling effort.\nAnother benefit of using this terminal API is the ability to certify the functioning of a Keyple terminal via the associated certification process.\nThis certification provides a guarantee that the terminal will function as expected.\n Plugin In Keyple terminology, a plugin is an add-on that allows the management of readers of a certain type. The plugin is responsible for informing the application about the availability of readers. The readers of the same plugin are usually hardware linked to the same physical interface.\nDepending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).\n Card extension A card extension is an add-on that provides high-level access to the features of a particular card technology.\nTwo card extensions are provided natively by the Keyple project:\n a generic card extension providing basic means to communicate with a card, a Calypso card extension providing high-level access to Calypso card features. It includes a Secure Session based transaction manager involving Calypso cards and SAMs.   Smart card service This is the main service of Keyple that concentrates the knowledge of active plugins and readers and provides card selection managers.\nAt startup, a Keyple application must register the add-ons (plugins and card extensions) it uses.\n Observation The concept of observation applies to certain types of readers and plugins.\nIt consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.\nNot all plugins and readers are observable and for those which are, the observation is optional.\n Selection The Keyple selection concept is derived from the application selection defined by the ISO7816-4 standard.\nIt supplements it by managing cards that do not have the standard command using identification mechanisms based on power-on data and communication protocol, and also by allowing the execution of commands immediately following application selection or detection.\nThis principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.\nSeveral targets can be defined by the application according to the different customer cards expected within a selection scenario.\nThe selection scenario principle consists in providing a set of selection cases corresponding to the expected cards and receiving a selection result containing not only the card identification but also the result of all additional commands that the application will have attached.\nThe Keyple card selection process is generic, allowing the management of cards of different types or technologies within the same application.\n Smart card The Keyple smart card is an object representation of the physical card.\nIt is built by the specific card extension used (e.g. Keyple Calypso) and is provided to the user by the card selection service.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"f15b055c274c840753dd4baf098df1cd","permalink":"https://keyple.org/learn/overview/key-concepts/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/overview/key-concepts/","section":"learn","summary":"Understand the concepts behind Keyple.","tags":null,"title":"The Keyple key concepts","type":"book"},{"authors":null,"categories":null,"content":" Overview This guide is intended to help developers who want to create a Keyple reader plugin add-on for a specific device.\n Operating mode  Learn the plugin architecture concepts Select the predefined features that meet your need Define specific features (optional) Set up the development environment Implement the solution   Plugin architecture A Keyple reader plugin consists of three objects, a plugin factory, a plugin and a reader, which meet the following two interface specifications:\n Common API: public contract containing only generic types common to all plugins. Plugin API: private contract based on two types of interfaces:  API (Application Programming Interface): interface implemented by Keyple Service and directly usable by the plugin code. SPI (Service Provider Interface): interface to be implemented by the plugin and directly used by Keyple Service.    The component diagram below illustrates the internal API/SPI links between the plugin and Keyple Service, as well as the public APIs exposed to the client application:  \n Select predefined features The diagram below helps you to determine exactly which interfaces to implement according to the characteristics of the reader:  \n The XxxPluginFactory, XxxPlugin and XxxReader interfaces must be created. They are specific to the plugin Xxx to be created but can remain empty if there is no specific feature.    Define specific features Depending on the characteristics of the reader, it may be necessary to add in the specific APIs configuration methods appropriate to the technical context.\nThese features can be exposed at three levels:\n In the plugin factory (XxxPluginFactory interface), for the initial configuration of the plugin (e.g. set custom plugin name). In the plugin (XxxPlugin interface), for dynamic configurations that can be applied to all the readers (e.g. put the readers in sleep mode).\nThe API will then be directly accessible from the client application through the getExtension(...) method of the plugin registered with Keyple Service. In the reader (XxxReader interface), for dynamic configurations specific to each reader (e.g. activate/deactivate a LED).\nThe API will then be directly accessible from the client application through the getExtension(...) method of the reader provided by the plugin registered with Keyple Service.   Set up dev environment  For Java and Android projects, the code should be compliant with Java 1.6 in order to address a wide range of applications.   If the reader plugin add-on is to be integrated into the Eclipse Keyple® project, it must use one of the following project templates:\n Java template: adapt fields [READER_PLUGIN_NAME], Xxx, xxx, TODO Android template: adapt fields [ANDROID_READER_PLUGIN_NAME], Xxx, xxx, TODO   Before pushing the project to GitHub the first time, you must give write permission to some scripts files via the following commands:\nCopy git update-index --chmod=\u0026#43;x \u0026#34;gradlew\u0026#34; git update-index --chmod=\u0026#43;x \u0026#34;scripts/check_version.sh\u0026#34; git update-index --chmod=\u0026#43;x \u0026#34;scripts/prepare_javadoc.sh\u0026#34;   If examples are proposed, they should be placed in the keyple-java-example repository.\nThe contribution procedure is described here.\n Implement the solution  It is important to hide the internal Keyple interfaces of the Plugin API from the client application.   For this purpose, it is suggested to respect the following programming pattern based on the use of:\n public interfaces, private interfaces adapters (package visibility) accessible from a public provider/builder.     It is possible to use other alternatives to the factory provider depending on the need. For example, if the plugin factory needs to expose specific configuration methods, it is recommended to use the builder pattern instead of the provider pattern in order to get a properly initialized factory. Thus, the factory does not expose any method.    API  Keyple Common API Keyple Plugin API   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"25e4a51c408d2c72488dc9bce481ce98","permalink":"https://keyple.org/learn/developer-guide/reader-plugin-add-on/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/developer-guide/reader-plugin-add-on/","section":"learn","summary":"How to develop an add-on to handle a specific hardware device.","tags":null,"title":"Reader Plugin Add-on Developer Guide","type":"book"},{"authors":null,"categories":null,"content":" Overview A standalone application is an application that runs in a device in contact with the end user.\nIt has at least one local smart card reader and manages itself the interaction with the user.\nThe diagram below illustrates the organization of a standalone application based on Keyple:  \n Operating mode  If you are new to Keyple, read the key concepts page and familiarize yourself with the fundamentals behind Keyple.    Access to the smart card service Set up a plugin Set up a reader Select a card Perform a transaction  The smart card service As part of Keyple Service component, the smart card service is the main service of Keyple. Its role is to centralize the add-on resources and to manage their life cycle.\nThe service is accessible by invoking the SmartCardServiceProvider.getService() static method.\nCopy SmartCardService smartCardService = SmartCardServiceProvider.getService();  Set up a plugin The Keyple application developer will choose the reader plugins he needs according to the equipment on which the Keyple application will run.\nFor example, if the environment is PC-based, the PC/SC plugin will probably, but not necessarily, be chosen. For an Andoid terminal environment, the plugin could be the standard Android NFC plugin or one of the plugins available from the industrial partners of the project.\nFor a complete list of available plugins, please see the standard reader plugins, the specific reader plugins or one of our partners reader plugins.\n A new plugin can also be created if there is no plugin for the intended hardware.   Access to a plugin To access a plugin at the application level, it must first be registered with the smart card service via the registerPlugin(...) method. It will be necessary to provide an implementation of the KeyplePluginExtensionFactory interface. This factory is provided by the API of the used plugin.\nDepending on the capabilities of the hardware, the plugin factory may or may not offer specific configuration options. Please refer to the API of the plugin component you are considering to see what is appropriate for your application.\nThe registration provides in return an implementation of one of the Plugin, ObservablePlugin or PoolPlugin interfaces depending on the type of target plugin.\n A plugin is identified by a unique name in the system so that it can be retrieved at any time from the smart card service.   Copy // Here is for example the registration of the PC/SC plugin Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build()); Configure a plugin Some plugin types may offer specific options.\nStatic options are usually directly exposed by the plugin factory API while dynamic options are exposed by the plugin extension API.\nTo access the plugin extension it is necessary to invoke the getExtension(...) method on the registered Plugin by specifying the expected class of the extension which must extends the KeyplePluginExtension interface. After that, the dedicated methods are available from the resulting object.\nCopy // Here is a snippet showing the usage of the extension of the Stub plugin plugin .getExtension(StubPlugin.class) .unplugReader(\u0026#34;READER_1\u0026#34;); Monitor a plugin  The plugin monitoring only applies to hardware environments in which the readers are removable. Moreover, only plugins of type ObservablePlugin can be monitored.   The observation of reader connections and disconnections is achieved through a background task managed by Keyple Service.\nTo enable these observation mechanisms, it is imperative to provide:\n a plugin observer implementing the PluginObserverSpi interface to be notified of plugin events, an exception handler implementing the PluginObservationExceptionHandlerSpi interface to be notified of errors that may occur during the monitoring or events notifications.  These two interfaces are available in the org.eclipse.keyple.core.service.spi package of the Keyple Service component.\nHere is an example of a plugin observer class including an exception handler:\nCopy class PluginObserver implements PluginObserverSpi, PluginObservationExceptionHandlerSpi { @Override public void onPluginEvent(PluginEvent event) { switch (event.getEventType()) { case READER_CONNECTED: // here the processing to be done when a reader is connected ... break; case READER_DISCONNECTED: // here the processing to be done when a reader is disconnected ... break; default: break; } } @Override public void onPluginObservationError(String pluginName, Throwable e) { // handle here the plugin exceptions raised while observing the readers ... } } In order to access the dedicated setters, the plugin has to be cast to ObservablePlugin.\nSince adding an observer will cause the Keyple Service to check for the presence of an exception handler, the definition of the exception handler must be done first.\nCopy PluginObserver pluginObserver = new PluginObserver(); ((ObservablePlugin) plugin).setPluginObservationExceptionHandler(pluginObserver); ((ObservablePlugin) plugin).addObserver(pluginObserver);  Note that the monitoring thread only works if there is at least one observer registered, and the notification process is sequential and synchronous.    Set up a reader The readers are provided by the plugins, that\u0026rsquo;s why you have to set up the plugin first.\nAccess to a reader The hardware readers already connected are referenced in the system during the registration of the plugin. For observable plugins, the references of the connected readers are updated in real time.\nReaders are accessible directly from the associated Plugin instance.\nCopy // Here is an example to get the 1st available reader String readerName = plugin.getReaderNames().get(0); Reader reader = plugin.getReader(readerName);  Depending on the type of plugin, the reader names are more or less dynamic (e.g. a PC/SC based system vs. an embedded terminal), it is sometimes necessary to implement an identification mechanism in order to assign the right reader to the right place in the system (for example by using regular expressions).   Configure a reader There are two types of configuration. Their availability depends on the characteristics of the reader:\n  The reader is an instance of ConfigurableReader:\nIt is then possible to activate or deactivate the protocols supported by the reader.\nUse of these methods may be optional if the application does not intend to target products by protocol filtering.   The reader\u0026rsquo;s extension API exposes specific options:\nTo access the reader extension it is necessary to invoke the getExtension(...) method on the Reader instance by specifying the expected class of the extension which must extends the KeypleReaderExtension interface. After that, the dedicated methods, if any, are available from the resulting object. Copy // Here is a snippet showing the usage of the extension of the Stub reader reader .getExtension(StubReader.class) .removeCard();\n  Monitor a reader  The reader monitoring only applies to hardware environments in which the smart cards are removable. Moreover, only readers of type ObservableReader can be monitored.    Observation of the readers is optional in Keyple. It facilitates an event-driven programming mode, but an application developer can choose not to observe a reader, either because this reader is not designed to manage card insertions/withdrawals (for example an Android OMAPI reader or a SAM reader), or because the application is designed to directly manage the presence of a card (see to isCardPresent method of the Reader interface).   The observation of card insertions and removals is achieved through a background task managed by Keyple Service.\nTo enable these observation mechanisms, it is imperative to provide:\n a reader observer implementing the CardReaderObserverSpi interface to be notified of reader events, an exception handler implementing the CardReaderObservationExceptionHandlerSpi interface to be notified of errors that may occur during the monitoring or events notifications.  These two interfaces are available in the org.calypsonet.terminal.reader.spi package of the Calypsonet Terminal Reader API component.\nHere is an example of a reader observer class including an exception handler:\nCopy class ReaderObserver implements CardReaderObserverSpi, CardReaderObservationExceptionHandlerSpi { @Override public void onReaderEvent(CardReaderEvent event) { switch (event.getType()) { case CardReaderEvent.Type.CARD_INSERTED: // here the processing to be done when a card is inserted ... break; case CardReaderEvent.Type.CARD_REMOVED: // here the processing to be done when a card is removed ... break; default: break; } } @Override public void onReaderObservationError(String pluginName, String readerName, Throwable e) { // handle here the reader exceptions raised while observing the cards ... } } In order to access the dedicated setters, the reader has to be cast to ObservableReader.\nSince adding an observer will cause the Keyple Service to check for the presence of an exception handler, the definition of the exception handler must be done first.\nCopy ReaderObserver readerObserver = new ReaderObserver(); ((ObservableReader) reader).setReaderObservationExceptionHandler(readerObserver); ((ObservableReader) reader).addObserver(readerObserver); ((ObservableReader) reader).startCardDetection(ObservableCardReader.DetectionMode.REPEATING);  Note that the startCardDetection(...) and stopCardDetection() methods start and stop the monitoring thread. The API offers different options to manage the needs around card detection.\nMoreover, the notification process is sequential and synchronous.    Select a card The starting point of any processing done with a card in the Keyple enrivonment, is to reference this card in the system. It is the role of the selection step to obtain this reference.\nYou have first to prepare a selection scenario defining the eligible cards for a transaction, then to execute the scenario when a card is present.\nPrepare a scenario To prepare a scenario, you have to get a new instance of CardSelectionManager from the smart card service using the createCardSelectionManager() method, then configure it with scenario cases using dedicated methods provided by one or more card extensions.\nCopy CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager();``` The prepareSelection(...) method allows to add a selection case to the scenario by providing an implementation of the CardSelection interface and return the index of the added case in order to be able to identify later the case that matched.\nPlease note that the order of addition is important because it will impact the selection cycle and favor the performance of the first added cases.\nProviding one or more selection cases to the CardSelectionManager constitutes a selection scenario. The scenario is run by Keyple Service when a card is detected, the different cases being evaluated sequentially as long as the card does not match the criteria of the defined cases.\nThe selection process for a case offers several options for selecting a processing based on the type of card presented to the reader.\nIt is based on a filtering process according to three possible criteria, each of which is optional:\n the communication protocol of the card (usually also identifying a card technology) the power-on data collected by the reader when the card is detected (e.g. the Answer To Reset) the ISO standard application identifier (AID) used to perform a Select Application command.  When a card is inserted, it is evaluated according to these criteria and will be given the status \u0026ldquo;selected\u0026rdquo; or not.\nWhen a card is not selected, no other operation will be possible with it.\nThe same card could correspond to several cases of the same scenario, especially when filtering by AID. By default, the selection process will stop at the first case that matches. It is however possible to choose another strategy using the setMultipleSelectionMode() method. In this case, the process will continue to the last selection case in the scenario and return all results, but only the last matching application will be selected.\nWhen a card is selected, the CardSelectionManager will make available the result as a SmartCard object containing all the information known about the card at that stage.\nDepending on the card extension that is used, this SmartCard object can be cast to a more comprehensive object with specific features defined by the extension.\nIn addition to the selection process itself, specific APDU commands may be sent to the card if the selection is successful. The output of these commands is available in the instance of the SmartCard object.\nThe following snippet shows the preparation of two selection cases using the generic card extension: Copy // prepare a selection for application 1 int firstCaseIndex = cardSelectionManager.prepareSelection( GenericExtensionService.getInstance() .createCardSelection() .filterByDfName(AID1)); // prepare a selection for application 2 int secondCaseIndex = cardSelectionManager.prepareSelection( GenericExtensionService.getInstance() .createCardSelection() .filterByDfName(AID2));\nRun a scenario If we know that the card is in the reader it is possible to run a selection scenario by invoking the processCardSelectionScenario(...) method on the corresponding reader. The result of the selection is then directly returned.\nCopy // Actual card communication: run the selection scenario. CardSelectionResult selectionResult = cardSelectionManager.processCardSelectionScenario(reader); // Check the selection result. if (selectionResult.getActiveSmartCard() == null) { throw new IllegalStateException(\u0026#34;The selection of the card failed.\u0026#34;); } // Get the SmartCard resulting of the selection. SmartCard smartCard = selectionResult.getActiveSmartCard(); Schedule a scenario If the reader is of type ObservableReader then it is possible to schedule in advance the execution of a selection scenario as soon as a card is presented.\nInvoke the scheduleCardSelectionScenario(...) to register the previously prepared scenario in the observable reader.\nIn this case, it is necessary to register a reader observer and to have started the card detection in order to be able to retrieve the result of the selection which will be contained in a ReaderEvent.\nUse the parseScheduledCardSelectionsResponse(...) method to extract the selection result from the event.\nNote that the scheduling of the execution of a scenario includes two options:\n the DetectionMode defining the expected behavior regarding the card detection allowing to automatically restart it or not. the NotificationMode allowing to choose if only the cards matching the selection (successfully selected) should trigger an event.  Copy ... @Override public void onReaderEvent(CardReaderEvent event) { switch (event.getType()) { case CardReaderEvent.Type.CARD_MATCHED: // Retrieve the selected smart card SmartCard smartCard = cardSelectionManager .parseScheduledCardSelectionsResponse(event.getScheduledCardSelectionsResponse()) .getActiveSmartCard(); // Perform the transaction ... break; default: break; } if (event.getType() == CardReaderEvent.Type.CARD_INSERTED || event.getType() == CardReaderEvent.Type.CARD_MATCHED) { // Ensures that the communication channel is closed, regardless of the processing with the card. ((ObservableReader) (reader)).finalizeCardProcessing(); } } ...  The finalizeCardProcessing() method must be invoked at the end of the transaction to ensure that the communication channel is closed. This switches the underlying monitoring thread into a state of waiting for the card to be removed.\nNot doing this can lead to blocking states of the card insertion/removal monitoring mechanism.\n   Perform a transaction Once the smart card is referenced in the system it is possible to perform the desired transaction using the appropriate card extension.\nWhen the transaction is completed, if the reader is observed, it is imperative to invoke the finalizeCardProcessing() method on the observable reader (see the above note).\n Unregister a plugin To shut down a Keyple application properly, it is necessary to free the resources and in particular to stop the observation threads.\nThis is done by unregistering the plugins in the following way:\nCopy smartCardService.unregisterPlugin(plugin.getName());  API  Calypsonet Terminal Reader API Keyple Common API Keyple Service API   Examples  Java examples   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"e77ca063ee6572d6bf15d5656980094d","permalink":"https://keyple.org/learn/user-guide/standalone-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/standalone-application/","section":"learn","summary":"How to develop an end-user standalone application.","tags":null,"title":"Standalone Application User Guide","type":"book"},{"authors":null,"categories":null,"content":" The Calypso Networks Association has implemented several plugins to integrate Keyple Java on different ticketing terminals.\nSome are fully provide as open source:\n plugin Coppernic for the terminal \u0026lsquo;C-One v2\u0026rsquo; plugin Famoco for the terminals \u0026lsquo;FX100\u0026rsquo;, \u0026lsquo;FX105\u0026rsquo;, \u0026lsquo;FX200\u0026rsquo;, \u0026lsquo;FX205\u0026rsquo;, \u0026lsquo;FX300\u0026rsquo;, \u0026lsquo;FX915\u0026rsquo;, \u0026lsquo;FX920\u0026rsquo;  Others have restricted access to respect the IP of the manufacturers (ask CNA on keyple @ calypsonet.org):\n plugin HSM to interface the \u0026lsquo;Calypso HSM\u0026rsquo; plugin Flowbird to support all the Android terminals proposed by Flowbird (Axio Touch Validator/ MTBorne validator, Magnetic Axio Touch Validator, Axio 4 Validator, Infigo Driver Console, Voyager Embedded Ticketing Vending Machine, Coppernic C-One, Coppernic C-One V2, Zebra TC77, ACTIA PSDT) plugin Bluebird for the terminal \u0026lsquo;EF501\u0026rsquo;  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1637161921,"objectID":"7f7073ddf9eb637cf459ba6b381040b3","permalink":"https://keyple.org/external-resources/external-add-ons/terminal-plugins-by-cna/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/external-add-ons/terminal-plugins-by-cna/","section":"external-resources","summary":"Plugins to integrate ticketing terminals from 'Coppernic', 'Famoco', 'Flowbird', 'Bluebird', and to interface the 'Calypso HSM'","tags":null,"title":"Terminal plugins by the Calypso Networks Association","type":"book"},{"authors":null,"categories":null,"content":" Overview The development of an Android application based on Keyple follows the same principles as those exposed in the Java part.\nHowever, this guide points out the specificities of this environment based on the Android NFC application example provided in the keyple-java-example repository.\nWe recommend that Android application developers clone this example to better understand how Keyple works on Android.\n The application available in the example repository requires:\n a retail Device with NFC powered by android.nfc library (integrated into standard Android SDK), Android OS 19+, a Calypso card (contactless smart card, NFC mobile phone with a Calypso applet or application).    It uses three main components of Keyple:\n Keyple Service Java Library which is the base component to which all the others refer, Keyple Card Generic add-on to handle the commands sent to the Calypso card, Keyple Plugin Android NFC add-on to provide the ability to drive the NFC reader.  Gradle is used as build automation tool, but it is easy to transpose these explanations to another tool such as Maven for example.\n Project setup The dependencies to be imported into the project are accessible with the configuration wizard.\nDepending on the nature of the hardware resources required, it is necessary to declare certain permissions in the project manifest file. In the case of the Android NFC example, access to NFC functions is declared as follows: Copy \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; ... \u0026lt;uses-permission android:name=\u0026#34;android.permission.NFC\u0026#34; /\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.nfc\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; ... \u0026lt;application ...\u0026gt; ... \u0026lt;activity ... \u0026gt; ... \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.nfc.action.TECH_DISCOVERED\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.nfc.action.TECH_DISCOVERED\u0026#34; android:resource=\u0026#34;@xml/tech_list\u0026#34; /\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt;\nYou will have to adapt this section according to the reader plugin used.\n Focus on Keyple specific code Copy ... abstract class AbstractExampleActivity : ..., CardReaderObserverSpi, CardReaderObservationExceptionHandlerSpi { ... } Copy ... class CoreExamplesActivity : AbstractExampleActivity() { private lateinit var reader: Reader override fun onCreate(savedInstanceState: Bundle?) { ... /** * Register AndroidNfc plugin Factory */ val plugin = SmartCardServiceProvider.getService().registerPlugin(AndroidNfcPluginFactoryProvider(this).getFactory()) /** * Configure Nfc Reader */ with(plugin.getReader(AndroidNfcReader.READER_NAME) as ObservableReader) { setReaderObservationExceptionHandler(this@CoreExamplesActivity) addObserver(this@CoreExamplesActivity) // with this protocol settings we activate the nfc for ISO1443_4 protocol (this as ConfigurableReader).activateProtocol(ContactlessCardCommonProtocol.ISO_14443_4.name, ContactlessCardCommonProtocol.ISO_14443_4.name) reader = this } } override fun onDestroy() { SmartCardServiceProvider.getService().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME) ... } override fun onResume() { ... try { checkNfcAvailability() if (intent.action != null \u0026amp;\u0026amp; intent.action == NfcAdapter.ACTION_TECH_DISCOVERED) run { ... // notify reader that card detection has been launched (reader as ObservableReader).startCardDetection(ObservableCardReader.DetectionMode.SINGLESHOT) ... reader.getExtension(AndroidNfcReader.class).processIntent(intent) configureUseCase1ExplicitSelectionAid() } else { ... // enable detection (reader as ObservableReader).startCardDetection(ObservableCardReader.DetectionMode.SINGLESHOT) } } catch (e: IOException) { ... } } ... private fun configureUseCase1ExplicitSelectionAid() { ... with(reader as ObservableReader) { ... if (isCardPresent) { val smartCardService = SmartCardServiceProvider.getService() /** * Get the generic card extension service */ val cardExtension = GenericExtensionService.getInstance() /** * Verify that the extension API level is consistent with the current service. */ smartCardService.checkCardExtension(cardExtension) /** * Setting of an AID based selection (in this example a Calypso REV3 PO) * * Select the first application matching the selection AID whatever the card communication * protocol keep the logical channel open after the selection */ val aid = CalypsoClassicInfo.AID_CD_LIGHT_GTML /** * Generic selection: configures a CardSelector with all the desired attributes to make * the selection and read additional information afterwards */ val cardSelection = cardExtension.createCardSelection() .filterByCardProtocol(AndroidNfcSupportedProtocols.ISO_14443_4.name) .filterByDfName(aid) /** * Create a card selection using the generic card extension. */ cardSelectionManager.prepareSelection(cardSelection) /** * Provide the Reader with the selection operation to be processed when a card is inserted. */ cardSelectionManager.scheduleCardSelectionScenario(reader as ObservableReader, ObservableCardReader.DetectionMode.SINGLESHOT, ObservableCardReader.NotificationMode.MATCHED_ONLY) ... try { val cardSelectionsResult = cardSelectionManager.processCardSelectionScenario(this) if (cardSelectionsResult.activeSmartCard != null) { val matchedCard = cardSelectionsResult.activeSmartCard ... } else { // selection failed ... } (reader as ObservableReader).finalizeCardProcessing() } catch (e: CardCommunicationException) { ... } catch (e: ReaderCommunicationException) { ... } } else { // No cards were detected ... } ... } } ... }  FAQ How to fix \u0026ldquo;More than one file was found with OS independent path \u0026lsquo;META-INF/NOTICE.md\u0026rsquo;\u0026rdquo;. Add lines below to your :app build.gradle file\nCopy android { packagingOptions { exclude \u0026#39;META-INF/NOTICE.md\u0026#39; } } ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"3809efcf55808c5f84377d047bfb6fb4","permalink":"https://keyple.org/learn/build-your-first-app/android-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/build-your-first-app/android-app/","section":"learn","summary":"This guide describes how to start a ticketing application using Keyple and Android NFC plugin to read the content of a Calypso card.","tags":null,"title":"Build your first Android application","type":"book"},{"authors":null,"categories":null,"content":" Keyple is designed to operate exchanges with secure data media such as smart cards, tags or smartphones.\nKeyple is as much as possible agnostic towards the secured media as towards the hardware allowing to communicate with them.\nIn order to achieve these objectives Keyple consists of a central core to which can be attached add-ons providing solutions to the specific needs of the targeted application. The core provides the basic services for registering add-ons and also provides generic interfaces independent of card and reader technologies.\nAdd-ons are organized into four categories:\n Card extensions, offering high-level interfaces for managing exchanges between a client application and a particular card technology. Reader plugins, which interface with the hardware through unified APIs. Distributed libraries to manage readers remotely. Additional services such as the dynamic allocation of card resources.  The diagram below shows an overview of the Keyple layers:\n  Keyple architecture layers overview  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"e451adcae425bf2919440a472b6744d6","permalink":"https://keyple.org/learn/overview/architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/overview/architecture/","section":"learn","summary":"Overall presentation of the Keyple architecture.","tags":null,"title":"Architecture","type":"book"},{"authors":null,"categories":null,"content":" Overview This guide is intended to help developers who want to create a Keyple card extension add-on for a specific card technology.\n Operating mode  Learn the card extension architecture concepts Take note of the minimal requirements Define the card commands Set up the development environment Implement the solution   Card extension architecture A Keyple card extension contains a set of objects which meet the following three interface specifications:\n Common API: public contract including a generic type common to all card extensions. Calypsonet Terminal Reader API: public contract provided be Calypso Networks Association including two specific interfaces to be implemented by the card extension and required by the card selection manager. Calypsonet Terminal Card API: private contract provided be Calypso Networks Association based on two types of interfaces:  API (Application Programming Interface): interface implemented by Keyple Service and directly usable by the card extension code. SPI (Service Provider Interface): interface to be implemented by the card extension and directly used by Keyple Service.    The component diagram below illustrates the internal API/SPI links between the card extension and Keyple Service, as well as the public APIs exposed to the client application:  \n Minimal requirements The table below lists the objects that must be created and indicates the interfaces to be implemented for each of them:\n   Object Common API Calypsonet Terminal Reader API Calypsonet Terminal Card API     Card extension service KeypleCardExtension     Card selection parser  CardSelection CardSelectionSpi   Smart card object  SmartCard SmartCardSpi   Card selector DTO   CardSelectorSpi   Card selection request DTO   CardSelectionRequestSpi   Card request DTO   CardRequestSpi   APDU request DTO   ApduRequestSpi     In the case where the smart card object has fields of type interface, it will then be necessary to define for each of them and recursively a JSON deserializer and register it during the service initialization with the method JsonUtil.registerTypeAdapter(...) provided by the Keyple Util library.\nThis will allow the transport of this object through the network when using the Keyple Distributed solution.\n   Define the card commands The card extension takes part in the communication with the card in two ways:\n implicitly, when the card is being selected, which is done directly by the client application via the Keyple Service selection manager; explicitly, when the card has been selected, on request of the client application, by direct use of the APIs exposed by the Card API.  For explicit communication, the card extension must require the client application to provide a reference to a CardReader of the Reader API. This can then be cast internally to a ProxyReaderApi of the Card API through which it will be possible to transmit card commands.\nEach card extension is free to define the APIs it considers relevant to perform card transactions.\n Set up dev environment  For Java and Android projects, the code should be compliant with Java 1.6 in order to address a wide range of applications.   If the card extension add-on is to be integrated into the Eclipse Keyple® project, it must use the following project template:\n Java template: adapt fields [CARD_EXTENSION_NAME], Xxx, xxx, TODO   Before pushing the project to GitHub the first time, you must give write permission to some scripts files via the following commands:\nCopy git update-index --chmod=\u0026#43;x \u0026#34;gradlew\u0026#34; git update-index --chmod=\u0026#43;x \u0026#34;scripts/check_version.sh\u0026#34; git update-index --chmod=\u0026#43;x \u0026#34;scripts/prepare_javadoc.sh\u0026#34;   If examples are proposed, they should be placed in the keyple-java-example repository.\nThe contribution procedure is described here.\n Implement the solution  It is important to hide the internal Calypsonet interfaces of the Calypsonet Terminal Card API from the client application.   For this purpose, it is suggested to respect the following programming pattern based on the use of:\n public interfaces, private interfaces adapters (package visibility) accessible from a public service.     API  Keyple Common API Calypsonet Terminal Reader API Calypsonet Terminal Card API   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"b7677d71ff4e99ab19423e5f98a625d9","permalink":"https://keyple.org/learn/developer-guide/card-extension-add-on/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/developer-guide/card-extension-add-on/","section":"learn","summary":"How to develop an add-on to manage a specific type of card.","tags":null,"title":"Card Extension Add-on Developer Guide","type":"book"},{"authors":null,"categories":null,"content":" Overview Keyple provides the \u0026ldquo;Keyple Distributed\u0026rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal.\nIn this way, you can manage transactions within a distributed architecture.\nThe diagram below shows the location of the Keyple Distributed components in the software layers used in a distributed architecture:\n Keyple Distributed - Solution layers overview   How to use it  In pre-requisite, read Standalone Application User Guide to understand the main concepts of Keyple in a standalone application. Learn main terms and concepts of the Keyple Distributed solution. Find your usage mode. This will help you to determine exactly which library and API to use. Import into your project the libraries specified by your usage mode. Implement the transport layer adapted to your network configuration. Implement your ticketing services as specified in the associated usage mode.   Concepts Here are the main concepts to keep in mind before continuing to read this user guide:\n   Concept Description     Remote Lib This is the keyple-distributed-remote-java-lib library.\nIt must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.   Local Lib This is the keyple-distributed-local-java-lib library.\nIt must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.   Network Lib This is the keyple-distributed-network-java-lib library.\nIt must always be imported because it contains the network elements used by Remote Lib and Local Lib.   Remote Plugin Part of the Remote Lib, this is a Keyple reader plugin extension which provides only Remote Readers to the application. It manages data exchanges with the Local Service. This reader plugin extension must be registered to the smart card service like any Keyple reader plugin.   Remote Reader Part of the Remote Lib, this is a Keyple reader extension which has some specificities:\n- each remote reader is connected to a local reader;\n- any command sent by the application to a remote reader will be forwarded to the associated local reader;\n- in some cases only, an event occurring on a local reader or plugin will be automatically forwarded to the associated remote reader or plugin.   Local Service Part of the Local Lib, this is a Keyple distributed local service extension which ensures data exchange between the Remote Plugin and local plugins and readers. It must be registered to the smart card service.   Factory Remote Plugin and Local Service each have a specific factory class to initialize them.   Node Remote Plugin and Local Service each are bind to a specific internal node which is responsible for the interfacing with the Network Endpoint.   Network Endpoint At the user\u0026rsquo;s charge, this component ensures the network exchanges between the Remote Plugin and Local Service nodes.      #concepts-table-1 table th:first-of-type { width: 130px; }  The diagram below illustrates the main functional concepts through a standard use case:\n Keyple Distributed - Concepts - Main use case  The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.\nThese could be for example a ticketing reloading service, where the business logic would be on the terminal without local readers, with thin clients on A \u0026amp; B terminals communicating locally with the cards.\nIn this use case, the Keyple Distributed solution is use for card communication.\n Keyple Distributed - Concepts - One remote plugin connected to many local services  Here is another example, but this time it illustrates several remote plugins connected to the same local service.\nThese could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.\nIn this use case, the Keyple Distributed solution is use for SAM communication.\n Keyple Distributed - Concepts - Many remote plugins connected to one local service   Usage modes The Keyple Distributed solution offers two different usage modes, each one having a specific API designed on a Client-Server model:\n   Usage mode Description     Reader Client Side Allows a server application to control a smart card reader available on a client (e.g. Card reader).   Reader Server Side Allows a client application to control a smart card reader available on a server (e.g. SAM reader, HSM).      #plugins-table-1 table th:first-of-type { width: 190px; }  Each mode provides a different Remote Plugin and Local Service and their associated factories.\nIn an application, it is possible to use simultaneously several usage modes and as many instances of a usage mode as you want, as long as the components are initialized with different names.\nReader Client Side This usage mode allows a server application to control a smart card reader available on a client (e.g. Card reader).\nIn this mode, the client is the initiator of the application processing following the local plugin or reader events (reader connection/disconnection or card insertion/removal).\nHe can hand over to the server whenever he wants to perform a remote ticketing service on a card present in one of his local readers.\nThe table below shows the classes and interfaces available for this usage mode.\nInterfaces marked with an asterisk \u0026ldquo;*\u0026rdquo; come from the Keyple Service API:\n   API Client Server     Library to use Local Lib Remote Lib   Factory builder to be used LocalServiceClientFactoryBuilder RemotePluginServerFactoryBuilder   Factory to be registered LocalServiceClientFactory RemotePluginServerFactory   Local Service / Remote Plugin DistributedLocalService * ObservablePlugin *   Local Service / Remote Plugin extension LocalServiceClient RemotePluginServer   Reader Any kind of reader Reader *   Reader extension Device specific RemoteReaderServer     It is the responsibility of the client application to observe and configure the local plugins and readers.   OPERATING MODE  Server  Build an instance of the RemotePluginServerFactory using the RemotePluginServerFactoryBuilder class, specifying a unique name for the Remote Plugin to be registered and your network endpoint implementation if required. Register the Remote Plugin to the smart card service by providing the previously built factory. Cast the registered plugin into an ObservablePlugin and add an event observer to it.\nPlease note that this remote plugin is observable only to trigger ticketing services on the server side, but does not allow observation on the local plugin such as reader connection or disconnection. Await for events of type PluginEvent.Type.READER_CONNECTED.\nThis type of event indicates to the server that a client asks it to perform a specific ticketing service using the connected remote reader. When an event occurs, you must retrieve the connected remote reader from the registered plugin using the name of the reader contained in the event.\nPlease note that the remote reader is strictly an instance of Reader, even if the local reader is an ObservableReader.\nThis usage mode does not allow to observe reader events such as card insertion or removal from the server.\nIt is the responsibility of the client to observe the local reader if needed, then to ask the server to execute a specific remote service depending on the case. Use information inside the RemoteReaderServer extension of the remote reader to identify the ticketing service to execute. Execute the specified ticketing service using the remote reader and all of its other information. End the remote ticketing service by invoking the associated method provided by the RemotePluginServer extension of the remote plugin.\nIt is then possible to send additional information to the client if necessary.   Client  Build an instance of the LocalServiceClientFactory using the LocalServiceClientFactoryBuilder class, specifying a unique name for the Local Service to be registered and your network endpoint implementation. Register the Local Service to the smart card service by providing the previously built factory. Register at least a local plugin to the smart card service and get the name of the local reader to connect to the server. Execute the desired remote service by invoking the associated method provided by the LocalServiceClient extension of the local service by specifying the identifier of the ticketing service to be executed, the name of the target local reader, and transmitting to the server if necessary the contents of the previously read smart card or additional information.    Reader Server Side This usage mode allows a client application to control a smart card reader or a pool of smart card readers available on a server (e.g. SAM reader, HSM).\nThe Keyple Distributed solution offers for this usage mode a remote control of all types of plugins (Plugin, ObservablePlugin, PoolPlugin):\n Regular plugin (Plugin or ObservablePlugin)  During the remote plugin registration process, the client automatically creates a remote reader for each local reader of the set of local plugins on the server.\nIf the factory has been properly configured, then the remote plugin and reader behave like the local plugins and readers.\nIt is then possible to observe directly from the client the plugin and/or reader events (reader connection/disconnection or card insertion/removal) if desired.\nThe table below shows the classes and interfaces available for this usage mode in the case of a regular plugin.\nInterfaces marked with an asterisk \u0026ldquo;*\u0026rdquo; come from the Keyple Service API:\n   API Client Server     Library to use Remote Lib Local Lib   Factory builder to be used RemotePluginClientFactoryBuilder LocalServiceServerFactoryBuilder   Factory to be registered RemotePluginClientFactory LocalServiceServerFactory   Remote Plugin / Local Service Plugin * or\nObservablePlugin * DistributedLocalService *   Remote Plugin / Local Service extension RemotePluginClient LocalServiceServer   Reader Reader * or\nObservableReader Any kind of reader   Reader extension RemoteReaderClient Device specific     Pool plugin (PoolPlugin)  The dynamic reader allocation process will search for the first available reader among all or a subset of the pool plugins registered on the server.\nIt is possible to define during the configuration phase of the local service factory a filter on the names of the pool plugins to use.\nThe table below shows the classes and interfaces available for this usage mode in the case of a pool plugin.\nInterfaces marked with an asterisk \u0026ldquo;*\u0026rdquo; come from the Keyple Service API:\n   API Client Server     Library to use Remote Lib Local Lib   Factory builder to be used RemotePoolPluginClientFactoryBuilder LocalServiceServerFactoryBuilder   Factory to be registered RemotePluginClientFactory LocalServiceServerFactory   Remote Plugin / Local Service PoolPlugin * DistributedLocalService *   Remote Plugin / Local Service extension RemotePluginClient LocalServiceServer   Reader Reader * Any kind of reader   Reader extension RemoteReaderClient Device specific     Whatever the type of plugin, it is the responsibility of the server application to configure the local plugins and readers.   OPERATING MODE  Server  Build an instance of the LocalServiceServerFactory using the LocalServiceServerFactoryBuilder class, specifying a unique name for the Local Service to be registered and your network endpoint implementation if required. Register the Local Service to the smart card service by providing the previously built factory. Register at least a local plugin or pool plugin to the smart card service, depending on your case.   Client  Build an instance of the RemotePluginClientFactory using the RemotePluginClientFactoryBuilder or RemotePoolPluginClientFactoryBuilder class depends on the type of plugin that you want to manage, specifying a unique name for the Remote Plugin to be registered and your network endpoint implementation. Register the Remote Plugin to the smart card service by providing the previously built factory. Use the registered remote plugin as a local plugin.     Network configuration The Keyple Distributed solution does not provide the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between Remote Plugin and Local Service components.\nSynchronous Choose this mode if you want to implement a Client-Server synchronous communication protocol, such as standard HTTP for example.\n    Client Server     Network endpoint SPI to be implemented SyncEndpointClientSpi -   Node API SyncNodeClient SyncNodeServer   Method to be used when initializing the factory withSyncNode(...) withSyncNode()   Method provided by the remote plugin or local service extension\nto use to access the node - getSyncNode()    Here is the minimal algorithm to implement in a context with a single server instance:\n Keyple Distributed - Synchronous network implementation  In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a serverNodeId are routed to the server associated with a SyncNodeServer node having the serverNodeId.\nAsynchronous Choose this mode if you want to implement a Full-Duplex asynchronous communication protocol, such as Web Sockets for example.\n    Client Server     Network endpoint SPI to be implemented AsyncEndpointClientSpi AsyncEndpointServerSpi   Node API AsyncNodeClient AsyncNodeServer   Method to be used when initializing the factory withAsyncNode(...) withAsyncNode(...)   Method provided by the remote plugin or local service extension\nto use to access the node getAsyncNode() getAsyncNode()    Here is the minimal algorithm to implement:\n Keyple Distributed - Asynchronous network implementation  Exchanged data The data exchanged between Remote Plugin and Local Service components are contained in the DTO (Data Transfer Object) MessageDto. It is built and processed by the plugin and you don\u0026rsquo;t need to modify it.\nHowever, it is necessary in some contexts to access certain information such as the sessionId in the case of asynchronous communication or the serverNodeId in the case of synchronous communication with several server instances.\n API  Local API Network API Remote API   Examples  Java examples   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"8a904b9f9936e7ea56be3cfe5bc9e243","permalink":"https://keyple.org/learn/user-guide/distributed-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/distributed-application/","section":"learn","summary":"How to develop an end-user application using network communications.","tags":null,"title":"Distributed Application User Guide","type":"book"},{"authors":null,"categories":null,"content":" The Calypso Networks Association has implemented several advanced demos to show the possibilities of ticketing terminals based on Keyple Java.\nTwo Android applications to emulate:\n an autonomous validator on Android-based ticketing terminals: the machine automatically starts a secure session when a contactless card is detected, the last transport event et the available ticketing contracts are checked, and if the access is granted a new event is written. a hand-held inspection terminal on Android portable terminals: an operator can check the content of a card.  Also proposed, the settings to integrate these two Android demos to terminals from Coppernic, Famoco, Flowbird, and Bluebird, using the dedicated plugins provided by CNA.\nThe server and client applications to operate a remote sale and ticketing reload service:\n in the back-office side, a Java server application to process the ticketing sale and to manage the Calypso secure session to reload contracts in remote cards. The server manages a pool of Calypso SAM using the PC/SC plugin and the Calypso SAM resource manager. on the customer side, an Android application loaded in a common NFC phone provides the graphic user interface to request the ticket purchase. The Android NFC plugin is used to communicate with the contactless card. The Calypso card commands are relayed from the ticketing server using the Keyple distributed module.  More guides on these demos on the CNA website.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1637224846,"objectID":"d252d9606db38c1e3265863b0c893bf8","permalink":"https://keyple.org/external-resources/external-add-ons/ticketing-demos-by-cna/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/external-resources/external-add-ons/ticketing-demos-by-cna/","section":"external-resources","summary":"Ticketing applications to emulate an autonomous validator, a hand-held inspection terminal, a distributed solution for remote ticket sales and loading","tags":null,"title":"Advanced ticketing demos by the Calypso Networks Association","type":"book"},{"authors":null,"categories":null,"content":"  Coming soon   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"8c80269a49e13a1d6fb880d95fc68e9b","permalink":"https://keyple.org/learn/build-your-first-app/cpp-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/build-your-first-app/cpp-app/","section":"learn","summary":"This quick start describes how to create a ready-to-execute C++ command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first C++ application","type":"book"},{"authors":null,"categories":null,"content":" Overview Keyple provides a card extension add-on dedicated to the Calypso® card technology.\nThis component allows operating commands with a Calypso card and to manage a secure Calypso transaction in a simple way. It completely hides the details of APDU orders that are sent to Calypso cards and SAMs, which are usually tedious operations.\nThe main features are:\n support for different card revisions; object mapping of card data structures; complete management of the secure session with SAMs; PIN code management; Stored Value operations management; card invalidation / rehabilitation.  The diagram below illustrates the organization of a Calypso application based on Keyple:  \n Operating mode  Pre-requisites:\n Have a global view of Calypso product concepts (cards, SAM, security principles) Have read the Standalone Application User Guide to understand the main concepts of Keyple in a standalone application     Access to the Calypso card extension service Select a card Set up the security settings (optional) Operate a card transaction   The Calypso extension service As part of the Calypso card extension add-on, the Calypso extension service is the provider of the API implementations.\nThe service is accessible by invoking the CalypsoExtensionService.getInstance() static method.\nCopy CalypsoExtensionService calypsoExtensionService = CalypsoExtensionService.getInstance(); During initialization, it is recommended to check the extension with the smart card service to ensure the compatibility of the different libraries involved.\nIn case of incompatibility a warning will be produced in the log file.\nCopy smartCardService.checkCardExtension(calypsoExtensionService);  Select a card In order to perform a transaction it is necessary to have selected the card first.\nTo do this, you must create a selection case for a selection scenario by invoking the createCardSelection() method.\nIn addition to the filtering capabilities offered by Keyple Service, the Calypso Selection API allows you to add commands that will be sent to the card after a successful selection (the details of these features are described in the API documentation).\nThe resulting SmartCard can be cast to a CalypsoCard object which concentrate all known information about the card being processed. Its content is dynamically updated during the transaction. The client application will use it to get the data necessary for its business logic.\nCopy // Create a card selection manager. CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager(); // Create a card selection using the Calypso card extension. cardSelectionManager.prepareSelection( calypsoExtensionService .createCardSelection() .filterByDfName(AID)); // Actual card communication: process the card selection. CardSelectionResult cardSelectionResult = cardSelectionManager.processCardSelectionScenario(cardReader); // Check the selection result. if (cardSelectionResult.getActiveSmartCard() == null) { throw new IllegalStateException( \u0026#34;The card selection failed.\u0026#34;); } // Get the SmartCard resulting of the selection. CalypsoCard calypsoCard = (CalypsoCard) cardSelectionResult.getActiveSmartCard();  Set up security settings  The security settings must be initialized only for secure transactions.   The API offers several types of settings such as choosing the SAM to use, enabling various modes, specifying keys for legacy cards, etc\u0026hellip; (see the API documentation for more information).\nWhen using a SAM, it is necessary to select it on a relevant reader. This selection can be done with the createSamSelection() method and its direct processing by a reader or with the Card Resource Service.\nIn the case of the Card Resource Service, you have to create a profile extension using the createSamResourceProfileExtension(...) method, specifying the previously built selection case, and then associate it to a dedicated profile in the service (see the Card Resource Service User Guide).\nThe following snippet shows the initialization of the card resource service with a SAM profile: Copy // Create a SAM selection case CalypsoSamSelection samSelection = CalypsoExtensionService.getInstance().createSamSelection(); // Create a SAM resource profile extension CardResourceProfileExtension samCardResourceExtension = CalypsoExtensionService.getInstance().createSamResourceProfileExtension(samSelection); // Get the card resource service CardResourceService cardResourceService = CardResourceServiceProvider.getService(); // Create a minimalist configuration (no plugin/reader observation) cardResourceService .getConfigurator() .withPlugins( PluginsConfigurator.builder().addPlugin(plugin, new ReaderConfigurator()).build()) .withCardResourceProfiles( CardResourceProfileConfigurator.builder(SAM_PROFILE_NAME, samCardResourceExtension) .withReaderNameRegex(readerNameRegex) .build()) .configure(); // Start the card resource service cardResourceService.start(); // Verify the resource availability CardResource cardResource = cardResourceService.getCardResource(SAM_PROFILE_NAME); if (cardResource == null) { throw new IllegalStateException( String.format( \u0026#34;Unable to retrieve a SAM card resource for profile \u0026#39;%s\u0026#39; from reader \u0026#39;%s\u0026#39; in plugin \u0026#39;%s\u0026#39;\u0026#34;, SAM_PROFILE_NAME, readerNameRegex, plugin.getName())); } // Release the resource cardResourceService.releaseCardResource(cardResource);\nHere is the creation of the security settings using a SAM resource obtained from the card resource service: Copy // Create security settings that reference the same SAM profile requested from the card resource service. CardResource samResource = CardResourceServiceProvider.getService().getCardResource(SAM_PROFILE_NAME); CardSecuritySetting cardSecuritySetting = CalypsoExtensionService.getInstance() .createCardSecuritySetting() .setSamResource(samResource.getReader(), (CalypsoSam) samResource.getSmartCard());\n Operate a card transaction It is possible to perform secure or non-secure transactions depending on the need. A transaction is managed by a dedicated CardTransactionManager which is provided by the Calypso extension service.\nThe transaction manager provides high-level API to manage transactions with a Calypso card. The provided CalypsoCard object is kept and updated dynamically all along the transaction process.\nThe transaction takes place in several repeatable steps:\n Preparation of the commands to be sent to the card. Several command preparations can be stacked (no communication neither with the card nor with the SAM). Processing of the prepared commands. Performs all necessary communications with the card and/or the SAM to carry out the previously prepared operations.  Copy try { // Performs file reads using the card transaction manager in secure mode. cardExtension .createCardTransaction(cardReader, calypsoCard, cardSecuritySetting) .prepareReadRecordFile(SFI_ENVIRONMENT_AND_HOLDER, RECORD_NUMBER_1) .processOpening(WriteAccessLevel.DEBIT) .prepareReleaseCardChannel() .processClosing(); } finally { try { CardResourceServiceProvider.getService().releaseCardResource(samResource); } catch (RuntimeException e) { logger.error(\u0026#34;Error during the card resource release: {}\u0026#34;, e.getMessage(), e); } }  API  Calypsonet Terminal Reader API Calypsonet Terminal Calypso API Keyple Common API Keyple Card Calypso API   Examples  Java examples   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"1d609d9f8b83fb8096714c6553c2e185","permalink":"https://keyple.org/learn/user-guide/calypso-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/calypso-application/","section":"learn","summary":"How to develop an end-user application using the Calypso card extension add-on.","tags":null,"title":"Calypso Application User Guide","type":"book"},{"authors":null,"categories":null,"content":" Overview An application that performs secure transactions on smart cards may need to dynamically allocate a card resource dedicated to the current transaction to manage the security of the transaction (e.g. SAM or HSM).\nTo meet this need, Keyple proposes the Service Resource component which provides a service that supports dynamic card resource allocation, using a profile-based filtering mechanism.\n Features  card resource locking during use; automatic monitoring of observable plugins and readers; customizable profile-based filtering mechanism (specific plugins list, reader name using regular expression, reader group name for pool plugins, specific card selection); specific reader configuration capability; allocation priority management; two allocation modes (blocking, non-blocking); multiple allocation strategies (first available card resource, cyclic, random); configurable allocation timeout; failure management.   Operating mode  Access to the service Access to the configurator Register plugins and/or pool plugins to be used Define profiles for card resource filtering Set the allocation mode (optional) Apply the configuration Start the service Allocate a resource Use the resource Release the used resource   Access to the service Invoke the CardResourceServiceProvider.getService() static method to access the service.\nCopy CardResourceService cardResourceService = CardResourceServiceProvider.getService();  Configure the service Access to the configurator Invoke the getConfigurator() method on the service to get a new instance of the service configurator. It is built on the fluent pattern, and it guides you through the various steps to be specified during the configuration process.\nCopy cardResourceService.getConfigurator()... Register plugins If you plan to use plugins of type Plugin or ObservablePlugin in the card resource service, you must specify the global ordered list of plugins to be used when searching for a card resource.\nThis is the default list that will be applied for profiles that have not explicitly specified another list.\nPlease note that the order in which plugins are added is important.\nTo add one or more plugins, you need to create a new instance of the PluginsConfigurator class and provide it to the configurator using the withPlugins(...) method.\nIt is possible to configure the following:\n specify the global allocation strategy to all added plugins; specify the global usage timeout of a resource; activate independently plugin by plugin the monitoring of the plugin and/or its readers in order to allow the service to automatically update the list of resources. In this case you will have to provide a handler to be informed in case of error or crash of the observation thread.  For each plugin added, you will need to provide an implementation of the ReaderConfiguratorSpi interface to automatically configure new readers or those already connected.\nCopy .withPlugins( PluginsConfigurator.builder() .withAllocationStrategy(...) .withUsageTimeout(...) .addPluginWithMonitoring(...) .addPlugin(...) .addPluginWithMonitoring(...) .build()) Register pool plugins If you plan to use plugins of type PoolPlugin in the card resource service, you must specify the global ordered list of pool plugins to be used when searching for a card resource.\nThis is the default list that will be applied for profiles that have not explicitly specified another list.\nPlease note that the order in which plugins are added is important. If you use both plugins and pool plugins in your configuration, it is possible to specify if pool plugins should be taken into account first or not during the resource allocation process.\nTo add one or more pool plugins, you need to create a new instance of the PoolPluginsConfigurator class and provide it to the configurator using the withPoolPlugins(...) method.\nCopy .withPoolPlugins( PoolPluginsConfigurator.builder() .usePoolFirst() .addPoolPlugin(...) .addPoolPlugin(...) .build()) Define profiles A profile defines a set of filters which will be used when enumerating the available resources. The profile identifiers will be used when allocating a resource.\nTo add profiles, you must create a new instance of the CardResourceProfileConfigurator class for each profile and provide them to the configurator using the withCardResourceProfiles(...) method.\nIt is possible to configure the following:\n override the global plugin list to use; set reader name filter using a regex value; set reader group reference filter in case of pool plugins.  You also need to provide an implementation of the CardResourceProfileExtension interface in order to be able to customize the filtering if needed and to return to the service an implementation of the SmartCard interface when a compatible card is found. The SmartCard found will be returned to the user by the allocation process.\nCopy .withCardResourceProfiles( CardResourceProfileConfigurator.builder(RESOURCE_A, yourCardResourceProfileExtensionA) .withReaderNameRegex(READER_NAME_REGEX_A) .build(), CardResourceProfileConfigurator.builder(RESOURCE_B, yourCardResourceProfileExtensionB) .withReaderNameRegex(READER_NAME_REGEX_B) .build(), CardResourceProfileConfigurator.builder(RESOURCE_C, yourCardResourceProfileExtensionC) .withReaderGroupReference(READER_GROUP_REFERENCE_C) .build()) Set allocation mode By default, the card resource service is configured with a non-blocking allocation mode. This means that if no resources are available at the time of the request for an allocation, then the service returns the hand directly.\nThe withBlockingAllocationMode(...) method configure the service to perform allocations in blocking mode so that it only hands over when a resource becomes available.\nYou will then have to specify the duration between two search cycles and the maximum waiting time so that the service can always return after a certain time if it has still not found anything.\nCopy .withBlockingAllocationMode(100, 10000) // e.g. search each 100 ms during 10 seconds maximum Apply the configuration Invoke the configure() method on the configurator to finalise and apply the configuration.\nOnce finalized, the new configuration replaces the previous one but does not change the state of the service. If the service was already started at that moment, then it stops, applies the new configuration, and restarts.\nCopy .configure();  Use the service Start the service Invoke the start() method on the service to start the service using the current configuration. The service will initialize the list of available resources for each profile and start the monitoring processes if requested.\nCopy cardResourceService.start(); Allocate a resource Invoke the getCardResource(...) method on the service to retrieve and lock a card resource. You just have to specify the name of the profile to use.\nIf the allocation mode is blocking, then the method will wait a while for a resource to become available.\nCopy CardResource cardResource = cardResourceService.getCardResource(RESOURCE_A); Release a resource Invoke the releaseCardResource(...) method on the service to unlock a card resource. You just have to provide the card resource to release.\nCopy cardResourceService.releaseCardResource(cardResource); Delete a resource Invoke the removeCardResource(...) method on the service to remove a card resource from the available card resource list. This can be useful in some cases if the card or reader has failed. You just have to provide the card resource to remove.\nCopy cardResourceService.removeCardResource(cardResource); Stop the service Invoke the stop() method on the service to stop the service if needed. Any monitoring is then stopped and no more resources are accessible.\nCopy cardResourceService.stop();  API  API documentation \u0026amp; class diagram   Example  Java example   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1634199549,"objectID":"90cca05980b207aa4a4b326e816d455c","permalink":"https://keyple.org/learn/user-guide/card-resource-service/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/card-resource-service/","section":"learn","summary":"How to develop an end-user application using the Card Resource Service.","tags":null,"title":"Card Resource Service User Guide","type":"book"},{"authors":null,"categories":null,"content":" This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.\nUpgrade from:\n 1.0.0 to 2.0.0   Upgrade from \u0026ldquo;1.0.0\u0026rdquo; to \u0026ldquo;2.0.0\u0026rdquo; Here is a comparative review of the main API changes between Keyple 1.0.0 and 2.0.0:\nDependency management Use the configuration wizard to correctly import the new artifacts into your project.\nInitial configuration Use of a provider to access the smart card service  1.0.0  Copy SmartCardService smartCardService = SmartCardService.getInstance();  2.0.0  Copy SmartCardService smartCardService = SmartCardServiceProvider.getService(); Use of builders to instantiate plugin factories  1.0.0  Copy Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, new ExceptionHandlerImpl())); ... ((ObservableReader) reader).addObserver(new CardReaderObserver());  2.0.0  Copy Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build()); ... ((ObservableReader) reader).setReaderObservationExceptionHandler(new ExceptionHandlerImpl()); ((ObservableReader) reader).addObserver(new CardReaderObserver());  Exception handlers are no longer required when registering the plugin but only when starting the observation.   Use of a new interface dedicated to the management of protocols  1.0.0  Copy reader.activateProtocol( PcscSupportedContactlessProtocols.ISO_14443_4.name(), ContactlessCardCommonProtocols.ISO_14443_4.name());  2.0.0  Copy ((ConfigurableReader) reader).activateProtocol( PcscSupportedContactlessProtocols.ISO_14443_4.name(), ContactlessCardCommonProtocols.ISO_14443_4.name()); Use of plugin and reader extensions for specific configurations  The examples below show the evolutions for the configuration of a PC/SC reader but the principle is the same for all plugins and readers.    1.0.0  Copy reader .setContactless(true) .setIsoProtocol(PcscReader.IsoProtocol.T1);  2.0.0  Copy reader.getExtension(PcscReader.class) .setContactless(true) .setIsoProtocol(PcscReader.IsoProtocol.T1); Card selection Use a manager instead of service for card selection  1.0.0  Copy CardSelectionsService cardSelectionsService = new CardSelectionsService();  2.0.0  Copy CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager();  A new instance of the card selection manager is provided by the smart card service.   Use of a card extension to create a card selection  1.0.0  Copy GenericCardSelectionRequest genericCardSelectionRequest = new GenericCardSelectionRequest( CardSelector.builder() .aidSelector(CardSelector.AidSelector.builder().aidToSelect(cardAid).build()) .build());  2.0.0  Copy CardSelection cardSelection = GenericExtensionService.getInstance() .createCardSelection() .filterByDfName(cardAid);   The CardSelector class does not exist anymore. A generic card extension is now available. The card extension service is used to configure the card selection.    Explicit card selection  1.0.0  Copy CardSelectionsResult selectionResult = cardSelectionsService.processExplicitSelections(reader);  2.0.0  Copy CardSelectionResult selectionResult = cardSelectionManager.processCardSelectionScenario(reader);  Note the removal of the \u0026ldquo;s\u0026rdquo; in CardSelectionResult.   Scheduled card selection  1.0.0  Copy ((ObservableReader) reader) .setDefaultSelectionRequest( defaultSelectionsRequest, ObservableReader.NotificationMode.MATCHED_ONLY, ObservableReader.PollingMode.REPEATING); ((ObservableReader) reader).addObserver(new CardReaderObserver());  2.0.0  Copy cardSelectionManager.scheduleCardSelectionScenario( (ObservableReader) reader, ObservableReader.DetectionMode.REPEATING, ObservableReader.NotificationMode.MATCHED_ONLY); ((ObservableReader) reader).setReaderObservationExceptionHandler(new ExceptionHandlerImpl()); ((ObservableReader) reader).addObserver(new CardReaderObserver());  The selection data is no longer provided to the observable reader but to the selection manager. It is the observable reader that is provided to the selection manager.   The processing of the result of the selection response has changed  1.0.0  Copy AbstractSmartCard smartCard = defaultSelection .processDefaultSelectionsResponse(event.getDefaultSelectionsResponse()) .getActiveSmartCard();  2.0.0  Copy SmartCard smartCard = cardSelectionManager .parseScheduledCardSelectionsResponse(event.getScheduledCardSelectionsResponse()) .getActiveSmartCard();  AbstractSmartCard was changed to the SmartCard interface.   Calypso Card Extension Vocabulary  PO has been replaced by Card.  SAM management The SAM resource manager has been replaced by a generic Card Resource Service.\nCard transaction Access to the card transaction manager has changed. It is now done through the card extension service.\n 1.0.0  Copy PoTransaction poTransaction = new PoTransaction( new CardResource\u0026lt;CalypsoPo\u0026gt;(poReader, calypsoPo), CalypsoUtils.getSecuritySettings(samResource));  2.0.0  Copy CardTransactionManager transactionManager = CalypsoExtensionService.getInstance() .createCardTransaction(cardReader, calypsoCard, cardSecuritySetting); Distributed systems Remote plugin registration  1.0.0  Copy // Init the remote plugin factory. RemotePluginServerFactory factory = RemotePluginServerFactory.builder() .withDefaultPluginName() .withSyncNode() .withPluginObserver(new RemotePluginServerObserver()) .usingEventNotificationPool( Executors.newCachedThreadPool(r -\u0026gt; new Thread(r, \u0026#34;server-pool\u0026#34;))) .build(); // Register the remote plugin to the smart card service using the factory. SmartCardService.getInstance().registerPlugin(factory);  2.0.0  Copy RemotePluginServerFactory factory = RemotePluginServerFactoryBuilder.builder(REMOTE_PLUGIN_NAME) .withSyncNode() .build(); // Register the remote plugin to the smart card service using the factory. ObservablePlugin plugin = (ObservablePlugin) SmartCardServiceProvider.getService().registerPlugin(factory); // Init the remote plugin observer. plugin.setPluginObservationExceptionHandler(new ExceptionHandlerImpl()); plugin.addObserver(new RemotePluginServerObserver());   You have to specify the name of the plugin. It is no longer necessary to provide a thread pool. The exception handler must be provided as for any observable plugin before adding an observer.    Local service registration  1.0.0  Copy // Init the local service using the associated factory. LocalServiceClientFactory.builder() .withDefaultServiceName() .withSyncNode(endpointClient) .withoutReaderObservation() .getService();  2.0.0  Copy // Init the local service factory. LocalServiceClientFactory factory = LocalServiceClientFactoryBuilder.builder(LOCAL_SERVICE_NAME) .withSyncNode(endpointClient) .build(); // Init the local service using the associated factory. SmartCardServiceProvider.getService().registerDistributedLocalService(factory);   You have to specify the name of the local service. The local service must be registered with the smart card service. It behaves like a plugin or reader and also provides an extension to access specific settings.    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636997377,"objectID":"335f2d8f16f4b12139105b69d66d7aab","permalink":"https://keyple.org/learn/user-guide/migrate-to-2-0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/user-guide/migrate-to-2-0/","section":"learn","summary":"How to upgrade an existing Keyple application using an earlier version.","tags":null,"title":"Upgrade from an earlier version of Keyple","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso C++ component is a Keyple reader extension for Calypso® technology.\nIt can be used on PC and MAC platforms.\nDocumentation  Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"9b54e3d7228023677a742ddf7d6531dc","permalink":"https://keyple.org/components-cpp-0.9/extensions/calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/extensions/calypso/","section":"components-cpp-0.9","summary":"Keyple C++ reader extension for Calypso® technology.","tags":null,"title":"Keyple Calypso","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso Java component is a Keyple reader extension for Calypso® technology.\nIt can be used on PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-calypso\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"f34034c18095933d9205c47ba7043c73","permalink":"https://keyple.org/components-java-1.0/extensions/calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/extensions/calypso/","section":"components-java-1.0","summary":"Keyple Java reader extension for Calypso® technology.","tags":null,"title":"Keyple Calypso","type":"book"},{"authors":null,"categories":null,"content":" Keyple is compliant with the terminal APIs provided by the Calypso Networks Association that standardize how to manage cards, readers, reader events and card selection.\nThis compliance allows Keyple to obtain certifications from the Calypso Networks Association. It is a guarantee of reliability and reproducibility of the processes implemented on a variety of devices.\nReader \u0026amp; Card APIs These two APIs standardize the way that a reader and a card interact. They are generic and apply to all card and reader technologies.\nThe Reader API must be used by developers of applications and card extensions, while the Card API must be used only by developers of card extensions.\n  Calypsonet Terminal Reader Java API  Calypsonet Terminal Card Java API  Calypso API This high-level API standardizes the way to interact with a Calypso® product (card, NFC smartphone applet/application, SAM, etc\u0026hellip;).\nThis API should be used by developers of Calypso applications.\n  Calypsonet Terminal Calypso Java API  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635429016,"objectID":"d784e843aa8a74dd57af3826f92aeb21","permalink":"https://keyple.org/components-java/standards-compliance/calypsonet-apis/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standards-compliance/calypsonet-apis/","section":"components-java","summary":"Keyple is compliant with the terminal APIs provided by Calypsonet that standardize how to manage cards, readers, reader events and card selection.","tags":null,"title":"Calypsonet Terminal Java APIs","type":"book"},{"authors":null,"categories":null,"content":" The dependencies between the Keyple components are shown in the diagram below:\n  Here are the most important things to remember:\n Each component has its own life cycle. There are two types of Keyple components: APIs and libraries. Some APIs are provided by Calypso Networks Association. APIs contain only interfaces. Libraries contain interfaces and their implementation. Some APIs are public while others are internal. All libraries are public. All libraries and public APIs can be used by the developer of the client application. The internal APIs are intended for the developer of Keyple add-ons only (e.g. custom reader plugin, custom card extension or custom distributed solution).  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"54a757e698099ba879acffdfec924b06","permalink":"https://keyple.org/components-java/overview/components-map/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/overview/components-map/","section":"components-java","summary":"General presentation of the dependencies between the different Keyple components.","tags":null,"title":"Java - Components map","type":"book"},{"authors":null,"categories":null,"content":" Overview You can find here some in-depth technical information about Keyple core services.\n Observable reader states An observable reader is active only when at least one reader observer is registered, and if the start of the detection has been requested. When active, an observable reader could switch between three internal states:\n Wait for card insertion Wait for card processing Wait for card removal  In the nominal case, a reader observer indicates to the observable reader that the processing of the card is finished by releasing the card channel. To manage a failure of the reader observer process, the observable reader interface provides also a method to finalize the card processing.\n Observable reader states  The states could be switched:\n due to an explicit API request (blue arrows):  the release of the card channel, the call of an observable reader method:  the addition or the remove of an observable reader, a request to start or stop the detection, to finalize the card processing.     Or because of an external event (red arrows), the insertion or the remove of a card.  the insertion of a card causing the observable reader to notify a CARD_MATCHED reader event (in case of successful scheduled selection) or a CARD_INSERTED reader event (notification mode defined as ALWAYS). the removal of a card causing the observable reader to notify a CARD_REMOVED reader event.    If a card detection is started with the REPEATING detection mode, then later when the card is removed, the reader starts again the detection of a new card.\nNotification of card removal during the card removal wait state is a feature of any observable reader. However, some observable readers may additionally have the ability to notify removal during the card processing state.\n Card selection modes Depending on the card transaction use case, or on the reader capability, there are two ways to manage the selection of a card:\n Either on a simple reader, a selection could be operated directly by transmitting the card selection scenario. In this case the same entity manages both the card selection and the card processing. Otherwise, on an observable reader, a scheduled card selection could be defined. In this case the card selection is operated automatically at the insertion of the card. In this case, the card selection is next managed by the observable reader, but the card processing is managed by a reader observer.   Card selection modes   Internal adapters (release) Service    Card resource service    Distributed     Internal adapters (snapshot) Service    Card resource service    Distributed    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"1edfec56e9f96cf03cac91e0ce7dac73","permalink":"https://keyple.org/learn/keyple-in-depth/core-services/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/keyple-in-depth/core-services/","section":"learn","summary":"In-depth technical information about Keyple core services.","tags":null,"title":"Core services","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Local Java component is the part of the Keyple Distributed solution which contains all the local services.\nIt must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.\nIt is important to note that it uses and exposes the APIs exposed by Keyple Distributed Network component.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-distributed-local:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-distributed-local\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"ff75cf75685921ed7d916449943d9a5e","permalink":"https://keyple.org/components-java-1.0/distributed-systems/local/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/distributed-systems/local/","section":"components-java-1.0","summary":"Part of the Keyple Distributed solution which contains all the local services.","tags":null,"title":"Keyple Distributed Local","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Network Java component is the part of the Keyple Distributed solution which contains the common network elements used by Keyple Distributed Local and Keyple Distributed Remote components.\nThis library should not be import explicitly because it\u0026rsquo;s imported by transitivity by the other components.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-distributed-network:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-distributed-network\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"ced4adf88c82c764a980874294d5324e","permalink":"https://keyple.org/components-java-1.0/distributed-systems/network/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/distributed-systems/network/","section":"components-java-1.0","summary":"Part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.","tags":null,"title":"Keyple Distributed Network","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin NFC Java component is a Keyple plugin for Android devices having NFC capabilities.\nIt is compatible with Android 4.4 minimum.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-android-plugin-nfc:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-nfc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"3e682ad79a821530f652e8cc894e45ed","permalink":"https://keyple.org/components-java-1.0/plugins/nfc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/plugins/nfc/","section":"components-java-1.0","summary":"Keyple Java plugin for Android devices having NFC capabilities.","tags":null,"title":"Keyple Plugin NFC","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin OMAPI Java component is a Keyple plugin for Android devices using OMAPI technology.\nIt is compatible with Android 4.4 minimum.\nOMAPI (Open Mobile Application Programming Interface) is the mechanism which enables an authorized mobile app to communicate with applets within a SE in a device. This allows the app to benefit from enhanced SE-based security services.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-android-plugin-omapi:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-omapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"d8f81ac75482a7d8aab25152c0e9e1d7","permalink":"https://keyple.org/components-java-1.0/plugins/omapi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/plugins/omapi/","section":"components-java-1.0","summary":"Keyple Java plugin for Android devices using OMAPI technology.","tags":null,"title":"Keyple Plugin OMAPI","type":"book"},{"authors":null,"categories":null,"content":"Coming from a rather closed technical environment, ticketing for transport is essentially based on proprietary solutions provided by manufacturers. However, in order for the concept of Mobility as a Service to become a reality, and at a reasonable cost, the ecosystem should, as far as possible, rely on open standards, APIs and SDKs as well as Open Source technologies. This openness has already been a reality for several years in the field of passenger information and has enabled the explosion of rich and high-quality applications, thanks in particular to Open Data. Today, Eclipse Keyple is paving the way for ticketing to follow the same path, by making available for free the first fully Open Source API.\nEclipse Keyple® accelerates the integration and development of ticketing applications by enabling multimodal transport services, public transport operators and event organizers to implement ticketing and access control systems based on a common, open and modular base.\nEclipse Keyple® works with Keyple\u0026rsquo;s extensions. The first available extension allows you to benefit from Calypso®'s main features of reliability, security and interoperability.\nEclipse Keyple® transforms complex contactless ticketing, transportation and event access systems into a simple integration to manage terminal readers and portals that use smart cards and mobile applications to enter and exit.\nAs an open source technology, Eclipse Keyple® offers uniformity of structure but does not lock you into a specific ticketing system. Plugins and extensions are being created, or may be created by developers, to allow ticket processing integrating technologies other than Calypso®, based on several programming languages.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"282cad7c0a4930ebfdb0d9b1b88c4a4b","permalink":"https://keyple.org/what-is-keyple/overview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/what-is-keyple/overview/","section":"what-is-keyple","summary":"Coming from a rather closed technical environment, ticketing for transport is essentially based on proprietary solutions provided by manufacturers. However, in order for the concept of Mobility as a Service to become a reality, and at a reasonable cost, the ecosystem should, as far as possible, rely on open standards, APIs and SDKs as well as Open Source technologies.","tags":null,"title":"Overview","type":"what-is-keyple"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC C++ component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.\nDocumentation  Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"2a0d68a64a482a0683b37a4d623739a5","permalink":"https://keyple.org/components-cpp-0.9/plugins/pcsc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/plugins/pcsc/","section":"components-cpp-0.9","summary":"Keyple C++ plugin for PC/SC smart card readers.","tags":null,"title":"Keyple Plugin PC/SC","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC Java component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-plugin-pcsc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"6c6f3f433f44618f32c8565e80cc3d5c","permalink":"https://keyple.org/components-java-1.0/plugins/pcsc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/plugins/pcsc/","section":"components-java-1.0","summary":"Keyple Java plugin for PC/SC smart card readers.","tags":null,"title":"Keyple Plugin PC/SC","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Remote Java component is the part of the Keyple Distributed solution which contains all the remote plugins.\nIt must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.\nIt is important to note that it uses and exposes the APIs exposed by Keyple Distributed Network component.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-distributed-remote:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-distributed-remote\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"44d8a47b71c2680987663fb00010e734","permalink":"https://keyple.org/components-java-1.0/distributed-systems/remote/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/distributed-systems/remote/","section":"components-java-1.0","summary":"Part of the Keyple Distributed solution which contains all the remote plugins.","tags":null,"title":"Keyple Distributed Remote","type":"book"},{"authors":null,"categories":null,"content":" Version 0.9 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub C++ component is a Keyple plugin used to stub smart card readers.\nIt is compatible with PC and MAC platforms.\nDocumentation  Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"e9f011f29e6324fd9e0e9f7c4be4b73c","permalink":"https://keyple.org/components-cpp-0.9/plugins/stub/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-cpp-0.9/plugins/stub/","section":"components-cpp-0.9","summary":"Keyple C++ plugin used to stub smart card readers.","tags":null,"title":"Keyple Plugin Stub","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub Java component is a Keyple plugin used to stub smart card readers.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-plugin-stub:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-plugin-stub\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"85f15d677065ad10b2e957cfb9a8cbd1","permalink":"https://keyple.org/components-java-1.0/plugins/stub/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java-1.0/plugins/stub/","section":"components-java-1.0","summary":"Keyple Java plugin used to stub smart card readers.","tags":null,"title":"Keyple Plugin Stub","type":"book"},{"authors":null,"categories":null,"content":" The diagram below illustrates the sequence of exchanges and the grouping of APDU commands during a secure Calypso transaction:\n  Calypso secure transaction  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"0746f13c4ba34c4d25ab11b2767c4086","permalink":"https://keyple.org/learn/keyple-in-depth/calypso-card-extension/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/keyple-in-depth/calypso-card-extension/","section":"learn","summary":"In-depth technical information about Keyple Calypso card extension add-on.","tags":null,"title":"Calypso card extension","type":"book"},{"authors":null,"categories":null,"content":" This online tool generates for you the dependencies section of Gradle or Maven configuration files. Choose your project profile and copy/paste the generated result into your project dependency manager.\nWhat do you want to develop?\n An application that uses existing Keyple components. A specific Keyple reader plugin add-on not already available. A specific Keyple card extension add-on not already available. An alternate Keyple distributed solution add-on.   Client application Please find below the configuration to use when developing an application that uses existing Keyple components:\n  Which card extension do you want to use?\n  Generic (with low-level API)   Calypso     Which reader plugin do you want to use?\n  Android NFC   Android OMAPI   PC/SC   Stub (simulated reader)     In case of a distributed system, on which side is your application located?\n  On the device having local access to the smart card reader   On the device not having local access to the smart card reader     Do you need additional services?\n  Service for dynamic card resource allocation (e.g. for HSM or pool of readers)     Gradle Groovy  Gradle Kotlin  Maven   Copy         Reader plugin add-on Please find below the configuration to use when developing a specific Keyple reader plugin add-on not already available: Gradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-plugin-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    Card extension add-on Please find below the configuration to use when developing a specific Keyple card extension add-on not already available:\n Do you need additional services?   Service for dynamic card resource allocation (e.g. HSM or pool of readers)     Gradle Groovy  Gradle Kotlin  Maven   Copy         Distributed solution add-on Please find below the configuration to use when developing an alternate Keyple distributed solution add-on:\n  For the \u0026ldquo;Local Service\u0026rdquo; component: Gradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-distributed-local-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-local-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-local-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     For the \u0026ldquo;Remote Plugin\u0026rdquo; component: Gradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-distributed-remote-java-api:2.0.0\u0026#39; implementation \u0026#39;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-common-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-remote-java-api:2.0.0\u0026#34;) implementation(\u0026#34;org.eclipse.keyple:keyple-util-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-remote-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     implementation 'org.eclipse.keyple:keyple-common-java-api:2.0.0' implementation 'org.eclipse.keyple:keyple-common-java-api:2.0.\u0026#43;' implementation 'org.eclipse.keyple:keyple-service-java-lib:2.0.1' implementation 'org.eclipse.keyple:keyple-service-resource-java-lib:2.0.1' implementation 'org.eclipse.keyple:keyple-util-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-util-java-lib:2.\u0026#43;' implementation 'org.eclipse.keyple:keyple-card-calypso-java-lib:2.0.1' implementation 'org.eclipse.keyple:keyple-card-generic-java-lib:2.0.1' implementation 'org.eclipse.keyple:keyple-distributed-local-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-distributed-network-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-distributed-remote-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-plugin-android-nfc-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-plugin-android-omapi-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.0.0' implementation 'org.eclipse.keyple:keyple-plugin-stub-java-lib:2.0.0' implementation 'org.calypsonet.terminal:calypsonet-terminal-reader-java-api:1.0.0' implementation 'org.calypsonet.terminal:calypsonet-terminal-reader-java-api:1.0.\u0026#43;' implementation 'org.calypsonet.terminal:calypsonet-terminal-card-java-api:1.0.0' implementation 'org.calypsonet.terminal:calypsonet-terminal-card-java-api:1.0.\u0026#43;' implementation 'org.calypsonet.terminal:calypsonet-terminal-calypso-java-api:1.0.\u0026#43;'  implementation(\"org.eclipse.keyple:keyple-common-java-api:2.0.0\") implementation(\"org.eclipse.keyple:keyple-common-java-api:2.0.\u0026#43;\") implementation(\"org.eclipse.keyple:keyple-service-java-lib:2.0.1\") implementation(\"org.eclipse.keyple:keyple-service-resource-java-lib:2.0.1\") implementation(\"org.eclipse.keyple:keyple-util-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-util-java-lib:2.\u0026#43;\") implementation(\"org.eclipse.keyple:keyple-card-calypso-java-lib:2.0.1\") implementation(\"org.eclipse.keyple:keyple-card-generic-java-lib:2.0.1\") implementation(\"org.eclipse.keyple:keyple-distributed-local-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-distributed-network-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-distributed-remote-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-plugin-android-nfc-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-plugin-android-omapi-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.0.0\") implementation(\"org.eclipse.keyple:keyple-plugin-stub-java-lib:2.0.0\") implementation(\"org.calypsonet.terminal:calypsonet-terminal-reader-java-api:1.0.0\") implementation(\"org.calypsonet.terminal:calypsonet-terminal-reader-java-api:1.0.\u0026#43;\") implementation(\"org.calypsonet.terminal:calypsonet-terminal-card-java-api:1.0.0\") implementation(\"org.calypsonet.terminal:calypsonet-terminal-card-java-api:1.0.\u0026#43;\") implementation(\"org.calypsonet.terminal:calypsonet-terminal-calypso-java-api:1.0.\u0026#43;\")  \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;[2.0.0,2.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-service-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-service-resource-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;[2.0.0,3.0.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-card-calypso-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-card-generic-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-distributed-local-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-distributed-network-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-distributed-remote-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-plugin-android-nfc-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-plugin-android-omapi-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-plugin-pcsc-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;keyple-plugin-stub-java-lib\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.calypsonet.terminal\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;calypsonet-terminal-reader-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.calypsonet.terminal\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;calypsonet-terminal-reader-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;[1.0.0,1.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.calypsonet.terminal\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;calypsonet-terminal-card-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.calypsonet.terminal\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;calypsonet-terminal-card-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;[1.0.0,1.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;groupId\u0026gt;org.calypsonet.terminal\u0026lt;/groupId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;artifactId\u0026gt;calypsonet-terminal-calypso-java-api\u0026lt;/artifactId\u0026gt; \u0026nbsp;\u0026nbsp;\u0026lt;version\u0026gt;[1.0.0,1.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  document.body.onload = function() { updateAppDependencies(1, null); updateCardDependencies(3, null); }; ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635430919,"objectID":"053867efdd6e3f279a2685cc1d699e68","permalink":"https://keyple.org/components-java/overview/configuration-wizard/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/overview/configuration-wizard/","section":"components-java","summary":"Online tool to generate the dependencies section of Gradle or Maven configuration files.","tags":null,"title":"Java - Configuration wizard","type":"book"},{"authors":null,"categories":null,"content":"Eclipse Keyple® is an Eclipse open source project currently leaded by Calypso Networks Association, which has been the leader in contactless electronic ticketing transportation standards since 2003.\n     Free, easy-to-use and flexible Built by developers, for developers Tailored to public entities requirements     Interoperable with any smart card reader solution (standard/proprietary, local/remote) Open source libraries in Java and C++ Audit and certification   Compatible with any terminal architecture (mobile, embedded, server) Developer-friendly, up-to-date documentation, code samples and how-to guides Permanent compliance to the latest Calypso® release   Options for creating add-on features that incorporate Calypso’s advanced security together with non-Calypso smart cards for ticketing and payment Accredited and hosted by the Eclipse foundation Exchange platform between providers and transport authorities    Help desk-Separate maintenance for software and equipment Online and offline trainings available that will help you get the most of Keyple    Active on GitHub and within the Eclipse community     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"b82f355f36579dc4f39c8ec384a1fc74","permalink":"https://keyple.org/what-is-keyple/why-trust/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/what-is-keyple/why-trust/","section":"what-is-keyple","summary":"Eclipse Keyple® is an Eclipse open source project currently leaded by Calypso Networks Association, which has been the leader in contactless electronic ticketing transportation standards since 2003.\n     Free, easy-to-use and flexible Built by developers, for developers Tailored to public entities requirements     Interoperable with any smart card reader solution (standard/proprietary, local/remote) Open source libraries in Java and C++ Audit and certification   Compatible with any terminal architecture (mobile, embedded, server) Developer-friendly, up-to-date documentation, code samples and how-to guides Permanent compliance to the latest Calypso® release   Options for creating add-on features that incorporate Calypso’s advanced security together with non-Calypso smart cards for ticketing and payment Accredited and hosted by the Eclipse foundation Exchange platform between providers and transport authorities    Help desk-Separate maintenance for software and equipment Online and offline trainings available that will help you get the most of Keyple    Active on GitHub and within the Eclipse community     ","tags":null,"title":"Why trust Eclipse Keyple®?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":" Build automation tool Keyple uses Gradle.\n Versioning rules Keyple components are versioned according to Semantic Versioning 2.0.0 which is based on the three numbers X.Y.Z\n For API components (i.e. artifacts suffixed with -api), the incrementation of Z indicates only a documentation update.    Continuous integration Keyple continuous integration works with the Jenkins server of the Eclipse Foundation.\nThe build process uses the home-made gradle plugin Keyple Gradle available directly from the Maven Central Repository and whose sources are available on GitHub.\nThe CI automates the following tasks (defined in the Jenkinsfile file):\n verify the validity of the version; verify the code formatting using Spotless; build the code; execute unit tests; sign and publish artifacts to Maven Central Repository; publish the javadoc to the corresponding GitHub Pages; publish the code quality report to SonarCloud.   Snapshot publication A snapshot artifact (suffixed with -SNAPSHOT) is automatically published after each commit on the main branch, except in the case of a release (see Release publication).\n The artifact version defined in the gradle.properties file must not have a -SNAPSHOT suffix because the suffix is automatically added by the Keyple Gradle plugin.    Release publication A release artifact is automatically published if and only if the following two conditions are met:\n The commit is done on the main branch or on a release-X.Y.Z branch. The commit message starts with Release X.Y.Z.   X.Y.Z must be the version defined in the gradle.properties file.    Integration tests Integration tests are defined in an independent GitHub repository: keyple-integration-java-test\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"9ec9badc2611e8c72b4bce5aa2987b02","permalink":"https://keyple.org/learn/keyple-in-depth/build-and-ci/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/learn/keyple-in-depth/build-and-ci/","section":"learn","summary":"Learn how the Keyple components are built, tested and published.","tags":null,"title":"Build process and continuous integration","type":"book"},{"authors":null,"categories":null,"content":" This online tool helps you to check the compatibility of Keyple components according to their API versions.\nSelect the targeted versions of the APIs to show the associated compliant libraries versions:\n  Calypso Networks Association APIs Core APIs Core libraries Distributed systems libraries Card extensions libraries Standard reader plugins libraries   calypsonet-terminal-reader-java-api calypsonet-terminal-card-java-api calypsonet-terminal-calypso-java-api keyple-common-java-api keyple-distributed-local-java-api keyple-distributed-remote-java-api keyple-plugin-java-api keyple-util-java-lib keyple-service-java-lib keyple-service-resource-java-lib keyple-distributed-local-java-lib keyple-distributed-network-java-lib keyple-distributed-remote-java-lib keyple-card-calypso-java-lib keyple-card-generic-java-lib keyple-plugin-android-nfc-java-lib keyple-plugin-android-omapi-java-lib keyple-plugin-pcsc-java-lib keyple-plugin-stub-java-lib     1.0.+1.0.+1.0.+2.0.+2.0.+2.0.+2.0.+2.0.02.0.0...2.0.12.0.0...2.0.12.0.02.0.02.0.02.0.0...2.0.12.0.0...2.0.12.0.02.0.02.0.02.0.0   document.body.onload = function() { initDatatableDependencyCheck(); };  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1638977335,"objectID":"5bbd15816dfc796282edc8b28f299b4b","permalink":"https://keyple.org/components-java/overview/dependency-check/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/overview/dependency-check/","section":"components-java","summary":"Online tool to check the compatibility of Keyple components according to their internal API versions.","tags":null,"title":"Java - Dependency check","type":"book"},{"authors":null,"categories":null,"content":"Whether you are a transport authority or operator, a mobility provider, a system integrator, an event manager, a mobility aggregator or a multi-mobility startup, Eclipse Keyple® allows you to:\n Reduce your costs and accelerate your developments. Facilitate the integration of new services or technologies. Use libraries to enable instant payments, remote top-ups, event and multimodal transport integrations, connection to park-and-ride services, and more. Easily create applications or services compatible with existing card-centric or server-centric systems. Benefit from a more diverse and easily collaborative network that encourages coopetition in a multimodal market: compete where you can, collaborate when necessary to create integrated mobility customer journeys. Harness the flexibility to introduce modern, mobile and new architecture systems while maintaining integrations to legacy infrastructure. Ensure the sustainability and future-proofing of your ticketing system, as Keyple is compatible with any smart card reader and SIO-enabled terminal. Unchain from vendor lock in, black box and single provider systems to an open solution with access to multiple suppliers. Enable partnerships with multimodal transport, building facilities including parking, tourism operators and events to offer seamless, single ticketing across the end customer’s journey.  With Keyple Calypso extension:\n Have easy access to a highly secure and interoperable standard, Calypso®. Quickly build new apps and integrations that conform to the Calypso® standard and other ticketing schemas. Easily migrate from an existing, closed ticketing schemes to Calypso®, a high-end open ticketing, certified solution. Easily integrate with public transport providers that are using the Calypso® standard, today used in major cities around the world in over 25 countries.  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"619e8d908db818972b80664557c05715","permalink":"https://keyple.org/what-is-keyple/who-is-it-for/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/what-is-keyple/who-is-it-for/","section":"what-is-keyple","summary":"Whether you are a transport authority or operator, a mobility provider, a system integrator, an event manager, a mobility aggregator or a multi-mobility startup, Eclipse Keyple® allows you to:\n Reduce your costs and accelerate your developments.","tags":null,"title":"Who is it for?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"Calypso® is a set of specifications describing a fast and secure off-line contactless transaction, between a portable object and a terminal. It has been created for public transport ticketing at the end of the 1990s by some European public transport operators or authority (RATP and SNCF in Paris and all France, STIB in Brussels, OTLIS in Lisbon, ACTV in Venice, Konstanz in Germany), in order to create an open, interoperable and secure standard independent from industrials to ensure a real competition.\nToday Calypso® represents 20% of the world market of contactless smart ticketing in more than 25 countries and over 170 cities globally. It brings to his user a guarantee of security and interoperability which relies on a total compliance with existing standards (ISO 14443, ISO 7816-4, Global Platform). The Calypso® standard is managed by the Calypso Networks Association (CNA), which is led by transports operators and public authorities in order to ensure openness and independence from industrials in confront of other proprietary schemes.\nDiscover more about Calypso® here : https://calypsonet.org/solutions-overview/\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"891b6c07aee52d1deb466963c0da5e9a","permalink":"https://keyple.org/what-is-keyple/what-is-calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/what-is-keyple/what-is-calypso/","section":"what-is-keyple","summary":"Calypso® is a set of specifications describing a fast and secure off-line contactless transaction, between a portable object and a terminal. It has been created for public transport ticketing at the end of the 1990s by some European public transport operators or authority (RATP and SNCF in Paris and all France, STIB in Brussels, OTLIS in Lisbon, ACTV in Venice, Konstanz in Germany), in order to create an open, interoperable and secure standard independent from industrials to ensure a real competition.","tags":null,"title":"What is Calypso®?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"The goal of Eclipse Keyple® is to allow developers to easily implement fast and secure off-line contactless transactions (using NFC cards, mobile phones, …) based on ticket processing integrating technologies other than Calypso® the Calypso standard.\nMore specifically, Keyple is a set of open source libraries that will initially be available in Java and C++, designed on the same mutual Object-Oriented Model compatible with any terminal architecture: mobile, embedded or server and Interoperable with any smart card reader solution: standard or proprietary, local or remote.\nTo fully understand how Keyple works, it is important to discern two main components of contactless ticketing technology:\n Smart Card Readers: Readers are situated at the entrance and exit of events, venues and transport sites. For example, a smart card reader could be a terminal, a portable scanning laser gun, or a swipe tablet area that is embedded into a door, vehicle or gate. Code is written for a terminal to set the parameters for allowing cards or apps to transmit ticketing information data. Sometimes in a distributed architecture system design, the code for the reader is not on the terminal, but in a cloud environment, so the reader sends the data to cloud-based architecture. Ticketing application: This is behind-the-scenes code that is able to take the data from the smart card reader and, in milliseconds real-time, analyze the balance of the ticket, confirm the permissions for entry, and update the data on the ticket (for example, to confirm that the ticket holder can enter the gate or vehicle, and then to deduct the cost of the journey and calculate the new balance).  According to this scheme, Keyple defines two layers:\n Smart Card readers are integrated through plugins implementing the SE Proxy API which manages the communications with a smart card through any type of contactless or contact reader (local, remote, standard, proprietary…) Ticketing applications relies on a high-level Calypso® processing API to manage Calypso® commands \u0026amp; security features. This API uses the SE Proxy API to communicate with the reader  Keyple comes with dedicated plugins that integrate directly with smart card readers that have been built on standard software interfaces including PC/SC, Android NFC reader, and Android OMAPI.\nIn cases where there is a distributed architecture design, Keyple includes a Remote API plugin so that a smart card terminal can be operated remotely, as if it were local to the terminal, and ensures that robust security and speed is not sacrificed in a cloud-based system.\nThe Calypso Processing API is also available as a Keyple extension. This component carries out the terminal processing element of ticketing technology. Access to Calypso’s security features are automatically managed by the Keyple extension.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"bf786b8ea9088ea228a979a08534bfca","permalink":"https://keyple.org/what-is-keyple/main-features/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/what-is-keyple/main-features/","section":"what-is-keyple","summary":"Keyple makes contactless ticketing accessible.","tags":null,"title":"Keyple's main features","type":"what-is-keyple"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview The Keyple solution provides currently 2 modules:\n the Keyple Core, a universal smart card reader interface to manage the setting of smart card reader, the detection and the communication with smart card, and the selection of card application. the Keyple Calypso, a first smart card solution extension built on the Keyple Core, dedicated to manage Calypso processing, Calypso card identification, card command generation, card data recovery, authentication with the secure session.    Keyple Architecture Global  The Keyple Core provides 3 interfaces:\n the Service API, to allow terminal application to handle reader \u0026amp; select card the Card API, for APDU command transmission, card data parsing the Plugin API, to integrate specific smart card reader solutions.  The Keyple Calypso extension provides the Calypso API: a high-level interface to manage Calypso card processing.\n Application integration The Card API is a low-level interface to manage the transmission of APDU commands with a smart card. A terminal application operating processing with a specific smart card solution could be implemented directly on top the Card API.\n  Keyple Architecture Application Integration  Another way offering a better abstraction on smart card technical settings could be to implement on the Card API a smart card solution library extension providing a high-level interface: a specific Solution API. This is how the Keyple Calypso extension has be defined, the Calypso API is a high-level functional interface, which hides the low-level APDU operations.\n Reader integration native integration The smart card readers could be directly integrated with the Keyple Core. By interfacing through the Plugin API, a specific plugin dedicated to a smart card reader solution, the Keyple Core could have the capability to fully manage the smart card readers corresponding to this native plugin.\n  Keyple Architecture Reader Integration Native  The Eclipse Keyple® project provides the plugin for the main standard smart card reader solutions.\n  Keyple Architecture Native Plugins   The PC/SC plugin is available for both the Java and the C++ implementation of Keyple, it allows to interface PC/SC reader on Windows, Linux and Mac OS. For Android devices the NFC plugin allows to operate the standard NFC interface to handle external contactless smart card. And the OMAPI plugin provides the integration of internal eSE (embedded Secure Element) or UICC (SIM card). Both plugins support Keyple Java. The Remote plugin (part of the Core distributed extension) allows to operate remote smart card readers.  hybrid integration It\u0026rsquo;s also possible to integrate Keyple in a terminal solution already embedding not Keyple based terminal applications operating smart card solutions. In those kinds of terminal, a Reader Manager has already the direct control on a smart card reader and manage the smart card detection: depending on the type of smart card identified on the reader, a specific terminal application is requested to operated the processing of the smart card.\n  Keyple Architecture Hybrid Plugins  In this case a reader manager plugin, also based on the Plugin API, could allow the Keyple Core to operate the processing of a specific smart card, when requested by the Reader Manager.\nFor example, an EMV certified reader manager could call a Keyple application in case of PPSE selection failure.\n Smart card processing stand-alone By default, a terminal application manages the processing of a specific smart card in stand-alone with its local readers.\n  Keyple Architecture Local Plugin  distributed The Distributed extension of the Keyple Core provides a solution allowing a master terminal application to manage the processing of a smart card localized in a remote driven terminal.   Keyple Architecture Remote Plugin \n Smart card transaction There are two ways for a terminal application to manage a transaction with a smart card.\n Either the smart card processing could be directly started by the terminal application. Otherwise, the smart card processing could be launched when a smart card is inserted in a reader of the terminal.  explicit selection For a classic transaction,\n the presence of a card is firtsly checked on a reader, then the car is selected and identified, finally, a transaction is processed with the card application.    [Keyple Transaction Explicit Selection  default selection  For automatons (e.g. a ticketing validator), the ticketing transaction is often driven by the insertion of a card. Keyple Core allows to define a default selection on Observable Reader, and in return to be notified of successful selections.    [Keyple Transaction Default Selection  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635429016,"objectID":"0f47ba084df17a3b780b297fa1349244","permalink":"https://keyple.org/docs-1.0/architecture/keyple-global/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/architecture/keyple-global/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview The Keyple solution provides currently 2 modules:","tags":null,"title":"Global Solution","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Features / packages and corresponding usages The Keyple Core is a tool to handle smart card reader and to operate generic processing with smart cards.\nThe Core is divided in 3 sub-modules:\n Service API : provides the interfaces to access to the smart card readers and to select a smart card. Card API : for the transmission of APDU commands with a smart card. Plugin API : includes the factorized processing for the implementation of plugin.     Module Package Feature     Service org.eclipse.keyple.core.service Management of the smart card readers Registration of plugins to the smart card Service Access to the readers through plugins   org.eclipse.keyple.core.service.event Notifications of reader plug/unplug, of smart card insertion/removed Define observers of plugins or readers Interface to be implemented by observers to be notified on plugin event or reader event For observable reader, setting of default selections, to automatically operate in case of smart card insertion   org.eclipse.keyple.core.service.util Communication protocols setting for contactless/contacts Reader   org.eclipse.keyple.card.selection Generic selection of a smart card preparation of smart card selection requests\n matching selection results as smart card images   Smart card org.eclipse.keyple.card.message Transmission of grouped APDU commands to a Reader   org.eclipse.keyple.core.card.command Generic API to develop a smart card specific library   Plugin org.eclipse.keyple.core.plugin Reader plugins implementation Utility classes providing generic processing for Readers     According to the developer’s objective different packages must be imported:\n for the implementation of a smart card terminal application: the packages service, event and selection. to develop a dedicated library supporting the command sets and transaction features of a specific smart card solution: the packages message, command, and selection. to implement a plugin: the packages plugin, service, event, and message.    Core packages   Service Interface - Reader Access for the development of ticketing terminal application\nTypes of plugin \u0026amp; reader On Keyple, the smart card readers are managed through plugins in order to integrate specific reader solutions. The SmartCard Service singleton provides the unique name list of registered plugins. There can be three kinds of plugin:\n Plugin is the generic interface to list the readers of a plugin, or to access to a specific reader with its name. The Observable Plugin interface extends Plugins which have the capability to be observed: in order to notify registered Plugin Observers about the plug or unplug of readers. Plugin Observers could be added or removed to the Observable Plugin. Useful for systems allowing the hot plug / unplug of Readers. A Pool Plugin is a plugin for which a Reader is available only after an explicit allocation. When not more necessary, a Reader must be released. Useful for server solutions managing farms of Readers or interfaced with HSM: unallocated Readers or HSM instances could be shared between several smartcard terminal solutions.  A smartcard Reader is identified through its unique name in a Plugin. There are two kinds of Reader:\n The Reader is the generic interface to handle a smartcard reader. The presence of card in a Reader could be checked. The Observable Reader interface extends Readers which have the capability to notify registered Reader Observers about the insertion or remove of a Card in the Reader. Reader Observers could be added or removed to the Observable Reader. Useful for systems automatically starting the processing of a Card at its insertion: like a ticketing validator.   [Reader Access v1.0.0   (The APDU transmission with a Card is managed at a lower layer, through a Card Solution API.)\nSpecific Plugin integration The Plugins are registered to the SmartCard Service through related specific Plugin Factory.   Specific Plugin v1.0.0 \nReader Notifications To be notified about Plugin Event or Reader Event, a terminal application must implement the dedicated Plugin Observer or Reader Observer interfaces.\n  Reader Notifications v1.0.0  Plugin Event Several Plugin Observers could be registered to an Observable Plugin. In case of reader connection / disconnection, the Observable Plugin notifies sequentially the registered Plugin Observers with the corresponding Plugin Event. The Observable Plugin is a blocking API, the thread managing the issuance of the Plugin Event waits the acknowledge of the Plugin Observer currently notified.\nReader Event Several Reader Observers could be registered to an Observable Reader. In case of Card insertion / removal or selection match, the Observable Reader notifies sequentially the registered Reader Observers with the corresponding Reader Event. The Observable Reader could be a blocking API, the thread managing the issuance of the Plugin Event could wait the acknowledge of the notified Reader Observers.\nAn Observable Reader has the capability to be set with a Default Selections Request: in this case when a Card is inserted in the Reader, the Reader will try to operate the configured default selections. If a selection successfully matches with the Card, instead to simply notify about the insertion of a Card, the Observable Reader will notify about a successful selection with a Card application.\n If the notification mode is defined as always, then in case of Card insertion, the Observable Reader will notify a matched card Reader Event in case of successful selection, or a simple card insertion Reader Event if not. If the notification mode is defined as matched only, then in case of Card insertion, simple card insertion Reader Events are not notified.  When the processing of an inserted or matched Card is finished, a Reader Observer must release the logical channel with the Card, in order to prepare the Observable Reader to detect the removal of the Card.\nObservable Reader states An Observable Reader is active only when at least one Reader Observer is registered, and if the start of the detection has been requested. When active, an Observable Reader could switch between three internal states: Wait for Card Insertion, Wait for Card Processing, \u0026amp; Wait for Card Removal.\nIn the nominal case, a Reader Observer indicates to the Observable Reader that the processing of the SE is finished by releasing the Card Channel. To manage a failure of the Reader Observer process, the Observable Reader interface provides also a method to finalize the Card processing.\n  Observable Reader States  The states could be switched:\n due to an explicit API request (blue arrows):  the release of the Card Channel, the call of an Observable Reader method:  the addition or the remove of an Observable Reader, a request to start or stop the detection, to finalize the Card processing.     Or because of an external event (red arrows), the insertion or the remove of a Card.  the insertion a Card causing the Observable Reader to notify a Card matched Reader Event (in case of successful default selection) or a Card inserted Reader Event (Notification Mode defined as always). the removal of a Card causing the Observable Reader to notify a Card removed Reader Event.    If a Card detection is started with the repeating polling mode, then later when the Card is removed, the Reader starts again the detection of a new Card.\nWhatever the Plugin of Observable Reader, when waiting for the Card removal, any Observable Reader shall have the capability to notify the remove of the Card. Some Plugin solutions could have the capability to notify a Card removal also during the processing of the Card.\n Service Interface - Card Selection for the development of ticketing terminal application\nSelection scenarios Depending on the Card transaction use case, or on the Reader capability, there are two ways to manage the Selection of a Card:\n Either on a simple Reader, a Selection could be operated directly by transmitting the Selection Request. In this case the same entity manages both the Card Selection and the Card processing. Otherwise, on an Observable Reader, a Default Selection could be defined. In this case the Selection is operated automatically at the insertion of the Card. In this case, the Card Selection is next managed by the Observable Reader, but the Card processing is managed by a Reader Observer.    Selection v1.0.0  Selection setting and processing A Card Selection request is defined with a Card Selector. A Card Selector could be defined with tree optional levels of selection filter.\n The selection could be limited to match a specific card communication protocol. The Card ATR could be filtered to match a regular expression. If an AID is defined, the local reader transmits a Select Application APDU command to the card. If a SE Selector is defined without any filter, the selection is always successful if a card is present in the reader.  Depending on the Keyple Card Solution extension library, a card request could be completed with specific card commands to operate at the selection (for example, a Select File for a specific DF LID, the read of a specific file).\nFor terminal managing several kinds of card applications, a Card Selection could be prepared with several card selection request to operate sequentially with the card.\nAccording to the defined multi selection processing mode, the card selection could stop at the first selection request matching card application, otherwise all the prepared card selection request could be operated.\n Before the new processing of card selection request, the logical channel previously opened is closed. The channel control defines if the logical channel should be kept open or close after the last processed card selection request.    Card Selection v1.0.0  The result of a card request selection is a card image of a matching card. For a card selection with multiple requests, several matching card could be provided.\n Card Interface for the development of smartcard solution library\nThe Keyple Calypso extension uses the card interface to exchange APDU commands with Calypso cards and SAM.\nAPDU Transmission   APDU Transmission v1.0.0   Plugin API for the implementation of smartcard reader plugins\nPlugin Factorized Processing The implementation of Plugins requires to extend the classes AbstractPlugin and AbstractLocalReader.\n If the reader solution allows the hot plug/unplug of readers then AbstractThreadedObservablePlugin should be extended. In case the local reader has the capability to detect the insertion or the removal or a card, then AbstractObservableLocalReader should be extended.  For reader solutions managing themselves the allocation of logical channel for communicatio with smart cards, the interface SmartSelectionReader should be implemented (e.g. it is the case for the OMAPI plugin).\nOnly the abstract methods highlighted in blue have to be implemented have to be implemented by the specific plugins.\nFor plugins with ObservableReader: depending on the capability of the reader solution different interfaces could be implemented:\n WaitForCardInsertionAutonomous WaitForCardRemovalAutonomous WaitForCardRemovalDuringProcessing or DontWaitForCardRemovalDuringProcessing WaitForCardInsertionBlocking or WaitForCardInsertionNonBlocking WaitForCardRemovalBlocking or WaitForCardRemovalNonBlocking AbstractObservableLocalAutonomousReader    Plugin Factorized Processing v1.0.0  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"690818085d0f4140e810a02d59aacb2a","permalink":"https://keyple.org/docs-1.0/architecture/keyple-core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/architecture/keyple-core/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Features / packages and corresponding usages The Keyple Core is a tool to handle smart card reader and to operate generic processing with smart cards.","tags":null,"title":"Keyple Core","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Features / packages and corresponding usages The Calypso transaction API provides a high-level of abstraction to define functional commands to manage a secure session with a Calypso Portable Object, to update or authenticate its data.\nThe transaction API is defined on a low-level Calypso commands API which contains the builders of PO and SAM APDU commands, and the corresponding parsers of APDU responses. This internal library is deprecated, and will be refactorized for the version 2.0.0 of Keyple Calypso.\n   Package APIlevel Feature     org.eclipse.keyple.calypso.transaction high Calypso Portable Object commands and secure transaction management CalypsoAPI, command’s settings are limited to functional parameters Calypso SAM (Secure Module) operations automatically processed (only functional parameters)   org.eclipse.keyple.calypso.command org.eclipse.keyple.calypso.command.po org.eclipse.keyple.calypso.command.po.builder org.eclipse.keyple.calypso.command.po.parser org.eclipse.keyple.calypso.command.po.parser.session org.eclipse.keyple.calypso.command.sam org.eclipse.keyple.calypso.command.sam.builder org.eclipse.keyple.calypso.command.sam.parser org.eclipse.keyple.calypso.command.sam.parser.session low Calypso PO \u0026amp; SAM APDU commands' sets APDU command builders APDU response parsers (technical parameter settings specific to the PO \u0026amp; SAM revisions)\n    Ticketing terminal applications must import only the high-level Calypso transaction package.\n  Calypso packages   Calypso Portable Object Selection Compared to the generic Card Selection API (cf. https://keyple.org/learn/architecture/keyple-core/#card-selection), a PO Selector could be defined to accept only non-invalidated Portable Object (in this cas an invalidated PO isn\u0026rsquo;t selected).\nIn addition, a PO Selection Request provides methods:\n to prepare Select File command (useful in particular to manage REV1 Calypso PO for which the select of the targeted DF is required). and to prepare simple read record command (useful to optimize the read of a file present on all targeted PO).  The matching SmartCard resulting from a PO Selection Request is a Calypso PO. In case file records have been read during the selection: the corresponding data could be recovered in the Calypso PO card image.\n  Calypso Selection v1.0.0   Calypso Portable Object Transaction A Card Resource is a set of a Reader and a selected Card application.\n A Calypso Portable Object is the image of a selected Calypso PO. A Calypso SAM is the image of a selected Calypso SAM.  To operate a Calypso transaction:\n At least a Calypso Resource (CardResource\u0026lt;CalypsoPo\u0026gt;) is required. A SAM Resource ((CardResource\u0026lt;CalypsoSam\u0026gt;) is required too if security features are involved (Calypso secure session, Stored value transaction, PIN encryption, etc…).  A Calypso PO image provides public getters in order to recover the information of the selected PO (startup data, file data, … etc).\nA transaction with a Calypso PO is fully managed through the PoTransaction object:\n First a set of PO commands could be defined through prepare commands. Next the prepared PO commands transmitted when operating a process command. The responses of the PO are then recovered through the Calypso PO image.    Calypso API Global Architecture  Calypso card image When read commands have been exchanged with a Calypso PO, the corresponding data could be recovered by parsing the file structure of the PO card image.\n  Calypso PO card image  Calypso transaction Only the process methods generate communication with the Calypso PO and SAM.\n processPoCommands is used to transmit a set of prepared PO commands (outside or inside a secure session). processOpening issues an Open Secure Session followed by the prepared PO commands. processClosing issues the last prepared PO commands and transmits a Close Secure Session.  The prepareReleaseChannel method allows to the logical channel with the Calypso PO at the end of the processing of the next process method.\n  Calypso transaction   Data model extension   Calypso Data Model   Secure session sequence   Calypso session  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"b38d04c5b1afe288c555a75367e680c7","permalink":"https://keyple.org/docs-1.0/architecture/keyple-calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/architecture/keyple-calypso/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Features / packages and corresponding usages The Calypso transaction API provides a high-level of abstraction to define functional commands to manage a secure session with a Calypso Portable Object, to update or authenticate its data.","tags":null,"title":"Keyple Calypso","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object (PO) involving two smart card readers.\n The demonstration application created for this quick start requires a Calypso PO (contactless smart card, mobile phone with contactless communication) and a Calypso Secure Access Module (SAM).   We will use three main components of Keyple:\n Keyple Core which is the base component to which all the others refer, Keyple PC/SC plugin to provide the ability to manage PC/SC readers, Keyple Calypso extension to handle the commands sent to the Calypso PO and the Calypso SAM.  In this guide Gradle is used as build automation tool, but it is easy to transpose these explanations to another tool such as Maven for example.\nThe example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you will need to download :\n Java 1.6 or newer Gradle (any version)  We recommend that you use a Java IDE like Eclipse or Intellij IDEA to create your new Gradle project.\n Create a Gradle-based empty project Create a new Java project and add the following statements to your build.gradle file to import the Keyple components into your project:\napply plugin: 'java' repositories { mavenCentral() } dependencies { //Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core implementation 'org.eclipse.keyple:keyple-java-core:1.0.0' //Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0' //Import PC/SC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0' //Import logger lib implementation 'org.slf4j:slf4j-api:1.7.25' implementation \u0026quot;org.slf4j:slf4j-simple:1.7.25\u0026quot; }  If necessary, also create the usual tree in which the Java code of this guide will be placed, namely the folders: \\src\\main\\java\n Let\u0026rsquo;s code Now let\u0026rsquo;s see step by step how to create in one single class the elements that allow a certified reading of data through a Calypso secure session.\nIn a real ticketing application, the organization of the code would probably be different, but the point here is to show how Keyple makes it possible to perform very simply operations that normally require a quantity of code and knowledge that far exceeds what is implemented here.\nYou can either progressively copy each of the small portions of code that follow or copy the whole class at the bottom of this page.\nCreate the class skeleton Copy the source code below in a new Java Class named DemoPoAuthentication.\nimport org.eclipse.keyple.calypso.command.sam.SamRevision; import org.eclipse.keyple.calypso.transaction.*; import org.eclipse.keyple.core.card.selection.*; import org.eclipse.keyple.core.service.*; import org.eclipse.keyple.core.util.ByteArrayUtil; import org.eclipse.keyple.plugin.pcsc.*; public class DemoPoAuthentication { public static void main(String[] args) { // ... } }  Configure the PC/SC plugin and the readers The first step to use Keyple is to initialize the plugin and smart card readers.\nIn this snippet the PC/SC plugin is registered to the SmartCardService.\nTwo readers needs to be connected to the local machine. Replace \u0026ldquo;PO_READER_NAME\u0026rdquo; and \u0026ldquo;SAM_READER_NAME\u0026rdquo; with the name of the USB readers.\nIf you don\u0026rsquo;t know the names of the readers, read how to find them in the FAQ.\n//... // Get the instance of the SmartCardService : main service of Keyple SDK SmartCardService smartCardService = SmartCardService.getInstance(); // Register the PcscPlugin within the SmartCardService to use PC/SC readers Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory()); // Get the PO reader PcscReader poReader = (PcscReader) plugin.getReader(\u0026quot;PO_READER_NAME\u0026quot;); // Configure the PO reader parameters poReader.setContactless(true); // Get the SAM reader PcscReader samReader = (PcscReader) plugin.getReader(\u0026quot;SAM_READER_NAME\u0026quot;); // ...  Select the Calypso SAM Before executing a transaction each smart card should be selected. The next step is the selection of the Calypso SAM resulting in a CalypsoSam object.\nIt is then combined with the SAM reader to form the SAM resource needed later within the transaction service.\n//... // Prepare a SamSelector that identifies the Calypso SAM SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build(); // Perform the SAM selection CardSelectionService samSelection = new CardSelectionService(); samSelection.prepareSelection(new SamSelection(samSelector)); if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader.getName()); } CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader); if (!cardSelectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard(); // Associate the calypsoSam and the samReader to create a samResource CardResource\u0026lt;CalypsoSam\u0026gt; samResource = new CardResource\u0026lt;CalypsoSam\u0026gt;(samReader, calypsoSam); //...  Select the Calypso PO 1st PO exchange:\nThe Calypso PO selection is made using the portable object application\u0026rsquo;s AID and results in a CalypsoPo object that will contain all the information extracted from the Calypso PO all along the transaction.\n// Prepare a Calypso PO selection final String AID = \u0026quot;315449432E49434131\u0026quot;; /* AID: Keyple test kit profile 1, Application 2 */ CardSelectionService cardSelectionService = new CardSelectionService(); // Setting up a selection based on the AID of a Calypso Revision 3.1 PO // // Select the first application matching the selection AID whatever the card communication protocol PoSelection poSelection = new PoSelection( PoSelector.builder() .aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier .invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not .build()); // Add the selection case to the current selection // (we could have added other cases) cardSelectionService.prepareSelection(poSelection); if (!poReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;The selection of the PO has failed.\u0026quot;); } // Perform the PO selection and get a CalypsoPo container in return CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard(); //...  Open the Calypso secure session 2nd PO exchange :\nThe secure session opening operated by the PoTransaction service is combined with the reading of the environment file (SFI=07h).\nThe mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.\n// Prepare the security settings used during the Calypso transaction PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build(); // Create a PoTransaction service to manage the Calypso transaction PoTransaction poTransaction = new PoTransaction( new CardResource\u0026lt;CalypsoPo(poReader, calypsoPo), poSecuritySettings); final byte RECORD_NUMBER_1 = 1; final byte SFI_Environment = (byte) 0x07; // Schedule the reading of the Environment file after the secure session is opened // (we could have added other commands) poTransaction.prepareReadRecordFile( SFI_Environment, // the sfi to select RECORD_NUMBER_1); // Perform the session opening with the debit key poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the Environment data from the card image CalypsoPo ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment); String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent()); System.out.println(\u0026quot;Environment file content: \u0026quot;+ environmentLog); //...  Close the Calypso secure session 3rd PO exchange:\nSimply close the Calypso secure session\nThe mutual authentication is finalized, it includes the authentication of the data in the read file.\nNote: any technical, crytographic or content-related incident in the Calypso PO would be signalled by an exception and would interrupt the thread of execution.\n// Schedule the closure of the channel with the PO after the closing of the secure session poTransaction.prepareReleasePoChannel(); // Perform the closing of the Calypso Secure Session poTransaction.processClosing(); System.out.println(\u0026quot;The data read in session have been certified by the successful closing.\u0026quot;); //...  Unregister the plugin Finally unregister the plugin before shutting down the application\n// Shutdown the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0);  Find the complete code source below.\n Run  Connect two USB PC/SC Readers. Insert the Calypso SAM in the SAM reader. Insert the Calypso PO in the PO reader. Run the application.   All project dependencies, including Keyple components, are downloaded during the first run, which can take some time.    FAQ How do I find out the names of the readers?\nTo find out the names of the readers connected to your computer, we will use Keyple with the following class which prints in the console the number and names of the readers present:\nimport org.eclipse.keyple.core.service.Plugin; import org.eclipse.keyple.core.service.SmartCardService; import org.eclipse.keyple.plugin.pcsc.PcscPluginFactory; import java.util.Set; public class ReaderDiscovery { public static void main(String[] args) { SmartCardService smartCardService = SmartCardService.getInstance(); Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory()); Set\u0026lt;String\u0026gt; names = plugin.getReaderNames(); System.out.println(names.size() + \u0026quot; readers found.\u0026quot;); for (String name : names) { System.out.println('\u0026quot;' + name + '\u0026quot;'); } } }  The console output should look something like:\n2 readers found. \u0026quot;ASK LoGO 0\u0026quot; \u0026quot;Identive CLOUD 2700 R Smart Card Reader 0\u0026quot;  Identify which reader will be the PO (contactless) reader and the SAM (contact) reader and replace PO_READER_NAME and SAM_READER_NAME with their values.\nHow to activate the Keyple\u0026rsquo;s logs?\nAs soon as the slf4j library is imported into the project, Keyple modules are able to produce logs.\nHowever, to take full advantage of the possibilities of this library, it is necessary to create a simplelogger.properties file in the /src/main/resources folder of the project.\nThe self-documented content of this file may be:\n# SLF4J's SimpleLogger configuration file # Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err. # Default logging detail level for all instances of SimpleLogger. # Must be one of (\u0026quot;trace\u0026quot;, \u0026quot;debug\u0026quot;, \u0026quot;info\u0026quot;, \u0026quot;warn\u0026quot;, or \u0026quot;error\u0026quot;). # If not specified, defaults to \u0026quot;info\u0026quot;. org.slf4j.simpleLogger.defaultLogLevel=debug # Logging detail level for a SimpleLogger instance named \u0026quot;xxxxx\u0026quot;. # Must be one of (\u0026quot;trace\u0026quot;, \u0026quot;debug\u0026quot;, \u0026quot;info\u0026quot;, \u0026quot;warn\u0026quot;, or \u0026quot;error\u0026quot;). # If not specified, the default logging detail level is used. #org.slf4j.simpleLogger.log.xxxxx= # Set to true if you want the current date and time to be included in output messages. # Default is false, and will output the number of milliseconds elapsed since startup. org.slf4j.simpleLogger.showDateTime=true # The date and time format to be used in the output messages. # The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat. # If the format is not specified or is invalid, the default format is used. # The default format is yyyy-MM-dd HH:mm:ss:SSS Z. org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS] # Set to true if you want to output the current thread name. # Defaults to true. org.slf4j.simpleLogger.showThreadName=true # Set to true if you want the Logger instance name to be included in output messages. # Defaults to true. org.slf4j.simpleLogger.showLogName=false # Set to true if you want the last component of the name to be included in output messages. # Defaults to false. org.slf4j.simpleLogger.showShortLogName=true org.slf4j.simpleLogger.levelInBrackets=true  Why do I see a warning in the console about illegal reflexive access when running the application?\nA known problem on Windows 8/10 platforms causes the smartcard service to stop when the last reader is removed. This problem prevents a \u0026ldquo;classic\u0026rdquo; monitoring of connections and disconnections of readers with the smartcard.io library (Java PC/SC). So for the moment we are using a workaround based on reflexivity to overcome this problem and allow a correct monitoring of the readers in the PC/SC plugin. This has the disadvantage of generating a warning message with recent versions of the JVM. However, we have not found any problems with this implementation of the PC/SC plugin so far.\nFull code Here is the complete code of this quick start in one single block.\nimport org.eclipse.keyple.calypso.command.sam.SamRevision; import org.eclipse.keyple.calypso.transaction.*; import org.eclipse.keyple.core.card.selection.*; import org.eclipse.keyple.core.service.*; import org.eclipse.keyple.core.util.ByteArrayUtil; import org.eclipse.keyple.plugin.pcsc.*; public class DemoPoAuthentication { public static void main(String[] args) { // Get the instance of the SmartCardService : main service of Keyple SDK SmartCardService smartCardService = SmartCardService.getInstance(); // Register a PcscPlugin within the SmartCardService to use PC/SC USB Readers Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, null)); // Get the PO reader PcscReader poReader = (PcscReader) plugin.getReader(\u0026quot;ASK LoGO 0\u0026quot;); // Configure the PO reader parameters poReader.setContactless(true); // Get a SAM reader PcscReader samReader = (PcscReader) plugin.getReader(\u0026quot;Identive CLOUD 2700 R Smart Card Reader 0\u0026quot;); // Prepare a SamSelector that identifies the Calypso SAM SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build(); // Perform the SAM selection CardSelectionsService samSelection = new CardSelectionsService(); samSelection.prepareSelection(new SamSelection(samSelector)); if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader.getName()); } CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader); if (!cardSelectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard(); // Associate the calypsoSam and the samReader to create a samResource CardResource\u0026lt;CalypsoSam\u0026gt; samResource = new CardResource\u0026lt;CalypsoSam\u0026gt;(samReader, calypsoSam); // Prepare a Calypso PO selection final String AID = \u0026quot;315449432E49434131\u0026quot;; /* AID: Keyple test kit profile 1, Application 2 */ final byte RECORD_NUMBER_1 = 1; final byte SFI_Environment = (byte) 0x07; CardSelectionsService cardSelectionService = new CardSelectionsService(); // Setting up a selection based on the AID of a Calypso Revision 3.1 PO // // Select the first application matching the selection AID whatever the card communication protocol PoSelection poSelection = new PoSelection( PoSelector.builder() .aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier .invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not .build()); // Add the selection case to the current selection // (we could have added other cases) cardSelectionService.prepareSelection(poSelection); if (!poReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;The selection of the PO has failed.\u0026quot;); } // Perform the PO selection and get a CalypsoPo container in return CalypsoPo calypsoPo = (CalypsoPo) cardSelectionService.processExplicitSelections(poReader).getActiveSmartCard(); // Prepare the security settings used during the Calypso transaction PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build(); // Create a PoTransaction service to manage the Calypso transaction PoTransaction poTransaction = new PoTransaction( new CardResource\u0026lt;CalypsoPo\u0026gt;(poReader, calypsoPo), poSecuritySettings); // Schedule the reading of the Environment file after the secure session is opened // (we could have added other commands) poTransaction.prepareReadRecordFile( SFI_Environment, // the sfi to select RECORD_NUMBER_1); // Perform the session opening with the debit key poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the Environment data from the card image CalypsoPo ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment); String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent()); System.out.println(\u0026quot;Environment file content: \u0026quot;+ environmentLog); // Schedule the closure of the channel with the PO after the closing of the secure session poTransaction.prepareReleasePoChannel(); // Perform the closing of the Calypso Secure Session poTransaction.processClosing(); System.out.println(\u0026quot;The data read in session have been certified by the successful closing.\u0026quot;); // Shutdown the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0); } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"dd8a193937be84f8cf1a4db728b4abb5","permalink":"https://keyple.org/docs-1.0/build-your-first-app/java-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/build-your-first-app/java-app/","section":"docs-1.0","summary":"This quick start describes how to create a ready-to-execute Java command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first Java application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Introduction Overview Since Keyple is supported by the Android operating system, developers can take advantage of this quick and easy way to implement solution to provide SmartCard communication functionalities in their own mobile application.\nFor example, Keyple could be used to facilitate the development of a ticketing application based on the use of conteners on a SIM card and relying on Android SE OMAPI. Keyple could also be used to develop an application reading SmartCard content through NFC using Android NFC.\n  As Keyple request low-level reader access, the key features of Keyple SDK relies on components called Plugins. These are the plugins that allow access to the hardware functionality of the terminal by using the native Android SDK or the terminal manufacturer\u0026rsquo;s own custom SDKs.\nThis guide will describe how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso SmartCard. As we want to focus on Keyple integration, the Android application architecture will remain the simplest as possible.\nWhat to we need for this guide?  Retail Device with NFC powered by android.nfc library (integrated into standard Android SDK). Android OS 19+ A NFC SmartCard with Calypso PO   Integration Application setup Like for any other Android NFC Application, we need to declare items in the application manifest.\n\u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\u0026gt; ... \u0026lt;uses-permission android:name=\u0026quot;android.permission.NFC\u0026quot; /\u0026gt; \u0026lt;uses-feature android:name=\u0026quot;android.hardware.nfc\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; ... \u0026lt;/manifest\u0026gt;  Also make sure your minSdkVersion is at least 19.\nSDK Integration Keyple Core This high-level API is convenient for developers implementing smart card processing application for terminal interfaced with smart card readers. Access to the readers is provided by the plugins.\nTo use Keyple core API (and in fact, anything keyple\u0026rsquo;s related) import the jar within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-java-core:$keyple_version\u0026quot;  Please refer to Architecture/Keyle Core\nKeyple Plugins There are many Keyple plugins available, the one to use depends on the device and ticketing tools you are aiming to use.\nTo use the NFC plugin simply import it within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-android-plugin-nfc:$keyple_version\u0026quot;  Keyple Calypso The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Objects.\nPlease refer to Architecture/Keyle Calypso\nTo use Keyple Calypso User API simply import the jar within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-java-calypso:$keyple_version\u0026quot;   Let\u0026rsquo;s code Initializing the SDK Register a plugin In order to setup Keyple, we need to register at least one plugin. Here we register our NFC plugin. To do so, we use the singleton SmartCardService and the plugin Factory. (See plugin development guide to know more about plugins)\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) /* register Android NFC Plugin to the SmartCardService */ try { val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -\u0026gt;} SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler)) }catch (e: KeypleException){ /* do something with it */ } }  Note: Plugins Factory\u0026rsquo;s initialisation could request more steps to execute before passing it to registerPlugin(). It depends on plugins, please check the documentation or usage example of desired plugin.\nUnregister a plugin Clean resources.\noverride fun onDestroy() { ... /* Unregister Android NFC Plugin to the SmartCardService */ SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME) reader = null super.onDestroy() }  Retrieve a specific reader With the plugin registered we can retrieve all instances of the component mapping the SmartCard readers. Here we want to retrieve the NFC reader.\n//We keep a reference to the reader for later use private lateinit var reader: AndroidNfcReader ... //PLUGIN_NAME and READER_NAME are constants provided by the used Keyple plugin reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader  Add observer to handle NFC events When native NFC is activated on an Android device, the OS dispatches insertion events occurring in the NFC detection field. In our application, we need detect it in order to proceed to exchanges with the SmartCard.\n//To keep it simple we choose to have our MainActivity implementing ObservableReader.ReaderObserver //interface. class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { ... reader.addObserver(this) ... //Belongs to ObservableReader.ReaderObserver //NFC Reader events will be received here. //this method is not triggered in UI thread override fun update(event: ReaderEvent) { if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){ //We'll select PO when SmartCard is presented in field //Method handlePo is described below handlePo() } } }  Activate a protocol Before starting to read a NFC tag, you must activate the protocol in which you wish to detect it. If you do not activate any protocol, no card will be detected by the Keyple library.\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ... // with this protocol settings we activate the nfc for ISO1443_4 protocol reader.activateProtocol( ContactlessCardCommonProtocols.ISO_14443_4.name, AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name) ) ... } }  Deactivate a protocol When your are done with your NFC operations, you can deactivate the NFC protocol :\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onDestroy() { ... //Deactivate nfc for ISO1443_4 protocol reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) ... super.onDestroy() } }  Now we have an access to our NFC Reader, we can activate Card Detection.\nActivate Card detection We will start detection as soon as our application comes in foreground and stop when application go background.\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onResume() { super.onResume() reader?.let { //We choose to continue waiting for a new card persentation it.startCardDetection(ObservableReader.PollingMode.REPEATING) } } }  Deactivate Card detection class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onPause() { reader?.let { it.stopCardDetection() } super.onPause() } }  Now we can detect when a SmartCard is presented in the field, we can proceed to card application selection and data reading.\nHandling a Calypso PO Calypso Selection API With Keyple, PO selection and FCI retrieving can be done using only Keyple Core, but Keyple Calypso API provides specific tools to handle Calypso POs and make the process a bit more simple.\nfun handlePo(){ reader?.let { //check if card is in the NFC field if(it.isCardPresent){ //Instanciate class handling card selection service val cardSelectionsService = CardSelectionsService() //We only want to select the PO so we choose to close communication channel once //selection is done cardSelectionsService.prepareReleaseChannel() //We build a selection request managing specific characteristics of Calypso POs val poSelection = PoSelection( PoSelector .builder() //Smarcard standard protocol .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) .aidSelector( CardSelector.AidSelector.builder() .aidToSelect(YOUR_AID) //Set the AID of your Calypso PO //indicates how to carry out the file occurrence in accordance with //ISO7816-4 .fileOccurrence(CardSelector.AidSelector.FileOccurrence.FIRST) //indicates which template is expected in accordance with ISO7816-4 .fileControlInformation( CardSelector.AidSelector.FileControlInformation.FCI) .build() ).build()) cardSelectionsService.prepareSelection(poSelection) //Proceed to selection using the reader val selectionResult = cardSelectionsService.processExplicitSelections(it) runOnUiThread { //We check the selection result and read the FCI if(selectionResult.hasActiveSelection()){ val matchedSmartCard = selectionResult.activeSmartCard val fci = matchedSmartCard.fciBytes Toast.makeText(this, String.format(\u0026quot;Selected, Fci %s\u0026quot;, ByteArrayUtil.toHex(fci)), Toast.LENGTH_LONG).show() }else { Toast.makeText(this, String.format(\u0026quot;Not selected\u0026quot;), Toast.LENGTH_SHORT).show() } } } } }  Now we\u0026rsquo;ve seen we can select our PO we can retrieve more data from it.\nReading Environment and usage In the below example we\u0026rsquo;ll read Environment and Usage data of an Hoplink container.\n... //Data related to Hoplink val poAid= \u0026quot;A000000291A000000191\u0026quot; val sfiHoplinkEFEnvironment = 0x14.toByte() val sfiHoplinkEFUsage = 0x1A.toByte() ... private fun handlePo(){ ... //Prepare the reading order. We'll read the first record of the EF //specified by its SFI. This reading will be done within explicit selection. poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1) poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1) ... //Hoplink is a Calypso PO, we can cast the SmartCard //with CalypsoPo class, representing the PO content. val calypsoPO = selectionResult.activeSmartCard as CalypsoPo val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment) val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage) Toast.makeText(this, String.format(\u0026quot;Environment %s\u0026quot;, ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show() Toast.makeText(this, String.format(\u0026quot;Usage %s\u0026quot;, ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show() }  Full code \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; package=\u0026quot;org.eclipse.keyple.android.quickstart\u0026quot;\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.NFC\u0026quot; /\u0026gt; \u0026lt;uses-feature android:name=\u0026quot;android.hardware.nfc\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;application android:allowBackup=\u0026quot;true\u0026quot; android:screenOrientation=\u0026quot;portrait\u0026quot; android:icon=\u0026quot;@mipmap/ic_launcher\u0026quot; android:label=\u0026quot;@string/app_name\u0026quot; android:roundIcon=\u0026quot;@mipmap/ic_launcher_round\u0026quot; android:supportsRtl=\u0026quot;true\u0026quot; android:theme=\u0026quot;@style/AppTheme\u0026quot;\u0026gt; \u0026lt;activity android:name=\u0026quot;.MainActivity\u0026quot;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt;  class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { private var reader: AndroidNfcReader? = null val poAid= \u0026quot;A000000291A000000191\u0026quot; val sfiHoplinkEFEnvironment = 0x14.toByte() val sfiHoplinkEFUsage = 0x1A.toByte() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) try { val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -\u0026gt;} val plugin = SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler)) val reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader reader.addObserver(this) reader.activateProtocol( ContactlessCardCommonProtocols.ISO_14443_4.name, AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name) ) this.reader = reader }catch (e: KeypleException){ Timber.e(e) Toast.makeText(this, String.format(\u0026quot;Error: %s\u0026quot;, e.message), Toast.LENGTH_LONG).show() } } override fun onResume() { super.onResume() reader?.let { it.startCardDetection(ObservableReader.PollingMode.SINGLESHOT) Toast.makeText(this, String.format(\u0026quot;Hunt enabled\u0026quot;), Toast.LENGTH_SHORT).show() } } override fun onPause() { reader?.let { it.stopCardDetection() } super.onPause() } override fun onDestroy() { /* Deactivate nfc for ISO1443_4 protocol */ reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) /* Unregister Android NFC Plugin to the SmartCardService */ SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME) reader = null super.onDestroy() } override fun update(event: ReaderEvent) { Timber.d(\u0026quot;Event: %s\u0026quot;, event.eventType.name) runOnUiThread { Toast.makeText(this, String.format(\u0026quot;Event: %s\u0026quot;, event.eventType.name), Toast.LENGTH_SHORT).show() } if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){ handlePo() } } //With Calypso API private fun handlePo(){ reader?.let { if(it.isCardPresent){ val cardSelectionsService = CardSelectionsService() cardSelectionsService.prepareReleaseChannel() val poSelection = PoSelection( PoSelector .builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) .aidSelector( CardSelector.AidSelector.builder() .aidToSelect(poAid) .fileOccurrence( CardSelector.AidSelector.FileOccurrence.FIRST) .fileControlInformation( CardSelector.AidSelector.FileControlInformation.FCI) .build() ).build()) cardSelectionsService.prepareSelection(poSelection) //Prepare the reading order. We'll read the first record of the EF //specified by his SFI. This reading will be done with selection. poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1) poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1) //Selection and file reading will be done here val selectionResult = cardSelectionsService.processExplicitSelections(it) runOnUiThread { if(selectionResult.hasActiveSelection()){ val matchedSmartCard = selectionResult.activeSmartCard val fci = matchedSmartCard.fciBytes Toast.makeText(this, String.format(\u0026quot;Selected, Fci %s\u0026quot;, ByteArrayUtil.toHex(fci)), Toast.LENGTH_SHORT).show() //Hoplink is a Calypso PO, we can cast the SmartCard //with CalypsoPo class, representing the PO content. val calypsoPO = selectionResult.activeSmartCard as CalypsoPo val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment) val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage) Toast.makeText(this, String.format(\u0026quot;Environment %s\u0026quot;, ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show() Toast.makeText(this, String.format(\u0026quot;Usage %s\u0026quot;, ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show() }else { Toast.makeText(this, String.format(\u0026quot;Not selected\u0026quot;), Toast.LENGTH_SHORT).show() } } } } } }   FAQ How to fix \u0026ldquo;More than one file was found with OS independent path \u0026lsquo;META-INF/NOTICE.md\u0026rsquo;.\u0026quot;\nAdd lines below to your :app build.gradle file\nandroid{ packagingOptions { exclude 'META-INF/NOTICE.md' } }  Where can I see more examples\nAndroid native plugins are provided with example applications. Check it to see more use cases: Examples\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635429016,"objectID":"5aefa6b9376d0f22c30a68a9e0f9236e","permalink":"https://keyple.org/docs-1.0/build-your-first-app/android-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/build-your-first-app/android-app/","section":"docs-1.0","summary":"This guide describes how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso Portable Object.","tags":null,"title":"Build your first Android application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   This quick start describes how to create a ready-to-execute C++ command-line application that runs a simple transaction based on a Calypso portable object (PO) involving two smart card readers.\n The demonstration application created for this quick start requires a Calypso PO (contactless smart card, mobile phone with contactless communication) and a Calypso Secure Access Module (SAM).   We will use three main components of Keyple:\n Keyple Core which is the base component to which all the others refer, Keyple PC/SC plugin to provide the ability to manage PC/SC readers, Keyple Calypso extension to handle the commands sent to the Calypso PO and the Calypso SAM.  In this guide CMake is used as build automation tool.\nThe example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you will need to download :\n CMake 2.8 or newer (download) GCC / CLang / MSVC compiler   Let\u0026rsquo;s code Now let\u0026rsquo;s see step by step how to create in one single class the elements that allow a certified reading of data through a Calypso secure session.\nIn a real ticketing application, the organization of the code would probably be different, but the point here is to show how Keyple makes it possible to perform very simply operations that normally require a quantity of code and knowledge that far exceeds what is implemented here.\nYou can either progressively copy each of the small portions of code that follow or copy the whole class at the bottom of this page.\nCreate the class skeleton Copy the source code below in a new C++ Class named DemoPoAuthentication.\n/* Common */ #include \u0026quot;IllegalStateException.h\u0026quot; #include \u0026quot;LoggerFactory.h\u0026quot; /* Core */ #include \u0026quot;ByteArrayUtil.h\u0026quot; #include \u0026quot;SeCommonProtocols.h\u0026quot; #include \u0026quot;SeSelector.h\u0026quot; #include \u0026quot;SeSelection.h\u0026quot; #include \u0026quot;SeProxyService.h\u0026quot; /* PCSC */ #include \u0026quot;PcscPluginFactory.h\u0026quot; #include \u0026quot;PcscProtocolSetting.h\u0026quot; #include \u0026quot;PcscReader.h\u0026quot; /* Calypso */ #include \u0026quot;CalypsoPo.h\u0026quot; #include \u0026quot;CalypsoSam.h\u0026quot; #include \u0026quot;ElementaryFile.h\u0026quot; #include \u0026quot;PoSecuritySettings.h\u0026quot; #include \u0026quot;PoSelectionRequest.h\u0026quot; #include \u0026quot;PoSelector.h\u0026quot; #include \u0026quot;PoTransaction.h\u0026quot; #include \u0026quot;SamRevision.h\u0026quot; #include \u0026quot;SamSelector.h\u0026quot; #include \u0026quot;SamSelectionRequest.h\u0026quot; using namespace keyple::calypso::command::po; using namespace keyple::calypso::command::po::builder; using namespace keyple::calypso::command::po::parser; using namespace keyple::calypso::command::sam; using namespace keyple::calypso::transaction; using namespace keyple::common; using namespace keyple::common::exception; using namespace keyple::core::command::exception; using namespace keyple::core::selection; using namespace keyple::core::seproxy; using namespace keyple::core::seproxy::event; using namespace keyple::core::seproxy::exception; using namespace keyple::core::seproxy::message; using namespace keyple::core::seproxy::protocol; using namespace keyple::core::util; using namespace keyple::plugin::pcsc; int main(int argv, char **args) { // ... return 0; }  Configure the PC/SC plugin and the readers The first step to use Keyple is to initialize the plugin and smart card readers.\nIn this snippet the PC/SC plugin is registered to the SmartCardService.\nTwo readers needs to be connected to the local machine. Replace \u0026ldquo;PO_READER_NAME\u0026rdquo; and \u0026ldquo;SAM_READER_NAME\u0026rdquo; with the name of the USB readers.\nIf you don\u0026rsquo;t know the names of the readers, read how to find them in the FAQ.\n/* ... */ /* PO Reader name */ const std::string PO_READER_NAME = \u0026quot;XXX\u0026quot;; /* SAM Reader name */ const std::string SAM_READER_NAME = \u0026quot;XXX\u0026quot;; /* Get the instance of the SeProxyService (Singleton pattern) */ SeProxyService\u0026amp; seProxyService = SeProxyService::getInstance(); /* Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin */ auto pluginFactory = std::make_shared\u0026lt;PcscPluginFactory\u0026gt;(); std::shared_ptr\u0026lt;ReaderPlugin\u0026gt; readerPlugin = seProxyService.registerPlugin(pluginFactory); /* Get the PO reader */ std::shared_ptr\u0026lt;SeReader\u0026gt; poReader = readerPlugin-\u0026gt;getReader(PO_READER_NAME); /* Configure the PO reader parameters */ poReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1); /* Get a SAM reader */ std::shared_ptr\u0026lt;SeReader\u0026gt; samReader = readerPlugin-\u0026gt;getReader(SAM_READER_NAME); /* Configure the SAM reader parameters */ samReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0); /* * PC/SC card access mode: * * The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited * time between two consecutive exchanges granted by Windows. * * This point will be addressed in a coming release of the Keyple PcSc reader plugin. * * The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the * selection step that may result in session failures. * * See KEYPLE-CORE.PC.md file to learn more about this point. * */ samReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED); poReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED); /* Set the PO reader protocol flag */ poReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_ISO14443_4, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]); poReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_B_PRIME, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]); samReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_ISO7816_3, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]); /* ... */  Select the Calypso SAM Before executing a transaction each smart card should be selected. The next step is the selection of the Calypso SAM resulting in a CalypsoSam object.\nIt is then combined with the SAM reader to form the SAM resource needed later within the transaction service.\n/* ... */ /* Prepare the selector to ensure the correct SAM is used */ auto selector = SamSelector::builder()-\u0026gt;samRevision(SamRevision::AUTO).build(); auto samSelector = std::dynamic_pointer_cast\u0026lt;SamSelector\u0026gt;(selector); /* Make the SAM selection */ SeSelection samSelection; auto samSelectionRequest = std::make_shared\u0026lt;SamSelectionRequest\u0026gt;(samSelector); auto abstractSamSelectionRequest = std::reinterpret_pointer_cast\u0026lt;AbstractSeSelectionRequest\u0026lt;AbstractApduCommandBuilder\u0026gt;\u0026gt;(samSelectionRequest); samSelection.prepareSelection(abstractSamSelectionRequest); std::shared_ptr\u0026lt;CalypsoSam\u0026gt; calypsoSam; if (samReader-\u0026gt;isSePresent()) { std::shared_ptr\u0026lt;SelectionsResult\u0026gt; selectionsResult = samSelection.processExplicitSelection(samReader); if (selectionsResult-\u0026gt;hasActiveSelection()) { calypsoSam = std::dynamic_pointer_cast\u0026lt;CalypsoSam\u0026gt;(selectionsResult-\u0026gt;getActiveMatchingSe()); } else { throw IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } } else { throw IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader-\u0026gt;getName()); } /* Associate the calypsoSam and the samReader to create the samResource */ auto samResource = std::make_shared\u0026lt;SeResource\u0026lt;CalypsoSam\u0026gt;\u0026gt;(samReader, calypsoSam); /* ... */  Select the Calypso PO 1st PO exchange:\nThe Calypso PO selection is made using the portable object application\u0026rsquo;s AID and results in a CalypsoPo object that will contain all the information extracted from the Calypso PO all along the transaction.\n/* Prepare a Calypso PO selection */ SeSelection seSelection; /* Keyple test kit profile 1, Application 2 */ const std::string AID = \u0026quot;315449432E49434131\u0026quot;; /* * Setting of an AID based selection of a Calypso Revision 3.1 PO * * Select the first application matching the selection AID whatever the card communication * protocol * Keep the logical channel open after the selection * * Calypso selection: configures a PoSelectionRequest with all the desired attributes to * make the selection and read additional information afterwards */ auto aidSelector = SeSelector::AidSelector::builder()-\u0026gt;aidToSelect(AID).build(); auto seSelector = PoSelector::builder()-\u0026gt;aidSelector(aidSelector) /* The application identifier to indicate if an invalidated PO should be accepted or not */ .invalidatedPo(PoSelector::InvalidatedPo::REJECT) .build(); auto poSelector = std::dynamic_pointer_cast\u0026lt;PoSelector\u0026gt;(seSelector); auto poSelectionRequest = std::make_shared\u0026lt;PoSelectionRequest\u0026gt;(poSelector); /* Add the selection case to the current selection (we could have added other cases) */ auto abstractPoSelectionRequest = std::reinterpret_pointer_cast\u0026lt;AbstractSeSelectionRequest\u0026lt;AbstractApduCommandBuilder\u0026gt;\u0026gt;(poSelectionRequest); seSelection.prepareSelection(abstractPoSelectionRequest); if (poReader-\u0026gt;isSePresent()) { try { // Actual PO communication: operate through a single request the Calypso PO selection std::shared_ptr\u0026lt;CalypsoPo\u0026gt; calypsoPo = std::dynamic_pointer_cast\u0026lt;CalypsoPo\u0026gt;( seSelection.processExplicitSelection(poReader)-\u0026gt;getActiveMatchingSe()); /* ... */ } catch (const Exception\u0026amp; e) { } /* ... */  Open the Calypso secure session 2nd PO exchange :\nThe secure session opening operated by the PoTransaction service is combined with the reading of the environment file (SFI=07h).\nThe mutual authentication process between Calypso PO and Calypso SAM is initiated transparently.\n/* Prepare the security settings used during the Calypso transaction */ auto poSecuritySettings = std::make_shared\u0026lt;PoSecuritySettings::PoSecuritySettingsBuilder\u0026gt;(samResource)-\u0026gt;build(); /* Create a PoTransaction object to manage the Calypso transaction */ auto poTransaction = std::make_shared\u0026lt;PoTransaction\u0026gt;( std::make_shared\u0026lt;SeResource\u0026lt;CalypsoPo\u0026gt;\u0026gt;(poReader, calypsoPo), poSecuritySettings); const uint8_t RECORD_NUMBER_1 = 1; const uint8_t SFI_Environment = 0x07; /* Read the Environment file at the Session Opening (we could have added other commands) */ poTransaction-\u0026gt;prepareReadRecordFile( SFI_Environment, /* The sfi to select */ RECORD_NUMBER_1); /* Open Session with the debit key */ poTransaction-\u0026gt;processOpening(PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT); /* Get the Environment data */ std::shared_ptr\u0026lt;ElementaryFile\u0026gt; efEnvironment = calypsoPo-\u0026gt;getFileBySfi(SFI_Environment); const std::string environmentLog = ByteArrayUtil::toHex(efEnvironment-\u0026gt;getData()-\u0026gt;getContent()); /* ... */  Close the Calypso secure session 3rd PO exchange:\nSimply close the Calypso secure session\nThe mutual authentication is finalized, it includes the authentication of the data in the read file.\nNote: any technical, crytographic or content-related incident in the Calypso PO would be signalled by an exception and would interrupt the thread of execution.\n/* Schedule the closure of the channel with the PO after the closing of the secure session */ poTransaction-\u0026gt;prepareReleasePoChannel(); /* Perform the closing of the Calypso Secure Session */ poTransaction-\u0026gt;processClosing(); /* ... */  Find the complete code source below.\n CMake build Create a CMakeLists.txt file as follows:\n# # Copyright (c) 2020 Calypso Networks Association https://www.calypsonet-asso.org/ # # All rights reserved. This program and the accompanying materials are made available under the # terms of the Eclipse Public License version 2.0 which accompanies this distribution, and is # available at https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html # CMAKE_MINIMUM_REQUIRED(VERSION 2.8) SET(CMAKE_LEGACY_CYGWIN_WIN32 0) SET(CMAKE_MACOSX_RPATH 1) SET(CMAKE_CXX_STANDARD 11) SET(CMAKE_C_COMPILER_WORKS 1) SET(CMAKE_CXX_COMPILER_WORKS 1) PROJECT(KeypleDemo) SET(KEYPLE_SOURCE_DIR \u0026quot;\u0026lt;path_to_keyple_repos\u0026gt;\u0026quot;) INCLUDE_DIRECTORIES( ${CMAKE_CURRENT_SOURCE_DIR} # Core ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/command/exception ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/selection ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/event ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/exception ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/message ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/seproxy/protocol ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util ${KEYPLE_SOURCE_DIR}/component/keyple-core/src/main/util/bertlv # Plugin ${KEYPLE_SOURCE_DIR}/component/keyple-plugin/pcsc/src/main # Common ${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main ${KEYPLE_SOURCE_DIR}/component/keyple-common/src/main/exception # Calypso ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/builder ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/po/parser ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/command/sam ${KEYPLE_SOURCE_DIR}/component/keyple-calypso/src/main/transaction # pcsc (Linux / macOS) /usr/include/PCSC ) IF(WIN32) SET(CMAKE_FIND_LIBRARY_PREFIXES \u0026quot;\u0026quot;) SET(CMAKE_FIND_LIBRARY_SUFFIXES \u0026quot;.dll\u0026quot;) SET(CMAKE_BUILD_DIRECTORY \u0026quot;${CMAKE_CURRENT_BINARY_DIR}\u0026quot;) SET(WINSCARD winscard.lib) ENDIF(WIN32) IF(APPLE) SET(CMAKE_FIND_LIBRARY_PREFIXES \u0026quot;lib\u0026quot;) SET(CMAKE_FIND_LIBRARY_SUFFIXES \u0026quot;.dylib\u0026quot;) SET(CMAKE_BUILD_DIRECTORY \u0026quot;${CMAKE_CURRENT_BINARY_DIR}\u0026quot;) SET(WINSCARD \u0026quot;-framework PCSC\u0026quot;) ENDIF(APPLE) IF(UNIX) SET(SPEC_LIBS pthread pcsclite rt) ENDIF(UNIX) IF(APPLE) SET(SPEC_LIBS pthread) ENDIF(APPLE) ADD_EXECUTABLE( demo_po_authentication ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp ) TARGET_LINK_DIRECTORIES(demo_po_authentication PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/build) TARGET_LINK_LIBRARIES(demo_po_authentication keyplecommon keyplepluginpcsc keyplecore keyplecalypso ${SPEC_LIBS})  Now build the demo code:\nmkdir build cd build cmake .. make   Run  Connect two USB PC/SC Readers. Insert the Calypso SAM in the SAM reader. Insert the Calypso PO in the PO reader. Run the application.   FAQ How do I find out the names of the readers?\nIf you don’t know the reader name, several options:\n run the application in debug mode and get the reader name in plugin variable run \u0026lsquo;pcsctest\u0026rsquo; (macOS) run \u0026lsquo;pcsc_scan\u0026rsquo; (Linux)  Identify which reader will be the PO (contactless) reader and the SAM (contact) reader and replace PO_READER_NAME and SAM_READER_NAME with their values.\nHow to activate the Keyple\u0026rsquo;s logs?\nLogs are automatically activated but log level can be dynamically changed by a simple call to the Logger::setLevel() function. Default value is Logger::Level::logDebug.\nclass DemoPoAuthentication final {}; const std::shared_ptr\u0026lt;Logger\u0026gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication)); logger-\u0026gt;setLoggerLevel(Logger::Level::logError);  Full code Here is the complete code of this quick start in one single block.\n/************************************************************************************************** * Copyright (c) 2020 Calypso Networks Association * * https://www.calypsonet-asso.org/ * * * * See the NOTICE file(s) distributed with this work for additional information regarding * * copyright ownership. * * * * This program and the accompanying materials are made available under the terms of the Eclipse * * Public License 2.0 which is available at http://www.eclipse.org/legal/epl-2.0 * * * * SPDX-License-Identifier: EPL-2.0 * **************************************************************************************************/ /* Common */ #include \u0026quot;IllegalStateException.h\u0026quot; #include \u0026quot;LoggerFactory.h\u0026quot; /* Core */ #include \u0026quot;ByteArrayUtil.h\u0026quot; #include \u0026quot;SeCommonProtocols.h\u0026quot; #include \u0026quot;SeSelector.h\u0026quot; #include \u0026quot;SeSelection.h\u0026quot; #include \u0026quot;SeProxyService.h\u0026quot; /* PCSC */ #include \u0026quot;PcscPluginFactory.h\u0026quot; #include \u0026quot;PcscProtocolSetting.h\u0026quot; #include \u0026quot;PcscReader.h\u0026quot; /* Calypso */ #include \u0026quot;CalypsoPo.h\u0026quot; #include \u0026quot;CalypsoSam.h\u0026quot; #include \u0026quot;ElementaryFile.h\u0026quot; #include \u0026quot;PoSecuritySettings.h\u0026quot; #include \u0026quot;PoSelectionRequest.h\u0026quot; #include \u0026quot;PoSelector.h\u0026quot; #include \u0026quot;PoTransaction.h\u0026quot; #include \u0026quot;SamRevision.h\u0026quot; #include \u0026quot;SamSelector.h\u0026quot; #include \u0026quot;SamSelectionRequest.h\u0026quot; using namespace keyple::calypso::command::po; using namespace keyple::calypso::command::po::builder; using namespace keyple::calypso::command::po::parser; using namespace keyple::calypso::command::sam; using namespace keyple::calypso::transaction; using namespace keyple::common; using namespace keyple::common::exception; using namespace keyple::core::command::exception; using namespace keyple::core::selection; using namespace keyple::core::seproxy; using namespace keyple::core::seproxy::event; using namespace keyple::core::seproxy::exception; using namespace keyple::core::seproxy::message; using namespace keyple::core::seproxy::protocol; using namespace keyple::core::util; using namespace keyple::plugin::pcsc; class DemoPoAuthentication final {}; const std::shared_ptr\u0026lt;Logger\u0026gt; logger = LoggerFactory::getLogger(typeid(DemoPoAuthentication)); // PO Reader name const std::string PO_READER_NAME = \u0026quot;XXX\u0026quot;; // SAM Reader name const std::string SAM_READER_NAME = \u0026quot;XXX\u0026quot;; // Keyple test kit profile 1, Application 2 const std::string AID = \u0026quot;315449432E49434131\u0026quot;; const uint8_t RECORD_NUMBER_1 = 1; const uint8_t SFI_Environment = 0x07; int main(int argv, char **args) { // Get the instance of the SeProxyService (Singleton pattern) SeProxyService\u0026amp; seProxyService = SeProxyService::getInstance(); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Get and Configure the PO \u0026amp; SAM Readers =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); // Register the PcscPlugin with SeProxyService, get the corresponding generic ReaderPlugin auto pluginFactory = std::make_shared\u0026lt;PcscPluginFactory\u0026gt;(); std::shared_ptr\u0026lt;ReaderPlugin\u0026gt; readerPlugin = seProxyService.registerPlugin(pluginFactory); // Get the PO reader std::shared_ptr\u0026lt;SeReader\u0026gt; poReader = readerPlugin-\u0026gt;getReader(PO_READER_NAME); // Get a SAM reader std::shared_ptr\u0026lt;SeReader\u0026gt; samReader = readerPlugin-\u0026gt;getReader(SAM_READER_NAME); // Eventually, configure the SAM reader parameters // ... /* Set Pcsc settings per reader */ poReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T1); samReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_PROTOCOL, PcscReader::SETTING_PROTOCOL_T0); /* * PC/SC card access mode: * * The SAM is left in the SHARED mode (by default) to avoid automatic resets due to the limited * time between two consecutive exchanges granted by Windows. * * This point will be addressed in a coming release of the Keyple PcSc reader plugin. * * The PO reader is set to EXCLUSIVE mode to avoid side effects (on OS Windows 8+) during the * selection step that may result in session failures. * * See KEYPLE-CORE.PC.md file to learn more about this point. * */ samReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED); poReader-\u0026gt;setParameter(PcscReader::SETTING_KEY_MODE, PcscReader::SETTING_MODE_SHARED); /* Set the PO reader protocol flag */ poReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_ISO14443_4, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO14443_4]); poReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_B_PRIME, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_B_PRIME]); samReader-\u0026gt;addSeProtocolSetting( SeCommonProtocols::PROTOCOL_ISO7816_3, PcscProtocolSetting::PCSC_PROTOCOL_SETTING[SeCommonProtocols::PROTOCOL_ISO7816_3]); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Create a SAM resource after selecting the SAM =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); // Prepare the selector to ensure the correct SAM is used auto selector = SamSelector::builder()-\u0026gt;samRevision(SamRevision::AUTO).build(); auto samSelector = std::dynamic_pointer_cast\u0026lt;SamSelector\u0026gt;(selector); // Make the SAM selection SeSelection samSelection; auto samSelectionRequest = std::make_shared\u0026lt;SamSelectionRequest\u0026gt;(samSelector); auto abstractSamSelectionRequest = std::reinterpret_pointer_cast\u0026lt;AbstractSeSelectionRequest\u0026lt;AbstractApduCommandBuilder\u0026gt;\u0026gt;( samSelectionRequest); samSelection.prepareSelection(abstractSamSelectionRequest); std::shared_ptr\u0026lt;CalypsoSam\u0026gt; calypsoSam; if (samReader-\u0026gt;isSePresent()) { std::shared_ptr\u0026lt;SelectionsResult\u0026gt; selectionsResult = samSelection.processExplicitSelection(samReader); if (selectionsResult-\u0026gt;hasActiveSelection()) { calypsoSam = std::dynamic_pointer_cast\u0026lt;CalypsoSam\u0026gt;( selectionsResult-\u0026gt;getActiveMatchingSe()); } else { throw IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } } else { throw IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader-\u0026gt;getName()); } // Associate the calypsoSam and the samReader to create the samResource auto samResource = std::make_shared\u0026lt;SeResource\u0026lt;CalypsoSam\u0026gt;\u0026gt;(samReader, calypsoSam); // Prepare the security settings used during the Calypso transaction auto poSecuritySettings = std::make_shared\u0026lt;PoSecuritySettings::PoSecuritySettingsBuilder\u0026gt;(samResource)-\u0026gt;build(); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Display basic information about the readers and SAM =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= PO Reader Name = %\\n\u0026quot;, poReader-\u0026gt;getName()); const std::string samSerialNumber = ByteArrayUtil::toHex(samResource-\u0026gt;getMatchingSe()-\u0026gt;getSerialNumber()); logger-\u0026gt;info(\u0026quot;= SAM Reader Name = %, Serial Number = %\\n\u0026quot;, samResource-\u0026gt;getSeReader()-\u0026gt;getName(), samSerialNumber); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Prepare the Calypso PO selection =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); // Prepare a Calypso PO selection SeSelection seSelection; // Setting of an AID based selection of a Calypso Revision 3.1 PO // // Select the first application matching the selection AID whatever the card communication // protocol // Keep the logical channel open after the selection // // Calypso selection: configures a PoSelectionRequest with all the desired attributes to // make the selection and read additional information afterwards auto aidSelector = SeSelector::AidSelector::builder()-\u0026gt;aidToSelect(AID).build(); auto seSelector = PoSelector::builder()-\u0026gt;aidSelector(aidSelector) // the application identifier // to indicate if an invalidated PO should be accepted // or not .invalidatedPo(PoSelector::InvalidatedPo::REJECT) .build(); auto poSelector = std::dynamic_pointer_cast\u0026lt;PoSelector\u0026gt;(seSelector); auto poSelectionRequest = std::make_shared\u0026lt;PoSelectionRequest\u0026gt;(poSelector); // Add the selection case to the current selection // (we could have added other cases) auto abstractPoSelectionRequest = std::reinterpret_pointer_cast\u0026lt;AbstractSeSelectionRequest\u0026lt;AbstractApduCommandBuilder\u0026gt;\u0026gt;( poSelectionRequest); seSelection.prepareSelection(abstractPoSelectionRequest); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Check if a PO is present in the reader =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); if (poReader-\u0026gt;isSePresent()) { logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Start of the Calypso PO processing =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= 1st PO exchange =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= AID based selection =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); try { // Actual PO communication: operate through a single request the Calypso PO selection std::shared_ptr\u0026lt;CalypsoPo\u0026gt; calypsoPo = std::dynamic_pointer_cast\u0026lt;CalypsoPo\u0026gt;( seSelection.processExplicitSelection(poReader)-\u0026gt;getActiveMatchingSe()); logger-\u0026gt;info(\u0026quot;The selection of the PO has succeeded\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= 2nd PO exchange =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Open a Calypso secure session =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Reading of Environment file (SFI=07h) =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); // Create a PoTransaction object to manage the Calypso transaction auto poTransaction = std::make_shared\u0026lt;PoTransaction\u0026gt;( std::make_shared\u0026lt;SeResource\u0026lt;CalypsoPo\u0026gt;\u0026gt;(poReader, calypsoPo), poSecuritySettings); // Read the Environment file at the Session Opening // (we could have added other commands) poTransaction-\u0026gt;prepareReadRecordFile( SFI_Environment, // the sfi to select RECORD_NUMBER_1); // Open Session with the debit key poTransaction-\u0026gt;processOpening( PoTransaction::SessionSetting::AccessLevel::SESSION_LVL_DEBIT); // Get the Environment data std::shared_ptr\u0026lt;ElementaryFile\u0026gt; efEnvironment = calypsoPo-\u0026gt;getFileBySfi(SFI_Environment); const std::string environmentLog = ByteArrayUtil::toHex(efEnvironment-\u0026gt;getData()-\u0026gt;getContent()); logger-\u0026gt;info(\u0026quot;File Environment log: %\\n\u0026quot;, environmentLog); if (!calypsoPo-\u0026gt;isDfRatified()) { logger-\u0026gt;info(\u0026quot;============= Previous Calypso Secure Session was not ratified =============\\n\u0026quot;); } logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= 3th PO exchange =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= Close the Calypso secure session =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); // To close the channel with the PO after the closing poTransaction-\u0026gt;prepareReleasePoChannel(); // Close the Calypso Secure Session // A ratification command will be sent (CONTACTLESS_MODE) poTransaction-\u0026gt;processClosing(); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= The Calypso secure session ended successfully =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= (Successful mutual authentication) =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;= End of the Calypso PO processing =\\n\u0026quot;); logger-\u0026gt;info(\u0026quot;============================================================================\\n\u0026quot;); } catch (const Exception\u0026amp; e) { logger-\u0026gt;error(\u0026quot;Exception: %\\n\u0026quot;, e.getMessage()); } } else { logger-\u0026gt;error(\u0026quot;The selection of the PO has failed\\n\u0026quot;); } return 0; }  Sample trace ============================================================================ = Get and Configure the PO \u0026amp; SAM Readers = ============================================================================ initNativeReaders - getting card terminals run - starting executor monitoring thread [PcscReaderImpl] constructor =\u0026gt; using terminal OMNIKEY CardMan (076B:5421) 5421(1) [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME =transmission_mode, VALUE = [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = protocol, VALUE = [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = mode, VALUE = [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = disconnect, VALUE = run - starting executor monitoring thread constructor =\u0026gt; using terminal OMNIKEY CardMan (076B:5421) 5421(2) [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = transmission_mode, VALUE = [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = protocol, VALUE = [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = mode, VALUE = [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = disconnect, VALUE = Registering a new Plugin to the platform : PcscPlugin [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = protocol, VALUE = T1 [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = protocol, VALUE = T0 [OMNIKEY CardMan (076B:5421) 5421(1)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = mode, VALUE = shared [OMNIKEY CardMan (076B:5421) 5421(2)] setParameter =\u0026gt; PCSC: Set a parameter. NAME = mode, VALUE = shared ============================================================================ = Create a SAM resource after selecting the SAM = ============================================================================ protocolFlagMatches - physical channel not open, opening it [OMNIKEY CardMan (076B:5421) 5421(1)] openAndConnect - protocol: T=0 openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(1) with protocol: T=0, connectProtocol: 1 and sharingMode: 2 openAndConnect - card state: 84 [OMNIKEY CardMan (076B:5421) 5421(1)] Opening of a physical SE channel in shared mode [OMNIKEY CardMan (076B:5421) 5421(1)] protocolFlagMatches =\u0026gt; matching SE. PROTOCOLFLAG = SEPROTOCOL: {NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS} processSeRequestSet - processing requests set [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =\u0026gt; transmit SEREQUEST: {REQUESTS = ApduRequests: {}, SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 7816-3, TRANMISSIONMODE = CONTACTS}AIDSELECTOR = null, ATRFILTER: {REGEX = .*}}} [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =\u0026gt; Logical channel open = 0 [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequests =\u0026gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {}, SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b3f9600805a4880c1205017aec11a36829000, FCI = R-APDU: {STATUS = FAILURE, BYTES (0) = }, HASMATCHED = 1}, CHANNELWASOPEN = 0} ============================================================================ = Display basic information about the readers and SAM = ============================================================================ = PO Reader Name = OMNIKEY CardMan (076B:5421) 5421(2) = SAM Reader Name = OMNIKEY CardMan (076B:5421) 5421(1), Serial Number = AEC11A36 ============================================================================ = Prepare the Calypso PO selection = ============================================================================ ============================================================================ = Check if a PO is present in the reader = ============================================================================ ============================================================================ = Start of the Calypso PO processing = ============================================================================ = 1st PO exchange = = AID based selection = ============================================================================ protocolFlagMatches - physical channel not open, opening it [OMNIKEY CardMan (076B:5421) 5421(2)] openAndConnect - protocol: T=1 openAndConnect - connecting tp OMNIKEY CardMan (076B:5421) 5421(2) with protocol: T=1, connectProtocol: 2 and sharingMode: 2 openAndConnect - card state: 84 [OMNIKEY CardMan (076B:5421) 5421(2)] Opening of a physical SE channel in shared mode [OMNIKEY CardMan (076B:5421) 5421(2)] protocolFlagMatches =\u0026gt; matching SE. PROTOCOLFLAG = SEPROTOCOL: {NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS} processSeRequestSet - processing requests set [OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =\u0026gt; transmit SEREQUEST: {REQUESTS = ApduRequests: {}, SELECTOR = SESELECTOR: {SEPROTOCOL: {NAME = ISO 14443-4, TRANMISSIONMODE = CONTACTLESS}AIDSELECTOR: {AIDTOSELECT = 315449432e49434131FILEOCCURRENCE: {ISOBITMASK = 0(0x00)}FILECONTROLINFORMATION: {ISOBITMASK = 0(0x00)}0x0}, ATRFILTER = null}} [OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =\u0026gt; Logical channel open = 0 [OMNIKEY CardMan (076B:5421) 5421(2)] openLogicalChannel =\u0026gt; Select Application with AID = 315449432e49434131 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Internal Select Application, RAWDATA = 00a4040009315449432e4943413100, CASE4 = 1}, elapsed 13c ms [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu \u0026gt;\u0026gt; 00a4040009315449432e4943413100 [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu \u0026lt;\u0026lt; 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, elapsed c ms [OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequests =\u0026gt; receive SERESPONSE: {RESPONSES = APDURESPONSES: {}, SELECTIONSTATUS = SELECTIONSTATUS: {ATR = ATR = 3b888001000000009171710098, FCI = R-APDU: {STATUS = SUCCESS, BYTES (27) = 6f238409315449432e49434131a516bf0c13c70800000000c17be1f653070a3c23051410019000}, HASMATCHED = 1}, CHANNELWASOPEN = 0} Application Serial Number = 00000000C17BE1F6 Discretionary Data = 0a3c2305141001 The selection of the PO has succeeded ============================================================================ = 2nd PO exchange = = Open a Calypso secure session = = Reading of Environment file (SFI=07h) = ============================================================================ [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =\u0026gt; Logical channel open = 1 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Select Diversifier, RAWDATA = 801400000800000000c17be1f6, CASE4 = 0}, elapsed 208 ms [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu \u0026gt;\u0026gt; 801400000800000000c17be1f6 [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu \u0026lt;\u0026lt; 9000 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000}, elapsed 37 ms [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Get Challenge, RAWDATA = 8084000004, CASE4 = 0}, elapsed 0 ms [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu \u0026gt;\u0026gt; 8084000004 [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu \u0026lt;\u0026lt; ef48651d9000 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (6) = ef48651d9000}, elapsed 3 ms identification: TERMINALCHALLENGE = ef48651d [OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =\u0026gt; Logical channel open = 1 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Open Secure Session V3.1 - KEYINDEX=3, SFI=07, REC=1, RAWDATA = 008a0b3904ef48651d00, CASE4 = 1}, elapsed c7 ms [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu \u0026gt;\u0026gt; 008a0b3904ef48651d00 [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu \u0026lt;\u0026lt; 030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (39) = 030ab2cf0030791d00000000000000000000000000000000000000000000000000000000009000}, elapsed e ms processAtomicOpening =\u0026gt; opening: CARDCHALLENGE = CF, POKIF = 30, POKVC = 79 initialize: POREVISION = REV3_1, SAMREVISION = C1, SESSIONENCRYPTION = 0, VERIFICATIONMODE = 0 initialize: VERIFICATIONMODE = 0, REV32MODE = 0, KEYRECNUMBER = 0(0x00) initialize: KIF = 48(0x30), KVC = 79(0x79), DIGESTDATA = 030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000 File Environment log: 0000000000000000000000000000000000000000000000000000000000 ============================================================================ = 3th PO exchange = = Close the Calypso secure session = ============================================================================ [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =\u0026gt; Logical channel open = 1 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Digest Init, RAWDATA = 808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000, CASE4 = 0}, elapsed 2f ms [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu \u0026gt;\u0026gt; 808a00ff273079030ab2cf0030791d0000000000000000000000000000000000000000000000000000000000 [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu \u0026lt;\u0026lt; 9000 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000}, elapsed 6 ms [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Digest Close, RAWDATA = 808e000004, CASE4 = 0}, elapsed 0 ms [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu \u0026gt;\u0026gt; 808e000004 [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu \u0026lt;\u0026lt; 819e515d9000 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (6) = 819e515d9000}, elapsed 9 ms SIGNATURE = 819e515d [OMNIKEY CardMan (076B:5421) 5421(2)] processSeRequest =\u0026gt; Logical channel open = 1 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Close Secure Session, RAWDATA = 008e800004819e515d00, CASE4 = 1}, elapsed 31 ms [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu \u0026gt;\u0026gt; 008e800004819e515d00 [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu \u0026lt;\u0026lt; 08d222e99000 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (6) = 08d222e99000}, elapsed 34 ms [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = , RAWDATA = 00b2000000, CASE4 = 0}, elapsed 0 ms [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - c-apdu \u0026gt;\u0026gt; 00b2000000 [OMNIKEY CardMan (076B:5421) 5421(2)] transmitApdu - r-apdu \u0026lt;\u0026lt; 6b00 [OMNIKEY CardMan (076B:5421) 5421(2)] processApduRequest =\u0026gt; R-APDU: {STATUS = FAILURE, BYTES (2) = 6b00}, elapsed 2a ms [OMNIKEY CardMan (076B:5421) 5421(2)] closePhysicalChannel [OMNIKEY CardMan (076B:5421) 5421(2)] closeAndDisconnect - reset: y [OMNIKEY CardMan (076B:5421) 5421(2)] Ignore =\u0026gt; Event SE_PROCESSED received in currentState WAIT_FOR_START_DETECTION [OMNIKEY CardMan (076B:5421) 5421(1)] processSeRequest =\u0026gt; Logical channel open = 1 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; APDUREQUEST: {NAME = Digest Authenticate, RAWDATA = 808200000408d222e9, CASE4 = 0}, elapsed 61 ms [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - c-apdu \u0026gt;\u0026gt; 808200000408d222e9 [OMNIKEY CardMan (076B:5421) 5421(1)] transmitApdu - r-apdu \u0026lt;\u0026lt; 9000 [OMNIKEY CardMan (076B:5421) 5421(1)] processApduRequest =\u0026gt; R-APDU: {STATUS = SUCCESS, BYTES (2) = 9000}, elapsed 5e ms ============================================================================ = The Calypso secure session ended successfully = = (Successful mutual authentication) = = End of the Calypso PO processing = ============================================================================  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"a649192166df002a8bbc7d300bde003b","permalink":"https://keyple.org/docs-1.0/build-your-first-app/cpp-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/build-your-first-app/cpp-app/","section":"docs-1.0","summary":"This quick start describes how to create a ready-to-execute C++ command-line application that runs a simple transaction based on a Calypso portable object involving two smart card readers.","tags":null,"title":"Build your first C++ application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   This page describes the core elements of Keyple, i.e. the concepts and APIs of Keyple Core that are used to build any application implementing Keyple.\nIt is essential for the future user of Keyple to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on Keyple Core.\n Reader Keyple\u0026rsquo;s primary goal being to interact with smart cards (or smartphones) worn by individuals, it is logical to put the Reader at the top of Keyple Core\u0026rsquo;s concepts.\nIndeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via Keyple Core or using an extension (such as Keyple Calypso).\nThese interfaces provide the means to\n identify the underlying physical reader, manage communication protocols, detect the presence and communicate with smart cards.  The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.\nMore information\n Plugin In Keyple language a plugin is a service that allows the management of readers of a certain type. The plugin is responsible for informing the application about the availability of readers. The readers of the same plugin are usually hardware linked to the same physical interface.\nDepending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).\nThe Plugin interface essentially allows to list and retrieve the available readers.\nMore information\n Smart card service This is the Keyple Core service that concentrates the knowledge of active plugins and readers.\nAt startup, a Keyple application must register the plugins it uses. Conversely, it can also unregister them.\nThe SmartCardService will then make sure that the resources used are properly released.\nMore information\n Observation The observation concept applies to readers as well as to plugins; optional, it is used depending on the needs.\nIt consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.\nNot all plugins and readers are observable.\nMore information\n Selection In Keyple the concept of selection is derived from the application selection defined by the ISO7816-4 standard.\nIt supplements it by managing cards that do not have the standard command using identification mechanisms based on Answer To Reset and the communication protocol, and also by allowing the execution of commands immediately following application selection or detection.\nThis principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.\nSeveral targets can be defined by the application according to the different customer cards expected.\nThe default selection principle consists in providing an observable reader with a set of selection cases corresponding to the expected cards and receiving notifications containing not only the card identification but also the result of all additional commands that the application will have attached.\nMore information\n Abstract smart card The abstract smart card concept is used by specific extensions (e.g. Keyple Calypso) and by the Keyple Core selection mechanism. It corresponds to an abstract container model implemented by the extension specific to a card type and returned by the selection process.\nThis container will be able to carry all the useful information known about the card.\nNote: this concept, mentioned here for understanding, should not appear to the application developer if he uses a card extension.\nMore information\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"33387f208f7727bafae93272a32b53ab","permalink":"https://keyple.org/docs-1.0/developer-guide/common-concepts/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/common-concepts/","section":"docs-1.0","summary":"Glossary of the key terms of the Keyple solution.","tags":null,"title":"Common concepts","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview A standalone application is an application that runs in a device in contact with the end user.\nIt has at least one local smart card reader and manages itself the interaction with the user.\nIn the ticketing industry, it is typically the software that runs a validator, a vending machine or a control terminal.\nThe diagram below illustrates the organization of the local standalone components:  \n Before you start  In pre-requisite, read the common concepts page and become familiar with the basic concepts on which Keyple is based. Any implementation of a Keyple application starts with the implementation of Keyple Core, please study the workflow proposed in the following chapter. Explore the Keyple Core API to discover all the possibilities offered by Keyple Core. Take inspiration from the examples. Follow the explanations given in the Build your first app section to configure your environment. Using the Java components or C++ components pages, import Keyple Core into your project and start playing with Keyple. Don\u0026rsquo;t forget to explore the potential of Keyple card-specific extensions such as Keyple Calypso.   Workflow Keyple Core is built around the concepts described here and sometimes proposes several ways to perform an action or to achieve a result depending on the needs of the application.\nThe purpose of this section is to guide you in its use.\nCreation of the Smart Card Service This is the very first step in the realization of a Keyple application:\n/* Get the instance of the SmartCardService */ SmartCardService smartCardService = SmartCardService.getInstance();  The Smart Card Service is based on the SmartCardService object, which is a singleton that must be held by the application all along its execution.\nIts main role is to centralize Keyple resources and manage their lifecycle.\nChoose the plugin The Keyple application developer will choose the plugins he needs according to the equipment on which his Keyple application will run.\nFor example, if the environment is PC based, one will probably, but without obligation, go for the PC/SC plugin.\nFor an Andoid terminal environment, the plugin could be the standard Android NFC plugin or one of the plugins available from the industrial partners of the project. For a complete list of available plugins, please see the Java or C++ pages.\n A new plugin can also be created if the envisaged hardware does not yet have its plugin.   Register the plugin All Keyple plugins implement the Plugin interface.\nThe plugin registration consists in submitting its factory to the Smart Card Service.\n/* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, readerExceptionHandlerImpl));   The plugin factories all implement the interface expected by SmartCardService.\nDepending on the case, the constructor of the factory provided by the plugin can take parameters as argument.\nFor example, in the code above, the PC/SC plugin expects exception handlers, but in other cases it could be other parameters.\n  Observation of the plugin  The notion of plugin observation applies only to hardware environments in which the readers are removable.   The observation of reader connections and disconnections is achieved through a background task managed by Keyple Core.\nIt is therefore imperative to provide an exception handler to allow Keyple Core to warn the application in case of an execution error during monitoring or event notification.\nHere is an example of exception handler implementation in a PC/SC plugin context:\n... private static class PluginExceptionHandlerImpl implements PluginObservationExceptionHandler { @Override public void onPluginObservationError(String pluginName, Throwable throwable) { logger.error(\u0026quot;An unexpected plugin error occurred: {}\u0026quot;, pluginName, throwable); } } } /* Create an exception handler for plugin observation */ PluginExceptionHandlerImpl pluginExceptionHandlerImpl = new ExceptionHandlerImpl(); /* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, null)); ...  For the observation of the plugin itself, the application must provide an object implementing the PluginObserver interface to the plugin after having cast it in ObservablePlugin.\n((ObservablePlugin) plugin).addObserver(new PluginObserver());  The PluginObserver interface requires the implementation of the update method that will be called by Keyple Core when notifying plugin events.\nclass PluginObserver implements ObservablePlugin.PluginObserver { @Override public void update(PluginEvent event) { switch (event.getEventType()) { case READER_CONNECTED: // here the processing to be done when a reader is connected ... break; case READER_DISCONNECTED: // here the processing to be done when a reader is disconnected ... break; default: break; } } } }  Retrieve the reader Readers are objects implementing the Reader interface and are returned by the plugin\u0026rsquo;s getReader method taking the name of the reader as argument.\nThe names of the readers available from the plugin are returned as a list of strings by the getReaderNames method.\nThe getReaders method also allows to retrieve all readers in a Map whose key is the name of the reader and the value the Reader object.\nHere is an example to get the 1st PC/SC reader:\nString readerName = plugin.getReaderNames().get(0); Reader reader = plugin.getReader(readerName);   Depending on the type of plugin, the reader names are more or less dynamic (e.g. a PC/SC based system vs. an embedded terminal), it is sometimes necessary to implement an identification mechanism in order to assign the right reader to the right place in the system (for example by using regular expressions).   Customize the reader settings Take a close look at the parameters proposed by the plugin and its readers.\nIn particular, it is necessary to configure the expected communication protocols, but it is also possible that other settings exist depending on the hardware context.\nObservation of the reader The observation of inserting and removing cards from readers is similar to the observation of plugins in that it requires the same operations, i.e. the use of an exception handler and an object implementing a dedicated interface.\n... private static class ReaderExceptionHandlerImpl implements ReaderObservationExceptionHandler { @Override public void onReaderObservationError(String pluginName, String readerName, Throwable throwable) { logger.error(\u0026quot;An unexpected reader error occurred: {}:{}\u0026quot;, pluginName, readerName, throwable); } } } /* Create an exception handler for reader observation */ ReaderExceptionHandlerImpl readerExceptionHandlerImpl = new ExceptionHandlerImpl(); /* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, readerExceptionHandlerImpl)); ...  The observation of the events of the reader is done in a similar way to that of the plugin, by adding an observer:\n((ObservableReader) reader).addObserver(new ReaderObserver());  and implementing the ReaderObserver interface:\nclass ReaderObserver implements ObservableReader.ReaderObserver { @Override public void update(ReaderEvent event) { switch (event.getEventType()) { case CARD_INSERTED: // here the processing to be done when a card is inserted ... break; case CARD_MATCHED: // here the processing to be done when a card matched the selection ... break; case CARD_REMOVED: // here the processing to be done when a card is removed ... break; default: break; } } } }   Observation of the readers is optional in Keyple. It facilitates an event-driven programming mode, but an application developer can choose not to observe a reader, either because this reader is not designed to manage card insertions/withdrawals (for example an Android OMAPI reader or a SAM reader), or because the application is designed to directly manage the presence of a card (refer to the Reader interface).   Card selection The card selection service offered by Keyple Core gives multiple possibilities to choose the processing according to the type of card presented to the reader.\nIt is based on a filtering process according to three possible criteria, each of which is optional:\n the communication protocol of the card (usually also identifying a card technology) the answer to reset of the card (ATR) the ISO standardized application identifier (AID)  Each of these criteria can be defined in a CardSelector object.\nWhen a card is inserted, it is evaluated according to these criteria and will be given the status \u0026ldquo;selected\u0026rdquo; or not.\nWhen a card is not selected, no other operation will be possible with it. Depending on the chosen setting, the result of the selection will or will not be made available to the application. It is thus possible to directly ignore cards that do not correspond to the defined selection criteria.\nWhen a card is selected, the result is an object that extends the AbstractSmartCard and contains all the information known about the card at that stage.\nIn the case of a ISO standardized card, the application is selected with the provided AID (additional settings are available to specify the desired navigation within the card applications list).\nIn addition to the selection process itself, specific APDU commands can be sent to the card if the selection is successful. The output data of these commands are available in the instance of the object AbstractSmarCard.\nThe CardSelector and the additional APDU commands are grouped in a CardSelectionRequest object.\nOne or more CardSelectionRequest can be set up to perform as many selection cases, each targeting a particular card or application.\nThe final selection process takes as input a list of CardSelectionRequest and gets in return a list of CardSelectionResponse.\nCard selection steps In this guide we will not show the addition of supplementary APDU commands. Please refer to the Calypso guide for an implementation example.\nCreate the card selection service The card selection service will be used all along the card search process.\ncardSelectionService = new CardSelectionsService();  Create the selection cases The application can create as many selection cases as the type of cards expected. The order in which the selection cases are prepared is important because it will favor the latency delay for the processing of the cards corresponding to the first case. It is therefore recommended to place the most common card profile in the application context first.\n/** Create a new class extending AbstractCardSelection */ public final class GenericCardSelection extends AbstractCardSelection { public GenericCardSelection(CardSelector cardSelector) { super(cardSelector); } @Override protected AbstractSmartCard parse(CardSelectionResponse cardSelectionResponse) { class GenericSmartCard extends AbstractSmartCard { public GenericSmartCard(CardSelectionResponse cardSelectionResponse) { super(cardSelectionResponse); } public String toJson() { return \u0026quot;{}\u0026quot;; } } return new GenericSmartCard(cardSelectionResponse); } } final String aid1 = \u0026quot;AABBCCDDEE\u0026quot;; final String aid2 = \u0026quot;EEDDCCBBAA\u0026quot;; // first selection case targeting cards with AID1 GenericCardSelection cardSelector1 = new GenericCardSelection( CardSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid1).build()) .build()); // Add the selection case to the current selection cardSelectionsService.prepareSelection(cardSelector1); // first selection case targeting cards with AID1 GenericCardSelection cardSelector2 = new GenericCardSelection( CardSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid2).build()) .build()); // Add the selection case to the current selection cardSelectionsService.prepareSelection(cardSelector2);  Proceed to the selection with a non-observable reader The processExplicitSelections method of CardSelectionService performs the actual communication with the card.\n... // Check if a card is present in the reader if (!reader.isCardPresent()) { logger.error(\u0026quot;No Po Card is present in the reader.\u0026quot;); return; } // Actual card communication: operate through a single request the card selection CardSelectionsResult cardSelectionsResult = cardSelectionsService.processExplicitSelections(reader); ...  Proceed to the selection with an observable reader In the case of an observable reader, the selection request is provided to the reader (it is then named Default Selection) and will be processed automatically as soon as a card is presented. The application is then notified of the event with the data resulting from the selection. Depending on the selection settings, the application will be notified of all card presentations (CARD_INSERTED event) or only those presentations that led to a successful selection (CARD_MATCHED event).\nAdd a default selection // Provide the Reader with the selection operation to be processed when a card is inserted. ((ObservableReader) reader) .setDefaultSelectionRequest( cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(), ObservableReader.NotificationMode.MATCHED_ONLY, ObservableReader.PollingMode.REPEATING);  The NotificationMode allows you to specify whether all card insertions should be reported to the application or only those that led to a successful selection.\nPollingMode indicates whether to go back to waiting for the card after processing (REPEATING) or let the application decide when to restart the search (SINGLESHOT) with startCardDetection.\nNote: when the default selection is set with the PollingMode parameter, the card detection is started automatically. However, it is possible to set a default selection without automatic start and by starting the detection independently with startCardDetection.\nReceive the result as an event ... @Override public void update(ReaderEvent event) { switch (event.getEventType()) { case CARD_MATCHED: AbstractSmartCard selectedCard = null; try { selectedCard = getDefaultSelection() .processDefaultSelectionsResponse(event.getDefaultSelectionsResponse()) .getActiveSmartCard(); } catch (KeypleException e) { logger.error(\u0026quot;Exception: {}\u0026quot;, e.getMessage()); ((ObservableReader) (event.getReader())).finalizeCardProcessing(); } if (selectedCard != null) { logger.info(\u0026quot;Observer notification: the selection of the card has succeeded.\u0026quot;); // insert the processing of the card here ... logger.info(\u0026quot;= #### End of the card processing.\u0026quot;); } else { logger.error( \u0026quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.\u0026quot;); } break; case CARD_INSERTED: logger.error( \u0026quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.\u0026quot;); break; case CARD_REMOVED: logger.trace(\u0026quot;There is no PO inserted anymore. Return to the waiting state...\u0026quot;); break; default: break; } if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED || event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) { // Informs the underlying layer of the end of the card processing, in order to manage the // removal sequence. ((ObservableReader) (event.getReader())).finalizeCardProcessing(); } } ...  Get the selection result The result of the selection is available in the AbstractSmartCard object.\n... if (!cardSelectionsResult.hasActiveSelection()) { logger.warn(\u0026quot;The selection of the application \u0026quot; + cardAid + \u0026quot; failed.\u0026quot;); } AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard(); logger.info(\u0026quot;The selection of the card has succeeded.\u0026quot;); if (smartCard.hasFci()) { String fci = ByteArrayUtil.toHex(smartCard.getFciBytes()); logger.info(\u0026quot;Application FCI = {}\u0026quot;, fci); } if (smartCard.hasAtr()) { String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes()); logger.info(\u0026quot;Card ATR = {}\u0026quot;, atr); } ...  Implementation of the application service The applicative processing of the card that follows the selection of the card is to be inserted in the processing of the CARD_INSERTED or CARD_MATCHED event.\nIt can be processed in the thread provided by the monitoring task or detached in a separate thread. The application developer must pay attention to the handling of exceptions in this part of the application. Indeed, in case of a runtime exception, the information will be given to the application via the exception handler configured beforehand.\nStopping the application The clean shutdown of a Keyple application requires the release of resources and in particular the shutdown of the observation threads.\nThis is done by unregistering the plugins in the following way:\nsmartCardService.unregisterPlugin(plugin.getName());   Keyple Core API To learn all the details of the Keyple Core API, please consult the Javadoc documentation.\nHowever, here are two diagrams showing the main features of Keyple Core:\n  The diagram below represents the main classes implemented around the Smart Card Service with in particular the observation mechanisms.  \n  The diagram below represents the main classes used for selection operations.  \n   Examples To help in the implementation of the different facilities offered by Keyple to process smart cards, a set of examples is present in the project repository  examples\nNevertheless, you will find below a brief description of them:\nExplicit Selection Shows the use of Keyple to make a card selection without observing the reader, based on testing the presence of the card by the application.\nsee the code\nDefault Selection Shows the use of Keyple to make a card selection with observation of the reader. A default selection is prepared, the presentation of a card triggers the notification of a reader event to the application.\nsee the code\nSequential Multiple Selection Executes successively several independent selection operations with the use of the ISO \u0026lsquo;NEXT\u0026rsquo; navigation flag.\nsee the code\nIllustrates the case of a card exploration with maintenance of the physical channel open.\nGrouped Multiple Selection Executes a multiple selection with logical channel closure between each selection.\nAllows the exploration of the applications of a card in a single operation but without selection at the end.\nsee the code\nDemo Card Protocol Detection Demonstrates the use of Keyple in a context where several card technologies are likely to be processed by the application.\nsee the code\nDemo Observable Reader Notification Demonstrates the use of Keyple to implement the observation of a plugin and its readers. Readers are dynamically created and an observer is assigned to them.\nsee the code\n Download The artifact Keyple Core and how to integrate it into your application is available here:\n Keyple Core Java component Keyple Core C++ component  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"462901e7345982e777004c1bbf06506a","permalink":"https://keyple.org/docs-1.0/developer-guide/standalone-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/standalone-application/","section":"docs-1.0","summary":"How to develop an end-user standalone application.","tags":null,"title":"Standalone application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview Keyple provides the \u0026ldquo;Keyple Distributed\u0026rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal.\nIn this way, you can manage transactions within a distributed architecture.\nThe diagram below shows the role of the Keyple Distributed components in the software layers used in a distributed architecture :\n   How to use it ?  In pre-requisite, read page Standalone application to understand the main concepts of Keyple in a standalone application. Read chapter Concepts to understand the main terms and concepts of the Keyple Distributed solution. Read the introduction of chapter Configuration modes to be informed about the different features and APIs proposed by the solution. Using chapter Use cases, find your use case. This will help you to determine exactly which library and API to use. Using chapter Download, import into your project the libraries specified by your use case. Using chapter Network configuration, implement the transport layer adapted to your network configuration. Implement your ticketing services as specified in the associated use case.   Concepts Here are the main concepts to keep in mind before continuing to read this user guide :\n   Concept Description     Remote Lib This is the library keyple-java-distributed-remote.\nIt must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.   Local Lib This is the library keyple-java-distributed-local.\nIt must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.   Network Lib This is the library keyple-java-distributed-network.\nThis library is implicitly imported by Remote Lib and Local Lib because it contains common network elements.   Remote Plugin Part of the Remote Lib, this is a Keyple plugin which provides only Remote Readers to the application. It manages data exchanges with the Local Service. This plugin must be registered to the smart card service like any Keyple plugin.   Remote Reader Part of the Remote Plugin, this is a Keyple reader which has some specificities :\n- each remote reader is connected to a local reader ;\n- any command sent by the application to a remote reader will be forwarded to the associated local reader ;\n- any event occurs on a local reader or plugin will be forwarded to the associated remote reader or plugin.   Local Service Part of the Local Lib, this service ensures data exchange between the Remote Plugin and local plugins and readers. It must be initialized and started by the host application.   Factory Remote Plugin and Local Service each have a specific factory class to initialize them.   Utility Remote Plugin and Local Service each have a specific utility class to access them everywhere in the code.   Node Remote Plugin and Local Service each are bind to a specific internal node which is responsible for the interfacing with the Network Endpoint.   Network Endpoint At the user\u0026rsquo;s charge, this component ensures the network exchanges between the Remote Plugin and Local Service nodes.      #concepts-table-1 table th:first-of-type { width: 130px; }  The diagram below illustrates the main functional concepts through a standard use case :\n  The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.\nThese could be for example a ticketing reloading service, where the business logic would be on the terminal with remote readers, with thin clients on A \u0026amp; B terminals communicating locally with the cards.\nIn this use case, the Keyple Distributed solution is use for card communication.\n  Here is another example, but this time it illustrates several Remote Plugin components connected to the same Local Service.\nThese could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.\nIn this use case, the Keyple Distributed solution is use for SAM communication.\n   Configuration modes The Keyple Distributed solution provides 3 different configuration modes, each one having a specific API designed on a Client-Server model :\n   Configuration mode Description     Reader Client Side Allows a server application to control a smart card reader available on a client (e.g. PO reader).   Reader Server Side Allows a client application to control a smart card reader available on a server (e.g. SAM reader).   Pool Reader Server Side Allows a client application to control a pool of smart cards readers available on a server (e.g. HSM readers).      #plugins-table-1 table th:first-of-type { width: 190px; }  Each mode provides a different Remote Plugin and Local Service components and their associated factories and utility classes.\nEach Remote Plugin and Local Service has a default name, but it\u0026rsquo;s possible to specify a custom name during the initialization phase.\nIn an application, it is thus possible to use simultaneously several configuration modes and as many instances of a configuration mode as you want, as long as the components are initialized with different names.\nReader Client Side This configuration mode allows a server application to control a smart card reader available on a client (e.g. PO reader).\n   API Client Server     Library Local Lib Remote Lib   Remote Plugin / Local Service LocalServiceClient RemotePluginServer   Factory LocalServiceClientFactory RemotePluginServerFactory   Utility LocalServiceClientUtils RemotePluginServerUtils    OPERATING MODE  Server side :  configure the factory by providing the network and plugin observer implementation. Please note that this plugin is observable only to trigger ticketing services on the server side, but does not allow observation on the local plugin (reader insertion, etc\u0026hellip;), register the Remote Plugin to the smart card service using the factory, await for events of type PluginEvent.READER_CONNECTED, when an event occurs, get the specified remote reader from the Remote Plugin, use information inside the remote reader to identify the ticketing service to execute, execute the specified ticketing service using the remote reader and all of its others information, terminate the remote ticketing service using the Remote Plugin API by transmitting if needed personal information to the client.   Client side :  configure the factory and start the Local Service by providing the network implementation, register at least a local plugin to the smart card service and get the local reader to connect to the server, execute the remote service using the Local Service API by indicating the ticketing service id to execute and transmitting to the server if needed personal information or smart card content previously read.    ILLUSTRATION The following sequence diagram shows the capabilities of the plugin through an arbitrary example that illustrates :\n the initialization phase of the local and remote components ; the registration of the local plugin and observable reader ; the selection phase of an observable reader carried out directly by the client ; the sending of the selection result and additional information to the server to remotely perform a specific ticketing service (materialization, validation, etc\u0026hellip;) ; the reception by the server of the transmitted data ; the execution of the remote ticketing service ; the server subscription to observable reader events ; the sending of information to the client at the end of processing.  Note that the network layer is deliberately hide in this diagram. Its implementation is described in the Network configuration chapter.\n  Reader Server Side  This configuration mode will only be available from version 1.1 onwards.   This configuration mode allows a client application to control a smart card reader available on a server (e.g. SAM reader).\nIt also allows to observe the plugin events (such as reader connection, etc\u0026hellip;) if desired.\n   API Client Server     Library Remote Lib Local Lib   Remote Plugin / Local Service RemotePluginClient or\nObservableRemotePluginClient LocalServiceServer   Factory RemotePluginClientFactory LocalServiceServerFactory   Utility RemotePluginClientUtils LocalServiceServerUtils    OPERATING MODE  Server side :  configure the factory and start the Local Service by providing the network implementation, register at least a local plugin to the smart card service.   Client side :  configure the factory by providing the network implementation, register the Remote Plugin to the smart card service using the factory, use the Remote Plugin and its remote readers as a local plugin (or observable plugin) with local readers.    Pool Reader Server Side This configuration mode allows a client application to control a pool of smart cards readers available on a server (e.g. HSM readers).\n   API Client Server     Library Remote Lib Local Lib   Remote Plugin / Local Service PoolRemotePluginClient PoolLocalServiceServer   Factory PoolRemotePluginClientFactory PoolLocalServiceServerFactory   Utility PoolRemotePluginClientUtils PoolLocalServiceServerUtils    OPERATING MODE  Server  configure the factory and start the Local Service by providing the network implementation, register at least a local pool plugin to the smart card service.   Client  configure the factory by providing the network implementation, register the Remote Plugin to the smart card service using the factory, use the Remote Plugin and its remote readers as a local pool plugin with local readers.     Use cases Here is a summary table of all proposed use cases. Search for the one that corresponds to your need and then look at the associated description :\n   Use Case Reader type Reader endpoint Reader observation Plugin observation     UC 1 Simple Client     UC 2 Simple Client ✔️    UC 3 Simple Server     UC 4 Simple Server ✔️    UC 5 Simple Server  ✔️   UC 6 Simple Server ✔️ ✔️   UC 7 Pool Server        #use-cases-table-2 table th:nth-of-type(6) { width: 240px; }  UC 1 This use case requires to use the Reader Client Side configuration mode.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the client side if needed.\n    Client Server     Methods to be used when initializing the factory withoutReaderObservation() -   Possible readers to use Reader or ObservableReader RemoteReaderServer    UC 2 This use case requires to use the Reader Client Side configuration mode.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withReaderObservation(...) -   Possible readers to use ObservableReader ObservableRemoteReaderServer    To observe \u0026ldquo;remotely\u0026rdquo; the reader events, you must :\n Server  register at least one observer to the remote reader created during the first client call and await for reader events, retrieve the remote reader from the Remote Plugin imperatively using the reader name contained in the received event, execute the ticketing service associated to the event using the remote reader and all of its others information, terminate the remote ticketing service associated to the event using the Remote Plugin API by transmitting if needed personal information to the client.   Client  execute a remote service first in order to connect a remote reader to the local reader and to allow the remote application to subscribe to the events of the remote reader.    UC 3 This use case requires to use the Reader Server Side configuration mode with the RemotePluginClient plugin.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the server side if needed.\n    Client Server     Methods to be used when initializing the factory withoutPluginObservation()\nwithoutReaderObservation() -   Possible readers to use Reader Reader or ObservableReader    UC 4 This use case requires to use the Reader Server Side configuration mode with the RemotePluginClient plugin.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withoutPluginObservation()\nwithReaderObservation() -   Possible readers to use ObservableReader ObservableReader    UC 5 This use case requires to use the Reader Server Side configuration mode with the ObservableRemotePluginClient plugin.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the server side if needed.\n    Client Server     Methods to be used when initializing the factory withPluginObservation()\nwithoutReaderObservation() -   Possible readers to use Reader Reader or ObservableReader    UC 6 This use case requires to use the Reader Server Side configuration mode with the ObservableRemotePluginClient plugin.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withPluginObservation()\nwithReaderObservation() -   Possible readers to use ObservableReader ObservableReader    UC 7 This use case requires to use the Pool Reader Server Side configuration mode.\nThis unique mode proposed for this plugin does not allow to observe the local reader.\n    Client Server     Methods to be used when initializing the factory - -   Possible readers to use Reader Reader     Network configuration The Keyple Distributed solution does not provide the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between Remote Plugin and Local Service components.\nSynchronous Choose this mode if you want to implement a Client-Server Synchronous communication protocol, such as standard HTTP for example.\n    Client Server     SPI to be implemented SyncEndpointClient -   Node API SyncNodeClient SyncNodeServer   Methods to be used when initializing the factory withSyncNode(...) withSyncNode()   Utility method to use to access the node - getSyncNode() or\ngetSyncNode(...)    Here is the minimal algorithm to implement in a context with a single server instance :\n  In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a serverNodeId are routed to the server associated with a SyncNodeServer node having the serverNodeId.\nAsynchronous Choose this mode if you want to implement a Full-Duplex Asynchronous communication protocol, such as Web Sockets for example.\n    Client Server     SPI to be implemented AsyncEndpointClient AsyncEndpointServer   Node API AsyncNodeClient AsyncNodeServer   Methods to be used when initializing the factory withAsyncNode(...) withAsyncNode(...)   Utility method to use to access the node getAsyncNode() or\ngetAsyncNode(...) getAsyncNode() or\ngetAsyncNode(...)    Here is the minimal algorithm to implement :\n  Exchanged data The data exchanged between Remote Plugin and Local Service components are contained in the DTO (Data Transfer Object) MessageDto. It is built and processed by the plugin and you don\u0026rsquo;t need to modify it.\nHowever, it is necessary in some contexts to access certain information such as the sessionId in the case of asynchronous communication or the serverNodeId in the case of synchronous communication with several server instances.\n APIs The class diagrams below shows the different APIs exposed and SPIs required by the Keyple Distributed solution.\nAn SPI (Service Provider Interface) is an interface that must be implemented by the user.\nHere are the available APIs depending on the library imported by your project :\n    Remote Lib Local Lib     Network API ✔️ ✔️   Remote API ✔️    Local API  ✔️    The associated API documentations are accessible from the page API Reference.\nNetwork API The associated API documentation is available here.\n  Remote API The associated API documentation is available here.\n  Local API The associated API documentation is available here.\n   Examples  Java examples   Download  Java components  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"806314cdf014b5d02ec2f6b50544b17e","permalink":"https://keyple.org/docs-1.0/developer-guide/distributed-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/distributed-application/","section":"docs-1.0","summary":"How to develop an end-user application using network communications.","tags":null,"title":"Distributed application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview Keyple API was designed to support an extension system. On top of Keyple Core, APIs can be developed to extend Keyple features. For example, Calypso Network Association provides Keyple Calypso Extension.\nThe use of Keyple Calypso Extension open the ability to operate commands with a Calypso Portable Object and to manage a secure Calypso transaction seamlessly. It completely hides the details of the APDU commands that are sent to POs and SAMs, which are usually tedious operations.\nThe diagram below shows the role of the Keyple Calypso Extension components in the software layers for a standalone application :\n  Before you start  In pre-requisite, have knowledge of the standard Calypso. Read the common concepts page and become familiar with the basic concepts on which Keyple is based. Any implementation of a Keyple application starts with the implementation of Keyple Core, please study the workflow proposed in Standalone application guide. Read chapter Concepts to understand the main terms and concepts of the Keyple Calypso Extension API. Explore the Keyple Calypso API to discover all the possibilities offered by Keyple Calypso Extension. Take inspiration from the examples. Follow the explanations given in the Build your first app section to configure your environment. Using the Java components or C++ components pages, import Keyple Core into your project. Using the Java components or C++ components pages, import Keyple Calypso Extension into your project. Start playing with Keyple.  Concepts Here are the main concepts to keep in mind before continuing to read this user guide :\nCalypso PO Concentrates all known information about the Personal Object being processed. Accessible information are\n The application identification fields (revision/version, class, DF name, serial number, ATR, issuer) The indication of the presence of optional features (Stored Value, PIN, Rev3.2 mode, ratification management) The management information of the session modifications buffer The invalidation status The files, counters, SV data read or modified during the execution of the processes defined by PoTransaction  The Calypso PO fields are first populated from the CardSelectionResponse obtained through the PO selection process then each time a PoTransaction \u0026ldquo;process\u0026rdquo; method is invoked.\n... //Retrieve PO's informations String atr = calypsoPo.getAtr() byte[] applicationSerial+Number = calypsoPo.getApplicationSerialNumber() //SFI_EventLog = 0x08 ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog); //SFI_EnvironmentAndHolder = 0x07 ElementaryFile efEnvironmentAndHolder =calypsoPo.getFileBySfi(SFI_EnvironmentAndHolder); ...  ElementaryFile Object containing the description of a Calypso Elementary File. Can be retrieved from Calypso PO using its SFI.\n... ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog); //Read data content of sevent log elemenatary file String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent()); ...  Calypso SAM Concentrates all the informations we know about the SAM currently selected. Accessible informations are:\n The Sam Revision The Serial number The Platform identifier The Application Type The Application SubType The Software Issuer identifier The Software Version number The Software Revision number  Calypso SAM fields are populated by analysis of the ATR within a CardSelectionResponse obtained through the SAM selection process.\n... byte[] serialNumber = calypsoSam.getSerialNumber() ...  PoSecuritySettings Concentrate the security settings involved in Calypso Secure Sessions:\n A reference to the SAM resource The default KIF The default KVC The default Key Record Number The modification mode The ratification mode The pin transmission mode The default Pin Ciphering Key The SV Get Log Read mode The SV Negative balance mode  The fields are populated with default values when the object is instantiated but can be customized to adjust the settings to the application needs.\n... poSecuritySettings.getSessionModificationMode() ...  Secure session settings can be finely tuned with PoSecuritySettings and a set of enums provided by Keyple:\nModification mode Indicates whether the secure session can be closed and reopened to manage the limitation of the PO buffer memory (session modifications buffer).\n   ModificationMode Description     ATOMIC The secure session is atomic.   MULTIPLE Several secure sessions will be chained (to manage the writing of large amounts of data).    ... PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .svGetLogReadMode(SvSettings.LogRead.ALL) .build(); ...  Ratification mode The ratification mode defines the behavior of processClosing regarding the ratification process.\n   RatificationMode Description     CLOSE_RATIFIED Close session with ratification.   CLOSE_NOT_RATIFIED Close session without ratification    ... PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .ratificationMode(RatificationMode.CLOSE_RATIFIED) .build(); ...  Pin Transmission Mode Defines the PIN transmission modes: plain or encrypted.\n   PinTransmissionMode     PLAIN   ENCRYPTED    SV Log Read mode Specifies whether only one or both SV logs (debit and load) should be read.\n   LogRead     SINGLE   ALL    SV Negative balance mode Specifies whether POs with a negative SV balance should be accepted.\n   NegativeBalance     FORBIDDEN   AUTHORIZED    Basic Operations PoSelection This service provides the means to define a selection case targeting a particular PO (in the ISO 7816-4 sense) with the possibility to collect additional information about the PO before a transaction.\nIt integrates with the Keyple Core Card Selection service to manage the specific features of Calypso POs:\n Sends optional read and/or select commands to the POs right after the initial card selection. Produces a CalypsoPO object from the CardSelectionResponse. The object is filled with the PO identification data from the FCI and the possible responses to additional APDU commands executed after the selection.  ... // Prepare a Calypso PO selection CardSelectionsService cardSelectionsService = new CardSelectionsService(); // Setting of an AID based selection of a Calypso REV3 PO // Select the first application matching the selection AID whatever the card communication // protocol keep the logical channel open after the selection // Calypso selection: configures a PoSelection with all the desired attributes to // make the selection and read additional information afterwards PoSelection poSelection = new PoSelection( PoSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector( CardSelector.AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build()) .invalidatedPo(PoSelector.InvalidatedPo.REJECT) .build()); // Prepare the reading order. poSelection.prepareReadRecordFile( CalypsoClassicInfo.SFI_EnvironmentAndHolder, CalypsoClassicInfo.RECORD_NUMBER_1); // Add the selection case to the current selection (we could have added other cases // here) cardSelectionsService.prepareSelection(poSelection); CalypsoPo calypsoPo = (CalypsoPo) cardSelectionsService.processExplicitSelections(poReader).getActiveSmartCard(); ...  SamSelection This service provides the means to define a selection case targeting a Calypso SAM.\nIt integrates with the Keyple Core Card Selection service to manage the specific features of Calypso SAMs:\n optionally executes an unlock command during the selection process. provides an instance of Calypso SAM.  ... CardSelectionsService samSelection = new CardSelectionsService(); //Sam selection parameters SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.C1).serialNumber(\u0026quot;.*\u0026quot;).build(); samSelection.prepareSelection(new SamSelection(samSelector)); //Sam reader retrieved from registered plugin CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader); if (!cardSelectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;Unable to open a logical channel for SAM!\u0026quot;); } //Cast selected card to CalypsoSam CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard(); ...  PoTransaction Service providing high-level API to manage transactions with a Calypso PO. The tied CalypsoPO Object is kept and updated at each step of using this service.\nThis service workflow is composed of two steps:\n Prepares the commands to be sent to the PO; several command preparations can be stacked (no communication neither with the PO nor with the SAM). Process the prepared commands. Performs all necessary communications with the PO and/or the SAM to carry out the previously prepared operations. CalypsoPo is updated accordingly.  Note:\n Regarding of commands, the presence of SAM is mandatory or not (mandatory when a Calypso Secure Session is open). Pay attention to the number of commands affecting the session modifications buffer, see the ModificationMode setting.  ... // CardResource allow management of specific card. // In this example a SAM is available CardResource\u0026lt;CalypsoPo\u0026gt; poResource = new CardResource\u0026lt;CalypsoPo\u0026gt;(poReader, calypsoPo); CardResource\u0026lt;CalypsoSam\u0026gt; samResource = new CardResource\u0026lt;CalypsoPo\u0026gt;(samReader, calypsoSam); // Configure Security settings // Both Reload and Debit SV logs are requested PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .svGetLogReadMode(SvSettings.LogRead.ALL) .build(); PoTransaction poTransaction = new PoTransaction(poResource, poSecuritySettings); // Read the EventLog file at record 1 within the Session Opening poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_EventLog, CalypsoClassicInfo.RECORD_NUMBER_1); // Open a secure session (DEBIT level) and execute the prepared command poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the EventLog data ElementaryFile efEventLog = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_EventLog); // Example of data parsing String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent()); // Prepare a SV Debit (this command could also have been placed before processOpening // since it is not followed by any other command) poTransaction.prepareSvGet(SvSettings.Operation.DEBIT, SvSettings.Action.DO); // Execute the prepared command poTransaction.processPoCommands(); //Get updated sv balance int svBalance = calypsoPo.getSvBalance() //Get the updated SV last transaction number int svLastTNum = calypsoPo.getSvLastTNum() ...  Secure Session Access level PoTransaction.processOpening() allows to open a Calypso Secure Session. If commands have been prepared previously, they will be executed.\nKeyple provides an enums to easily configure the Secure Session AccessLevel:\n   AccessLevel Description     SESSION_LVL_PERSO Session Access Level used for personalization purposes.   SESSION_LVL_LOAD Session Access Level used for reloading purposes.   SESSION_LVL_DEBIT Session Access Level used for validating and debiting purposes.    Transaction flow and Calypso Secure Session management PoTransaction allows you to process a Calypso Secure session in different ways. These are difficult to describe all in detail but here is an example from which other variants can be obtained.\nA typical Calypso PO transaction flow, for example for ticket validation, could be :\n Execute the selection of a Calypso PO and retrieves the contents of the environment file at the same time. Open a secure session and get the contract list Get the contract and associated counter Decrease the counter, append a new event log Close the secure session  Translated into Keyple Calypso operations, the entire transaction would include the following steps (simplified syntax):\n poSelection = new PoSelection(CARD_IAD) poSelection.prepareReadRecordFile(ENVIRONMENT_SFI) process the poSelection (either explicitly or by default, see the standalone application) guide retrieve CalypsoPo, check its content (environment data) poTransaction = new PoTransaction(calypsoPo) poTransaction.prepareReadRecordFile(CONTRACT_LIST_SFI) poTransaction.processOpening(DEBIT) check CalypsoPo content (contract list), decide which contract/counter to read poTransaction.prepareReadRecordFile(CONTRACT_n) poTransaction.prepareReadRecordFile(COUNTER_n) poTransaction.processPoCommands() check CalypsoPo content (contract/counter), decide action (decrease counter, append event log) poTransaction.prepareDecrease(COUNTER_n, X) poTransaction.prepareAppendRecord(EVENT, event_data poTransaction.prepareReleaseChannel() poTransaction.processClosing()  Examples Detailed use case examples can be seen here:\n PC Android  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"aba7a56586a43cc06ebf4e71294a1a66","permalink":"https://keyple.org/docs-1.0/developer-guide/calypso-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/calypso-application/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   Overview Keyple API was designed to support an extension system.","tags":null,"title":"Calypso application","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Coming soon   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"83fd61e14ab2e663b83a55eb621601ee","permalink":"https://keyple.org/docs-1.0/developer-guide/create-plugin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/create-plugin/","section":"docs-1.0","summary":"How to develop a specific hardware device Keyple plugin.","tags":null,"title":"Create a plugin","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.    Coming soon   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"a5b32f75e801ffb5b3a5b43b2dc75765","permalink":"https://keyple.org/docs-1.0/developer-guide/create-extension/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/create-extension/","section":"docs-1.0","summary":"How to develop a card specific Keyple extension.","tags":null,"title":"Create an extension","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.\nUpgrade from:\n 0.9.0 to 1.0.0 0.8.1 to 0.9.0  Note: here we describe the evolutions in broad outline, for the details of the APIs, the reader is invited to consult the API reference section.\n Upgrade from 0.9.0 to 1.0.0 What\u0026rsquo;s changed? Compared to version 0.9, the goal of Keyple 1.0 is mainly to fix bugs, add features to make Keyple more robust and rename/reorganize classes to make it easier to learn.\n Renamings Internal exception handling PC/SC plugin Keyple Distributed  Class renaming    Module Old name (0.9.0) New name (1.0.0)     Keyple Core SeProxyService SmartCardService   Keyple Core ReaderPlugin Plugin   Keyple Core SeReader Reader   Keyple Core ReaderPoolPlugin PoolPlugin   Keyple Core SeSelection CardSelectionService   Keyple Core SeSelector CardSelector   Keyple Core AbstractMatchingSe AbstractSmartCard   Keyple Calypso PoSelectionRequest PoSelection   Keyple Calypso SamSelectionRequest SamSelection    Internal exception handling New possibilities have been added in the management of observable objects (Plugin and Reader).\nIf the Plugin or Reader is observable, it is now necessary to define exception handlers that will be called by the internal layers of Keyple in the case of an exception raised by an observation process.\nTwo new interfaces have been added to the event package to allow applications via the factories of the concerned plugins to define the method that will be called when needed:\n PluginObservationExceptionHandler ReaderObservationExceptionHandler  These handlers are usually provided by the application via the constructor of the plugin\u0026rsquo;s factory.\nPC/SC plugin The generic parameterization interface for plugins and readers has been removed in favor of methods specific to each plugin.\nIn the case of the PC/SC plugin, the following methods have appeared:\n         PcscPlugin setReaderNameFilter   PcscPlugin setProtocolIdentificationRule   PcscReader setSharingMode   PcscReader setContactless   PcscReader setIsoProtocol   PcscReader setDisconnectionMode    Keyple Distributed The use of Keyple in a remote context has been extensively reviewed and its description is beyond the scope of this guide. Please refer to the distributed application section.\n Upgrade from 0.8.1 to 0.9.0 What\u0026rsquo;s changed? From a user API point of view, the changes relate to the following topics: From a user API point of view, the changes relate to the following topics:\n plugin registration in the SeProxyService preparation of selection cases retrieving selection results definition of the security settings of the transaction creation of the PoTransaction object transaction commands preparation transaction commands processing retrieving data read from POs error handling  Plugin registration in the SeProxyService The registerPlugin method of the SeProxyService class now returns the reference of the registered plugin.\nThis makes it possible, for example, to perform a reader setup in an application such as this one:\n// Create a PcscPlugin and register it into the SeProxyService ReaderPlugin pcscPlugin = seProxyService.registerPlugin(new PcscPluginFactory());` // Get the PO reader from the plugin SeReader poReader = pcscPlugin.getReader(\u0026quot;ASK LoGO 0\u0026quot;);  Preparation of selection cases The AidSelector, Selector and PoSelector classes now follow the Fluent Builder pattern for better handling of optional parameters.\nThe construction of an AidSelector is as follows:\nAidSelector appAidSelector = AidSelector.builder() .aidToSelect(AID) .fileControlInformation(AidSelector.FileControlInformation.FCI) .fileOccurrence(AidSelector.FileOccurrence.FIRST) .build();  The fileControlInformation and fileOccurrence fields are optional (shown here with their default values), so a simple version can be :\nAidSelector aidSelector = AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build();  The construction of a SeSelector is as follows:\nseSelector = SeSelector.builder() .seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4) .aidSelector(appAidSelector) .build();  The PoSelector adds the possibility to specify that an invalidated PO should be processed\nseSelector = SeSelector.builder() .seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4) .aidSelector(appAidSelector) .invalidatedPo(InvalidatedPo.ACCEPT) .build();  The management of PO commands to be performed after the selection step (when it has been successful) is handled by the methods of the PoSelectionRequest class:\n preparing to read files has been simplified and is done using the unique following method:  public void prepareReadRecordFile(byte sfi, int recordNumber)   preparing to select files is done using the following method:  public void prepareSelectFile(byte[] lid) public void prepareSelectFile(short lid)  Note that from now the \u0026ldquo;prepare\u0026rdquo; methods no longer return indexes, the data will be placed in the CalypsoPo object.\nRetrieving selection results The MatchingSelection class no longer exists. In the class SelectionsResult (see processDefaultSelection/processExplicitSelection):\n  getActiveSelection is replaced by getActiveMatchingSe which returns an AbstractMatchingSe object (the still existing hasActiveSelection method must be used before)\n  getMatchingSelection is replaced by getMatchingSe which returns an AbstractMatchingSe object (may be null if the index provided does not correspond to a successful selection case)\n  getMatchingSelections now returns a Map containing a list of associated AbstractMatchingSe with the selection index that produced it (Map\u0026lt;Integer, AbstractMatchingSe\u0026gt;)\n  a new hasSelectionMatched method indicates whether the selection index provided corresponds to a successful selection case\n  a new getActiveSelectionIndex method returns the index of the active selection (the still existing hasActiveSelection method must be used before)\n  Definition of the security settings of the transaction These parameters are defined via the PoSecuritySettings class, whose construction now follows the Fluent Builder pattern.\nAll parameters are optional except the SamResource.\nHere is an example of a complete PoSecuritySettings build:\npoSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .sessionDefaultKif(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KIF_PERSO) .sessionDefaultKif(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KIF_LOAD) .sessionDefaultKif(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KIF_DEBIT) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KEY_RECORD_NUMBER_PERSO) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KEY_RECORD_NUMBER_LOAD) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KEY_RECORD_NUMBER_DEBIT) .sessionModificationMode(ModificationMode.ATOMIC) .ratificationMode(RatificationMode.CLOSE_RATIFIED) .sessionAuthorizedKvcList(authKvcs) .build();  Creation of the PoTransaction object Since PoSecuritySettings now integrates SamResource, the construction of PoTransaction has evolved slightly.\nHere is an example:\nPoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo), poSecuritySettings);  Transaction commands preparation Just as with the \u0026ldquo;prepare\u0026rdquo; commands used for selection, the \u0026ldquo;prepare\u0026rdquo; commands used for transactions no longer return indexes.\nThe available commands in version 0.9 are:\npublic final void prepareSelectFile(SelectFileControl control) public final void prepareSelectFile(short lid) public final void prepareSelectFile(byte[] lid) public final void prepareReadRecordFile(byte sfi, int recordNumber) public final void prepareReadRecordFile(byte sfi, int firstRecordNumber, int numberOfRecords, int recordSize)) public final void prepareReadCounterFile(byte sfi, int countersNumber) public final void prepareUpdateRecord(byte sfi, int recordNumber, byte[] recordData) public final void prepareWriteRecord(byte sfi, int recordNumber, byte[] recordData) public final void prepareAppendRecord(byte sfi, byte[] recordData) public final void prepareIncreaseCounter(byte sfi, int counterNumber, int incValue) public final void prepareDecreaseCounter(byte sfi, int counterNumber, int decValue)  Transaction commands processing The \u0026ldquo;process\u0026rdquo; commands have also been revised and simplified.\nThey all return void.\nIn case of failure a exception is raised (see below).\npublic final void processOpening(PoTransaction.SessionSetting.AccessLevel accessLevel)  The ModificationMode is no longer required since it is integrated in the PoSecuritySettings.\nParameters previously used to specify that a file is read at login are removed.\nInstead, the first prepareReadFile command will be automatically taken into account.\npublic final void processPoCommands() public final void processPoCommandsInSession() public final void processCancel(ChannelControl channelControl) public final void processClosing(ChannelControl channelControl)  Retrieving data read from POs This is a major evolution of the Keyple API. Previously, data read from Calyspo POs were retrieved by applications using \u0026ldquo;parser\u0026rdquo; methods.\nWith Keyple API 0.9, Calypso PO data is made available in the CalypsoPo object obtained during selection and enriched all along the operations performed with PoTransaction.\nThe public getter methods of CalypsoPo are:\npublic final String getDfName() public final byte[] getDfNameBytes() public final String getApplicationSerialNumber() public final byte[] getApplicationSerialNumberBytes() public final String getAtr() public final String getStartupInfo() public final PoRevision getRevision() public final byte getSessionModification() public final byte getApplicationType() public final byte getApplicationSubtype() public final byte getPlatform() public final byte getSoftwareIssuer() public final byte getSoftwareVersion() public final byte getSoftwareRevision() public final boolean isDeselectRatificationSupported() public final boolean isConfidentialSessionModeSupported() public final boolean isPublicAuthenticationSupported() public final boolean isPinFeatureAvailable() public final boolean isSvFeatureAvailable() public final boolean isDfInvalidated() public final boolean isDfRatified() public final DirectoryHeader getDirectoryHeader() public final ElementaryFile getFileBySfi(byte sfi) public final ElementaryFile getFileByLid(short lid) public final Map\u0026lt;Byte, ElementaryFile\u0026gt; getAllFiles()  Four new classes DirectoryHeader, ElementaryFile, FileHeader and FileData have been added.\nDirectoryHeader The public getters for this class are:\npublic short getLid() public byte[] getAccessConditions() public byte[] getKeyIndexes() public byte getDfStatus() public byte getKif(AccessLevel level) public byte getKvc(AccessLevel level) public String toString()  ElementaryFile The public getters for this class are:\npublic byte getSfi() public FileHeader getHeader() public FileData getData() public String toString()  FileHeader The public getters for this class are:\npublic short getLid() public int getRecordsNumber() public int getRecordSize() public FileType getType() public byte getDfStatus() public boolean isShared() public Short getSharedReference() public byte[] getAccessConditions() public byte[] getKeyIndexes() public String toString()  FileData The public getters for this class are:\npublic byte[] getContent() public byte[] getContent(int numRecord) public byte[] getContent(int numRecord, int dataOffset, int dataLength) public SortedMap\u0026lt;Integer, byte[]\u0026gt; getAllRecordsContent() public int getContentAsCounterValue(int numCounter) public SortedMap\u0026lt;Integer, Integer\u0026gt; getAllCountersValue() public String toString()  So, for example to extract the contents of contract files present in the PO, the code might look like this:\n[...] /* Read all 4 contracts command, record size set to 29 */ poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Contracts, CalypsoClassicInfo.RECORD_NUMBER_1, 4, 29); /* proceed with the sending of commands, don't close the channel */ poTransaction.processPoCommandsInSession(); ElementaryFile efContracts = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_Contracts); SortedMap\u0026lt;Integer, byte[]\u0026gt; records = efContracts.getData().getAllRecordsContent(); for (Map.Entry\u0026lt;Integer, byte[]\u0026gt; entry : records.entrySet()) { logger.info(\u0026quot;Contract #{}: {}\u0026quot;, entry.getKey(), ByteArrayUtil.toHex(entry.getValue())); } [...]  Error handling Since version 0.9, all Keyple exceptions are of the RuntimeException type.\nCatching exceptions is therefore now optional.\nHowever, it is possible to selectively catch certain exceptions in order to deal with particular cases.\nThe new hierarchy of Keyple exceptions is shown here\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"58148a9cca027f27c7a528e35b5067df","permalink":"https://keyple.org/docs-1.0/developer-guide/upgrade/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/developer-guide/upgrade/","section":"docs-1.0","summary":"Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   This guide is intended to help a user of a previous version of Keyple Java to upgrade his application to a new version of the library.","tags":null,"title":"Upgrade from an earlier version of Keyple","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   The JavaDoc for the Keyple project is available online. The documentation is split into the following parts:\n 1.0.0 0.9.0 0.8.1  Modules    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"8d687977622d8d6b9b85d04b2a779416","permalink":"https://keyple.org/docs-1.0/api-reference/java-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/api-reference/java-api/","section":"docs-1.0","summary":"The JavaDoc for the Keyple project is available online.","tags":null,"title":"Java API reference","type":"book"},{"authors":null,"categories":null,"content":" Version 1.0 of the documentation is no longer actively maintained. The site that you are currently viewing is an archived snapshot. For up-to-date documentation, see the latest version.   The Doxygen document for the Keyple project is available online. The documentation is split into the following parts:\n 0.9.0  Modules    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"fb1dfca08161793f4898bad52698217f","permalink":"https://keyple.org/docs-1.0/api-reference/cpp-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs-1.0/api-reference/cpp-api/","section":"docs-1.0","summary":"The C++ documentation for the Keyple project will be available online.","tags":null,"title":"C++ API reference","type":"book"},{"authors":["Calypso Networks Association"],"categories":["Release"],"content":"All the components of Eclipse Keyple Java have been release in version 2.0.0:\n at the core level: the Keyple Service, the Plugin API, the shared references, the helper functions, and the card resource manager, the distribution module inluding: the remote API, the remote lib, the local API, the local lib, the network messaging lib, the card extension libraries for generic card, and Calypso card, the standard plugins for PC/SC, Stub reader, NFC Android, and OMAPI Android.  The components have no longer dependency on each other and can evolve separately. Keyple Java follows now the version 1.0 of the Calypso terminal API defined by the Calypso Networks Association.\n","date":1633518e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636966723,"objectID":"044868e24c9230bbadaa956095979439","permalink":"https://keyple.org/post/release-2-0-0-java/","publishdate":"2021-10-06T12:00:00+01:00","relpermalink":"/post/release-2-0-0-java/","section":"post","summary":"Version 2.0.0 of the Java implementation of Eclipse Keyple® was released on October 06, 2021.","tags":["Eclipse","Keyple","Release","OpenSource","SDK","API","Ticketing","Calypso"],"title":"Release 2.0.0 of Eclipse Keyple® Java","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Release"],"content":"We are pleased to announce that the version 0.9.0 of the C++ implementation of Eclipse Keyple® was released January 26th, 2021.\nThis 0.9.0 C++ Keyple implementation follows the API design for the 0.9.0 Java Keyple implementation.\n New simplifications are introduced on the Calypso API. Keyple 0.8 had a high-level API for building map commands, but the map response data needed to be parsed with a low-level API. The Calypso 0.9.0 API provided a high-level API for retrieving map response data from a map image for which the file structure could be browsed. The Core 0.9.0 has also made the reader observation function more reliable in order to be notified in case of card withdrawal.  C++ API reference\nBuild your first C++ application\nThe source of Keyple C++ is available on https://github.com/eclipse/keyple-cpp. Some dedicated support is provided on keyple.org:\n the documentation of the C++ API a guide to Build a first C++ application  ","date":1611665876,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"857c7e6e71885778697df385b67d141c","permalink":"https://keyple.org/post/release-0-9-0-cpp/","publishdate":"2021-01-26T14:57:56+02:00","relpermalink":"/post/release-0-9-0-cpp/","section":"post","summary":"Version 0.9.0 of the Java implementation of Eclipse Keyple® was released January 26, 2021.","tags":["Eclipse","Keyple","Release","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"Release 0.9.0 C++ on the field","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Release"],"content":"The release 1.0.0 of Eclipse Keyple® Java is available.\nMost of the improvements concerns the Keyple Core:\n the new Core extension to manage \u0026ldquo;distributed architecture\u0026rdquo; and operate remote smart card readers, some packages \u0026amp; classes renaming to facilitate the understanding, the setting of smart card reader has also been simplified. The NFC \u0026amp; OMAPI Android plugins have been optimized for all Android versions from 4.4.  A new Keyple website provides the documentation and guides to handle the Keyple solution.\n","date":1608222281,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633093922,"objectID":"645ecdec44738be2a777ceaa4263992b","permalink":"https://keyple.org/post/release-1-0-0-java/","publishdate":"2020-12-17T17:24:41+01:00","relpermalink":"/post/release-1-0-0-java/","section":"post","summary":"Version 1.0.0 of the Java implementation of Eclipse Keyple® was released December 17, 2020.","tags":["Eclipse","Keyple","Release","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"Release 1.0.0 of Eclipse Keyple® Java","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Events"],"content":"Are you a mobility aggregator, a system integrator, an event manager, a developer or a multi-mobility startup? Do you want to have easy access to a highly secure and interoperable standard, Calypso®, to reduce your costs and accelerate your developments, to move from a black box to an open and modular solution with access to multiple hardware platforms, to enable partnerships with multimodal transport, building facilities including parking, tourism and events… or just discover what Eclipse Keyple® is and how it works?\nOn October 15, 2020, we organized a webinar Eclipse Keyple® for Developers!\nSee the whole event on video:     Discover the presentation.\n","date":1601038643,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"893cbaacbce8fe50e13670aac253661a","permalink":"https://keyple.org/post/webinar-eclipse-keyple-developers-oct15-2020/","publishdate":"2020-09-25T14:57:23+02:00","relpermalink":"/post/webinar-eclipse-keyple-developers-oct15-2020/","section":"post","summary":"Are you a mobility aggregator, a system integrator, an event manager, a developer or a multi-mobility startup?","tags":["Eclipse","Keyple","Events","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA","Mobility"],"title":"Webinar Eclipse Keyple® for Developers, Thursday, October 15, 2020 ","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Release"],"content":"We are pleased to announce that the version 0.9.0 of the Java implementation of Eclipse Keyple® was released September 11th, 2020.\nThe main improvement on the Calypso® extension is the addition of high-level API to manage the portable object response. Now the APDU responses of the Calypso® cards are automatically parsed to fill card images. Currently all the components of Eclipse Keyple® Java are following the same versioning.\nFrom the version 1.0.0 scheduled for November 2020, the components will be defined with their own versioning in order to stabilize as possible the different APIs.\nDocumentation currently available:\n the project plan, the guides of the different public API, and a guide to manage the migration between the release 0.8.1 \u0026amp; 0.9.0.  ","date":1600433876,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"b73458a3048ddd5b999490db1ff58736","permalink":"https://keyple.org/post/release-0-9-0-java/","publishdate":"2020-09-18T14:57:56+02:00","relpermalink":"/post/release-0-9-0-java/","section":"post","summary":"Version 0.9.0 of the Java implementation of Eclipse Keyple® was released September 11, 2020.","tags":["Eclipse","Keyple","Release","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"Release 0.9.0 Java on the field","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Events"],"content":"On October 17, 2019, we organized the first Meet Up Eclipse Keyple®! Great moments of exchanges around the first Open Source SDK for Ticketing with Benoît Boute, Nicolas Generali, Pierre Terree, Hicham Elbizy, Benoist Laforge, Gaël Blondelle, Camille Moulin, Philippe Vappereau, Valentina Zajackowski. Many thanks to them for their interventions and also to Manon Chaix, Jean-Pierre Fortune, Olivier Delcroix, Ludovic Teixeira Costa and all the participants!\nSee the whole event on video:     Discover the presentation.\n  Discover the photos.\n","date":1571270400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633942038,"objectID":"33404383739ed4d1c8c4bd9333070a94","permalink":"https://keyple.org/post/first-meetup-eclipse-keyple/","publishdate":"2019-10-17T00:00:00Z","relpermalink":"/post/first-meetup-eclipse-keyple/","section":"post","summary":"On October 17, 2019, we organized the first Meet Up Eclipse Keyple®!","tags":["Eclipse","Keyple","Events","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"First Meet Up Eclipse Keyple®","type":"post"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Plugin Android NFC Java Library is an add-on to manage Android NFC readers.\nTherefore, it should be used only by application developers.\nIt is compatible with Android 4.4 minimum.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-plugin-android-nfc-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-android-nfc-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-android-nfc-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"bd7db3922350008a662f4438da2f7110","permalink":"https://keyple.org/components-java/standard-reader-plugins/keyple-plugin-android-nfc-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standard-reader-plugins/keyple-plugin-android-nfc-java-lib/","section":"components-java","summary":"Add-on to manage Android NFC readers.","tags":null,"title":"Keyple Plugin Android NFC Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Plugin Android OMAPI Java Library is an add-on to manage Android OMAPI readers.\nTherefore, it should be used only by application developers.\nIt is compatible with Android 4.4 minimum.\nOMAPI (Open Mobile Application Programming Interface) is the mechanism which enables an authorized mobile app to communicate with applets within a SE in a device. This allows the app to benefit from enhanced SE-based security services.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-plugin-android-omapi-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-android-omapi-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-android-omapi-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"9bcbfbab4a8fbf1ee34813885d0afb25","permalink":"https://keyple.org/components-java/standard-reader-plugins/keyple-plugin-android-omapi-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standard-reader-plugins/keyple-plugin-android-omapi-java-lib/","section":"components-java","summary":"Add-on to manage Android OMAPI readers.","tags":null,"title":"Keyple Plugin Android OMAPI Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.1  Download  GitHub  Changelog   Overview The Keyple Card Calypso Java Library is an add-on to manage Calypso® cards.\nTherefore, it should be used only by application developers.\nIt can be used on PC, MAC and Android platforms.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-card-calypso-java-lib:2.0.1\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-card-calypso-java-lib:2.0.1\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-card-calypso-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"dea4618f9996649bac97a6610a14113d","permalink":"https://keyple.org/components-java/card-extensions/keyple-card-calypso-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/card-extensions/keyple-card-calypso-java-lib/","section":"components-java","summary":"Add-on to manage Calypso® cards.","tags":null,"title":"Keyple Card Calypso Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Common Java API defines the public elements shared between all Keyple libraries.\nTherefore, it must be used by all developers.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-common-java-api:2.0.\u0026#43;\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-common-java-api:2.0.\u0026#43;\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-common-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,2.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Therefore, it is recommended to always perform a dynamic import as described above in order to have the most up-to-date documentation.   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"7f6f6307e21a2fa55b1c7f2149d812f4","permalink":"https://keyple.org/components-java/core/keyple-common-java-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-common-java-api/","section":"components-java","summary":"Public API which defines the elements shared between all Keyple libraries.","tags":null,"title":"Keyple Common Java API","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Distributed Local Java API defines the internal API dedicated to the development of local services components of the Keyple distributed solution.\nTherefore, it must be used only by developers of custom local services.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-distributed-local-java-api:2.0.\u0026#43;\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-local-java-api:2.0.\u0026#43;\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-local-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,2.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Therefore, it is recommended to always perform a dynamic import as described above in order to have the most up-to-date documentation.   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"1048737edf9c601b7ce2f5c067e40f1f","permalink":"https://keyple.org/components-java/core/keyple-distributed-local-java-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-distributed-local-java-api/","section":"components-java","summary":"Internal API dedicated to the development of custom local services components of the Keyple distributed solution.","tags":null,"title":"Keyple Distributed Local Java API","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Distributed Remote Java API defines the internal API dedicated to the development of remote plugins components of the Keyple distributed solution.\nTherefore, it must be used only by developers of custom remote plugins.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-distributed-remote-java-api:2.0.\u0026#43;\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-remote-java-api:2.0.\u0026#43;\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-remote-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,2.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Therefore, it is recommended to always perform a dynamic import as described above in order to have the most up-to-date documentation.   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"0d0e032702ca0479c1cbfd9c6045d941","permalink":"https://keyple.org/components-java/core/keyple-distributed-remote-java-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-distributed-remote-java-api/","section":"components-java","summary":"Internal API dedicated to the development of custom remote plugins components of the Keyple distributed solution.","tags":null,"title":"Keyple Distributed Remote Java API","type":"book"},{"authors":null,"categories":null,"content":" 2.0.1  Download  GitHub  Changelog   Overview The Keyple Card Generic Java Library is an add-on to manage cards with low-level API.\nTherefore, it should be used only by application developers.\nIt can be used on PC, MAC and Android platforms.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-card-generic-java-lib:2.0.1\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-card-generic-java-lib:2.0.1\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-card-generic-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635429016,"objectID":"0fcb584c242b3750e7eb869b4c7d758f","permalink":"https://keyple.org/components-java/card-extensions/keyple-card-generic-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/card-extensions/keyple-card-generic-java-lib/","section":"components-java","summary":"Add-on to manage cards with low-level API.","tags":null,"title":"Keyple Card Generic Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Distributed Local Java Library is the part of the Keyple Distributed solution which contains all the local services.\nTherefore, it should be used only by developers of applications installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-distributed-local-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-local-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-local-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"8808dc0fbab341cb5470de793ff1fab3","permalink":"https://keyple.org/components-java/distributed/keyple-distributed-local-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/distributed/keyple-distributed-local-java-lib/","section":"components-java","summary":"Part of the Keyple Distributed solution which contains all the local services.","tags":null,"title":"Keyple Distributed Local Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Distributed Network Java Library is the part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.\nTherefore, it should be used only by developers of distributed applications.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-distributed-network-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-network-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-network-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"69a8da20d131a5f29b601bf640f9f1f4","permalink":"https://keyple.org/components-java/distributed/keyple-distributed-network-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/distributed/keyple-distributed-network-java-lib/","section":"components-java","summary":"Part of the Keyple Distributed solution which contains the common network elements used by Local and Remote components.","tags":null,"title":"Keyple Distributed Network Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Plugin PC/SC Java Library is an add-on to manage PC/SC readers.\nTherefore, it should be used only by application developers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-pcsc-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"4ca077c92c9c3b00b06933edf9e59314","permalink":"https://keyple.org/components-java/standard-reader-plugins/keyple-plugin-pcsc-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standard-reader-plugins/keyple-plugin-pcsc-java-lib/","section":"components-java","summary":"Add-on to manage PC/SC readers.","tags":null,"title":"Keyple Plugin PC/SC Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Plugin Java API defines the internal API dedicated to the development of reader plugins components.\nTherefore, it must be used only by developers of custom reader plugins.\nDocumentation  API documentation Developer guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-plugin-java-api:2.0.\u0026#43;\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-java-api:2.0.\u0026#43;\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-java-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,2.1.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    The third version number (x.y.z) only concerns updates of the javadoc because this component does not contain any implementation, but only an API. Therefore, it is recommended to always perform a dynamic import as described above in order to have the most up-to-date documentation.   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"ba35c3725e6ab8a0c5ca7ce6a80b688a","permalink":"https://keyple.org/components-java/core/keyple-plugin-java-api/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-plugin-java-api/","section":"components-java","summary":"Internal API dedicated to the development of custom reader plugins components.","tags":null,"title":"Keyple Plugin Java API","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Distributed Remote Java Library is the part of the Keyple Distributed solution which contains all the remote plugins.\nTherefore, it should be used only by developers of applications installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-distributed-remote-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-distributed-remote-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-distributed-remote-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"1ce42180cbd0b20abde8fb83253d0da9","permalink":"https://keyple.org/components-java/distributed/keyple-distributed-remote-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/distributed/keyple-distributed-remote-java-lib/","section":"components-java","summary":"Part of the Keyple Distributed solution which contains all the remote plugins.","tags":null,"title":"Keyple Distributed Remote Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.1  Download  GitHub  Changelog   Overview The Keyple Service Java Library contains the implementation of the core Keyple components and services, such as the smart card service, the card selection manager or the card and reader event manager.\nTherefore, it must be used only by application developers.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-service-java-lib:2.0.1\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-service-java-lib:2.0.1\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-service-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"540be2d93dae6b75a883ee318126ac6c","permalink":"https://keyple.org/components-java/core/keyple-service-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-service-java-lib/","section":"components-java","summary":"Main library containing the implementation of the core Keyple components and services.","tags":null,"title":"Keyple Service Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.1  Download  GitHub  Changelog   Overview The Keyple Service Resource Java Library is an add-on providing profile-based card resource allocation mechanism.\nTherefore, it can be used by developers of applications or card extensions.\nDocumentation  API documentation User guide  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-service-resource-java-lib:2.0.1\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-service-resource-java-lib:2.0.1\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-service-resource-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"2c6b7e12e4bce3bcf04f3e69ce8eb56d","permalink":"https://keyple.org/components-java/core/keyple-service-resource-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-service-resource-java-lib/","section":"components-java","summary":"Add-on library providing profile-based card resource allocation mechanism.","tags":null,"title":"Keyple Service Resource Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Plugin Stub Java Library is an add-on to manage virtual readers and cards.\nTherefore, it should be used only by application developers.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-plugin-stub-java-lib:2.0.0\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-plugin-stub-java-lib:2.0.0\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-stub-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"2af96180d181763dc0f342c11605e2c0","permalink":"https://keyple.org/components-java/standard-reader-plugins/keyple-plugin-stub-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/standard-reader-plugins/keyple-plugin-stub-java-lib/","section":"components-java","summary":"Add-on to manage virtual readers and cards.","tags":null,"title":"Keyple Plugin Stub Java Library","type":"book"},{"authors":null,"categories":null,"content":" 2.0.0  Download  GitHub  Changelog   Overview The Keyple Util Java Library contains utility classes used by all Keyple libraries.\nTherefore, it can be used by all developers.\nDocumentation  API documentation  Download All deliverables are available directly from the Maven Central Repository or by using one of the project resource managers below:\nGradle Groovy  Gradle Kotlin  Maven   Copy implementation \u0026#39;org.eclipse.keyple:keyple-util-java-lib:2.\u0026#43;\u0026#39;  implementation(\u0026#34;org.eclipse.keyple:keyple-util-java-lib:2.\u0026#43;\u0026#34;)  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-util-java-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,3.0.0)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    Since this library is used by all Keyple libraries, it is recommended to explicitly perform a dynamic import of the library for a given major version. This ensures compatibility with all the used libraries.   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1635264586,"objectID":"3ef929c863a885aee9c2533733bef4ce","permalink":"https://keyple.org/components-java/core/keyple-util-java-lib/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/components-java/core/keyple-util-java-lib/","section":"components-java","summary":"Utility classes for Keyple components.","tags":null,"title":"Keyple Util Java Library","type":"book"}]